<HTML>
<HEAD>
<TITLE>Listing of ../framework/usb/src/usb_device.c</TITLE>
<LINK rel=stylesheet href="udf_styles.css" type="text/css">
</HEAD>
<BODY>
<table class="">
<tr><td><code><i>     1</i> </code></td><td><code>&nbsp /*******************************************************************************</code></td></tr>
<tr><td><code><i>     2</i> </code></td><td><code>&nbsp &nbsp&nbsp USB&nbsp Device&nbsp Layer</code></td></tr>
<tr><td><code><i>     3</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>     4</i> </code></td><td><code>&nbsp &nbsp&nbsp Company:</code></td></tr>
<tr><td><code><i>     5</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Microchip&nbsp Technology&nbsp Inc.</code></td></tr>
<tr><td><code><i>     6</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>     7</i> </code></td><td><code>&nbsp &nbsp&nbsp File&nbsp Name:</code></td></tr>
<tr><td><code><i>     8</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp usb_device.c</code></td></tr>
<tr><td><code><i>     9</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    10</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>    11</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp Provides&nbsp basic&nbsp USB&nbsp device&nbsp functionality,&nbsp including&nbsp enumeration&nbsp and&nbsp USB</code></td></tr>
<tr><td><code><i>    12</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp chapter&nbsp 9&nbsp required&nbsp behavior.</code></td></tr>
<tr><td><code><i>    13</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    14</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>    15</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp Provides&nbsp basic&nbsp USB&nbsp device&nbsp functionality,&nbsp including&nbsp enumeration&nbsp and&nbsp USB</code></td></tr>
<tr><td><code><i>    16</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp chapter&nbsp 9&nbsp required&nbsp behavior.</code></td></tr>
<tr><td><code><i>    17</i> </code></td><td><code>&nbsp *******************************************************************************/</code></td></tr>
<tr><td><code><i>    18</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    19</i> </code></td><td><code>&nbsp //&nbsp DOM-IGNORE-BEGIN</code></td></tr>
<tr><td><code><i>    20</i> </code></td><td><code>&nbsp /*******************************************************************************</code></td></tr>
<tr><td><code><i>    21</i> </code></td><td><code>&nbsp Copyright&nbsp (c)&nbsp 2013&nbsp released&nbsp Microchip&nbsp Technology&nbsp Inc.&nbsp&nbsp All&nbsp rights&nbsp reserved.</code></td></tr>
<tr><td><code><i>    22</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    23</i> </code></td><td><code>&nbsp Microchip&nbsp licenses&nbsp to&nbsp you&nbsp the&nbsp right&nbsp to&nbsp use,&nbsp modify,&nbsp copy&nbsp and&nbsp distribute</code></td></tr>
<tr><td><code><i>    24</i> </code></td><td><code>&nbsp Software&nbsp only&nbsp when&nbsp embedded&nbsp on&nbsp a&nbsp Microchip&nbsp microcontroller&nbsp or&nbsp digital&nbsp signal</code></td></tr>
<tr><td><code><i>    25</i> </code></td><td><code>&nbsp controller&nbsp that&nbsp is&nbsp integrated&nbsp into&nbsp your&nbsp product&nbsp or&nbsp third&nbsp party&nbsp product</code></td></tr>
<tr><td><code><i>    26</i> </code></td><td><code>&nbsp (pursuant&nbsp to&nbsp the&nbsp sublicense&nbsp terms&nbsp in&nbsp the&nbsp accompanying&nbsp license&nbsp agreement).</code></td></tr>
<tr><td><code><i>    27</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    28</i> </code></td><td><code>&nbsp You&nbsp should&nbsp refer&nbsp to&nbsp the&nbsp license&nbsp agreement&nbsp accompanying&nbsp this&nbsp Software&nbsp for</code></td></tr>
<tr><td><code><i>    29</i> </code></td><td><code>&nbsp additional&nbsp information&nbsp regarding&nbsp your&nbsp rights&nbsp and&nbsp obligations.</code></td></tr>
<tr><td><code><i>    30</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    31</i> </code></td><td><code>&nbsp SOFTWARE&nbsp AND&nbsp DOCUMENTATION&nbsp ARE&nbsp PROVIDED&nbsp "AS&nbsp IS"&nbsp WITHOUT&nbsp WARRANTY&nbsp OF&nbsp ANY&nbsp KIND,</code></td></tr>
<tr><td><code><i>    32</i> </code></td><td><code>&nbsp EITHER&nbsp EXPRESS&nbsp OR&nbsp IMPLIED,&nbsp INCLUDING&nbsp WITHOUT&nbsp LIMITATION,&nbsp ANY&nbsp WARRANTY&nbsp OF</code></td></tr>
<tr><td><code><i>    33</i> </code></td><td><code>&nbsp MERCHANTABILITY,&nbsp TITLE,&nbsp NON-INFRINGEMENT&nbsp AND&nbsp FITNESS&nbsp FOR&nbsp A&nbsp PARTICULAR&nbsp PURPOSE.</code></td></tr>
<tr><td><code><i>    34</i> </code></td><td><code>&nbsp IN&nbsp NO&nbsp EVENT&nbsp SHALL&nbsp MICROCHIP&nbsp OR&nbsp ITS&nbsp LICENSORS&nbsp BE&nbsp LIABLE&nbsp OR&nbsp OBLIGATED&nbsp UNDER</code></td></tr>
<tr><td><code><i>    35</i> </code></td><td><code>&nbsp CONTRACT,&nbsp NEGLIGENCE,&nbsp STRICT&nbsp LIABILITY,&nbsp CONTRIBUTION,&nbsp BREACH&nbsp OF&nbsp WARRANTY,&nbsp OR</code></td></tr>
<tr><td><code><i>    36</i> </code></td><td><code>&nbsp OTHER&nbsp LEGAL&nbsp EQUITABLE&nbsp THEORY&nbsp ANY&nbsp DIRECT&nbsp OR&nbsp INDIRECT&nbsp DAMAGES&nbsp OR&nbsp EXPENSES</code></td></tr>
<tr><td><code><i>    37</i> </code></td><td><code>&nbsp INCLUDING&nbsp BUT&nbsp NOT&nbsp LIMITED&nbsp TO&nbsp ANY&nbsp INCIDENTAL,&nbsp SPECIAL,&nbsp INDIRECT,&nbsp PUNITIVE&nbsp OR</code></td></tr>
<tr><td><code><i>    38</i> </code></td><td><code>&nbsp CONSEQUENTIAL&nbsp DAMAGES,&nbsp LOST&nbsp PROFITS&nbsp OR&nbsp LOST&nbsp DATA,&nbsp COST&nbsp OF&nbsp PROCUREMENT&nbsp OF</code></td></tr>
<tr><td><code><i>    39</i> </code></td><td><code>&nbsp SUBSTITUTE&nbsp GOODS,&nbsp TECHNOLOGY,&nbsp SERVICES,&nbsp OR&nbsp ANY&nbsp CLAIMS&nbsp BY&nbsp THIRD&nbsp PARTIES</code></td></tr>
<tr><td><code><i>    40</i> </code></td><td><code>&nbsp (INCLUDING&nbsp BUT&nbsp NOT&nbsp LIMITED&nbsp TO&nbsp ANY&nbsp DEFENSE&nbsp THEREOF),&nbsp OR&nbsp OTHER&nbsp SIMILAR&nbsp COSTS.</code></td></tr>
<tr><td><code><i>    41</i> </code></td><td><code>&nbsp *******************************************************************************/</code></td></tr>
<tr><td><code><i>    42</i> </code></td><td><code>&nbsp //&nbsp DOM-IGNORE-END</code></td></tr>
<tr><td><code><i>    43</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    44</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    45</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>    46</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>    47</i> </code></td><td><code>&nbsp //&nbsp Section:&nbsp Included&nbsp Files</code></td></tr>
<tr><td><code><i>    48</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>    49</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>    50</i> </code></td><td><code>&nbsp #include&nbsp&lsaquo  stdint.h&rsaquo  </code></td></tr>
<tr><td><code><i>    51</i> </code></td><td><code>&nbsp #include&nbsp&lsaquo  stddef.h&rsaquo  </code></td></tr>
<tr><td><code><i>    52</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    53</i> </code></td><td><code>&nbsp #include&nbsp "system.h"</code></td></tr>
<tr><td><code><i>    54</i> </code></td><td><code>&nbsp #include&nbsp "system_config.h"</code></td></tr>
<tr><td><code><i>    55</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    56</i> </code></td><td><code>&nbsp #include&nbsp "usb.h"</code></td></tr>
<tr><td><code><i>    57</i> </code></td><td><code>&nbsp #include&nbsp "usb_ch9.h"</code></td></tr>
<tr><td><code><i>    58</i> </code></td><td><code>&nbsp #include&nbsp "usb_device.h"</code></td></tr>
<tr><td><code><i>    59</i> </code></td><td><code>&nbsp #include&nbsp "usb_device_local.h"</code></td></tr>
<tr><td><code><i>    60</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    61</i> </code></td><td><code>&nbsp #if&nbsp defined(USB_USE_MSD)</code></td></tr>
<tr><td><code><i>    62</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #include&nbsp "usb_device_msd.h"</code></td></tr>
<tr><td><code><i>    63</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>    64</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    65</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>    66</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>    67</i> </code></td><td><code>&nbsp //&nbsp Section:&nbsp File&nbsp Scope&nbsp or&nbsp Global&nbsp Constants</code></td></tr>
<tr><td><code><i>    68</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>    69</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>    70</i> </code></td><td><code>&nbsp #if&nbsp !defined(USE_USB_BUS_SENSE_IO)</code></td></tr>
<tr><td><code><i>    71</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Assume&nbsp the&nbsp +5V&nbsp VBUS&nbsp is&nbsp always&nbsp present&nbsp (like&nbsp it&nbsp would&nbsp be&nbsp in&nbsp a&nbsp bus&nbsp powered</code></td></tr>
<tr><td><code><i>    72</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //only&nbsp application),&nbsp unless&nbsp USE_USB_BUS_SENSE_IO&nbsp and&nbsp USB_BUS_SENSE&nbsp have</code></td></tr>
<tr><td><code><i>    73</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //been&nbsp properly&nbsp defined&nbsp elsewhere&nbsp in&nbsp the&nbsp project.</code></td></tr>
<tr><td><code><i>    74</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #undef&nbsp USB_BUS_SENSE</code></td></tr>
<tr><td><code><i>    75</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #define&nbsp USB_BUS_SENSE&nbsp 1</code></td></tr>
<tr><td><code><i>    76</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>    77</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    78</i> </code></td><td><code>&nbsp #if&nbsp defined(USB_DEVICE_DISABLE_DTS_CHECKING)</code></td></tr>
<tr><td><code><i>    79</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #define&nbsp _DTS_CHECKING_ENABLED&nbsp 0</code></td></tr>
<tr><td><code><i>    80</i> </code></td><td><code>&nbsp #else</code></td></tr>
<tr><td><code><i>    81</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #define&nbsp _DTS_CHECKING_ENABLED&nbsp _DTSEN</code></td></tr>
<tr><td><code><i>    82</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>    83</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    84</i> </code></td><td><code>&nbsp #if&nbsp !defined(self_power)</code></td></tr>
<tr><td><code><i>    85</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Assume&nbsp the&nbsp application&nbsp is&nbsp always&nbsp bus&nbsp powered,&nbsp unless&nbsp self_power&nbsp has&nbsp been</code></td></tr>
<tr><td><code><i>    86</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //defined&nbsp elsewhere&nbsp in&nbsp the&nbsp project</code></td></tr>
<tr><td><code><i>    87</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #define&nbsp self_power&nbsp 0&nbsp&nbsp&nbsp&nbsp //0&nbsp =&nbsp bus&nbsp powered</code></td></tr>
<tr><td><code><i>    88</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>    89</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    90</i> </code></td><td><code>&nbsp #if&nbsp !defined(USB_MAX_NUM_CONFIG_DSC)</code></td></tr>
<tr><td><code><i>    91</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Assume&nbsp the&nbsp application&nbsp only&nbsp implements&nbsp one&nbsp configuration&nbsp descriptor,</code></td></tr>
<tr><td><code><i>    92</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //unless&nbsp otherwise&nbsp specified&nbsp elsewhere&nbsp in&nbsp the&nbsp project</code></td></tr>
<tr><td><code><i>    93</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #define&nbsp USB_MAX_NUM_CONFIG_DSC&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 1</code></td></tr>
<tr><td><code><i>    94</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>    95</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    96</i> </code></td><td><code>&nbsp #if&nbsp defined(__XC8)</code></td></tr>
<tr><td><code><i>    97</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Suppress&nbsp expected/harmless&nbsp compiler&nbsp warning&nbsp message&nbsp about&nbsp unused&nbsp RAM&nbsp variables</code></td></tr>
<tr><td><code><i>    98</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //and&nbsp certain&nbsp function&nbsp pointer&nbsp usage.</code></td></tr>
<tr><td><code><i>    99</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Certain&nbsp variables&nbsp and&nbsp function&nbsp pointers&nbsp are&nbsp not&nbsp used&nbsp if&nbsp you&nbsp don't&nbsp use&nbsp all</code></td></tr>
<tr><td><code><i>   100</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //of&nbsp the&nbsp USB&nbsp stack&nbsp APIs.&nbsp&nbsp However,&nbsp these&nbsp variables&nbsp should&nbsp not&nbsp be</code></td></tr>
<tr><td><code><i>   101</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //removed&nbsp (since&nbsp they&nbsp are&nbsp still&nbsp used/needed&nbsp in&nbsp some&nbsp applications,&nbsp and&nbsp this</code></td></tr>
<tr><td><code><i>   102</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //is&nbsp a&nbsp common&nbsp file&nbsp shared&nbsp by&nbsp many&nbsp projects,&nbsp some&nbsp of&nbsp which&nbsp rely&nbsp on&nbsp the&nbsp "unused"</code></td></tr>
<tr><td><code><i>   103</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //variables/function&nbsp pointers).</code></td></tr>
<tr><td><code><i>   104</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #pragma&nbsp warning&nbsp disable&nbsp 1090</code></td></tr>
<tr><td><code><i>   105</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp __XC8_VERSION&nbsp&rsaquo &nbsp 1300</code></td></tr>
<tr><td><code><i>   106</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #pragma&nbsp warning&nbsp disable&nbsp 1471</code></td></tr>
<tr><td><code><i>   107</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   108</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>   109</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   110</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   111</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   112</i> </code></td><td><code>&nbsp //&nbsp Section:&nbsp File&nbsp Scope&nbsp Data&nbsp Types</code></td></tr>
<tr><td><code><i>   113</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   114</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   115</i> </code></td><td><code>&nbsp typedef&nbsp union</code></td></tr>
<tr><td><code><i>   116</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   117</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp Val;</code></td></tr>
<tr><td><code><i>   118</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp struct&nbsp __PACKED</code></td></tr>
<tr><td><code><i>   119</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   120</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp unsigned&nbsp b0:1;</code></td></tr>
<tr><td><code><i>   121</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp unsigned&nbsp b1:1;</code></td></tr>
<tr><td><code><i>   122</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp unsigned&nbsp b2:1;</code></td></tr>
<tr><td><code><i>   123</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp unsigned&nbsp b3:1;</code></td></tr>
<tr><td><code><i>   124</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp unsigned&nbsp b4:1;</code></td></tr>
<tr><td><code><i>   125</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp unsigned&nbsp b5:1;</code></td></tr>
<tr><td><code><i>   126</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp unsigned&nbsp b6:1;</code></td></tr>
<tr><td><code><i>   127</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp unsigned&nbsp b7:1;</code></td></tr>
<tr><td><code><i>   128</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }&nbsp bits;</code></td></tr>
<tr><td><code><i>   129</i> </code></td><td><code>&nbsp }&nbsp uint8_t_VAL,&nbsp uint8_t_BITS;</code></td></tr>
<tr><td><code><i>   130</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   131</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   132</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   133</i> </code></td><td><code>&nbsp //&nbsp Section:&nbsp Variables</code></td></tr>
<tr><td><code><i>   134</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   135</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   136</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp USB_DEVICE_STATE&nbsp USBDeviceState;</code></td></tr>
<tr><td><code><i>   137</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp uint8_t&nbsp USBActiveConfiguration;</code></td></tr>
<tr><td><code><i>   138</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp uint8_t&nbsp USBAlternateInterface[USB_MAX_NUM_INT];</code></td></tr>
<tr><td><code><i>   139</i> </code></td><td><code>&nbsp volatile&nbsp BDT_ENTRY&nbsp *pBDTEntryEP0OutCurrent;</code></td></tr>
<tr><td><code><i>   140</i> </code></td><td><code>&nbsp volatile&nbsp BDT_ENTRY&nbsp *pBDTEntryEP0OutNext;</code></td></tr>
<tr><td><code><i>   141</i> </code></td><td><code>&nbsp volatile&nbsp BDT_ENTRY&nbsp *pBDTEntryOut[USB_MAX_EP_NUMBER+1];</code></td></tr>
<tr><td><code><i>   142</i> </code></td><td><code>&nbsp volatile&nbsp BDT_ENTRY&nbsp *pBDTEntryIn[USB_MAX_EP_NUMBER+1];</code></td></tr>
<tr><td><code><i>   143</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp uint8_t&nbsp shortPacketStatus;</code></td></tr>
<tr><td><code><i>   144</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp uint8_t&nbsp controlTransferState;</code></td></tr>
<tr><td><code><i>   145</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp IN_PIPE&nbsp inPipes[1];</code></td></tr>
<tr><td><code><i>   146</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp OUT_PIPE&nbsp outPipes[1];</code></td></tr>
<tr><td><code><i>   147</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp uint8_t&nbsp *pDst;</code></td></tr>
<tr><td><code><i>   148</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp bool&nbsp RemoteWakeup;</code></td></tr>
<tr><td><code><i>   149</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp bool&nbsp USBBusIsSuspended;</code></td></tr>
<tr><td><code><i>   150</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp USTAT_FIELDS&nbsp USTATcopy;</code></td></tr>
<tr><td><code><i>   151</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp uint8_t&nbsp endpoint_number;</code></td></tr>
<tr><td><code><i>   152</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp bool&nbsp BothEP0OutUOWNsSet;</code></td></tr>
<tr><td><code><i>   153</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp EP_STATUS&nbsp ep_data_in[USB_MAX_EP_NUMBER+1];</code></td></tr>
<tr><td><code><i>   154</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp EP_STATUS&nbsp ep_data_out[USB_MAX_EP_NUMBER+1];</code></td></tr>
<tr><td><code><i>   155</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp uint8_t&nbsp USBStatusStageTimeoutCounter;</code></td></tr>
<tr><td><code><i>   156</i> </code></td><td><code>&nbsp volatile&nbsp bool&nbsp USBDeferStatusStagePacket;</code></td></tr>
<tr><td><code><i>   157</i> </code></td><td><code>&nbsp volatile&nbsp bool&nbsp USBStatusStageEnabledFlag1;</code></td></tr>
<tr><td><code><i>   158</i> </code></td><td><code>&nbsp volatile&nbsp bool&nbsp USBStatusStageEnabledFlag2;</code></td></tr>
<tr><td><code><i>   159</i> </code></td><td><code>&nbsp volatile&nbsp bool&nbsp USBDeferINDataStagePackets;</code></td></tr>
<tr><td><code><i>   160</i> </code></td><td><code>&nbsp volatile&nbsp bool&nbsp USBDeferOUTDataStagePackets;</code></td></tr>
<tr><td><code><i>   161</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp uint32_t&nbsp USB1msTickCount;</code></td></tr>
<tr><td><code><i>   162</i> </code></td><td><code>&nbsp USB_VOLATILE&nbsp uint8_t&nbsp USBTicksSinceSuspendEnd;</code></td></tr>
<tr><td><code><i>   163</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   164</i> </code></td><td><code>&nbsp /**&nbsp USB&nbsp FIXED&nbsp LOCATION&nbsp VARIABLES&nbsp ***********************************/</code></td></tr>
<tr><td><code><i>   165</i> </code></td><td><code>&nbsp #if&nbsp defined(COMPILER_MPLAB_C18)</code></td></tr>
<tr><td><code><i>   166</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #pragma&nbsp udata&nbsp USB_BDT=USB_BDT_ADDRESS</code></td></tr>
<tr><td><code><i>   167</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>   168</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   169</i> </code></td><td><code>&nbsp volatile&nbsp BDT_ENTRY&nbsp BDT[BDT_NUM_ENTRIES]&nbsp BDT_BASE_ADDR_TAG;</code></td></tr>
<tr><td><code><i>   170</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   171</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>   172</i> </code></td><td><code>&nbsp &nbsp *&nbsp EP0&nbsp Buffer&nbsp Space</code></td></tr>
<tr><td><code><i>   173</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>   174</i> </code></td><td><code>&nbsp volatile&nbsp CTRL_TRF_SETUP&nbsp SetupPkt&nbsp CTRL_TRF_SETUP_ADDR_TAG;</code></td></tr>
<tr><td><code><i>   175</i> </code></td><td><code>&nbsp volatile&nbsp uint8_t&nbsp CtrlTrfData[USB_EP0_BUFF_SIZE]&nbsp CTRL_TRF_DATA_ADDR_TAG;</code></td></tr>
<tr><td><code><i>   176</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   177</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>   178</i> </code></td><td><code>&nbsp &nbsp *&nbsp non-EP0&nbsp Buffer&nbsp Space</code></td></tr>
<tr><td><code><i>   179</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>   180</i> </code></td><td><code>&nbsp #if&nbsp defined(USB_USE_MSD)</code></td></tr>
<tr><td><code><i>   181</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Check&nbsp if&nbsp the&nbsp MSD&nbsp application&nbsp specific&nbsp USB&nbsp endpoint&nbsp buffer&nbsp placement&nbsp address&nbsp </code></td></tr>
<tr><td><code><i>   182</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //macros&nbsp have&nbsp already&nbsp been&nbsp defined&nbsp or&nbsp not&nbsp (ex:&nbsp in&nbsp a&nbsp processor&nbsp specific&nbsp header)</code></td></tr>
<tr><td><code><i>   183</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //The&nbsp msd_cbw&nbsp and&nbsp msd_csw&nbsp buffers&nbsp must&nbsp be&nbsp USB&nbsp module&nbsp accessible&nbsp (and&nbsp therefore</code></td></tr>
<tr><td><code><i>   184</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //must&nbsp be&nbsp at&nbsp a&nbsp certain&nbsp address&nbsp range&nbsp on&nbsp certain&nbsp microcontrollers).</code></td></tr>
<tr><td><code><i>   185</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp !defined(MSD_CBW_ADDR_TAG)</code></td></tr>
<tr><td><code><i>   186</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Not&nbsp previously&nbsp defined.&nbsp&nbsp Assume&nbsp in&nbsp this&nbsp case&nbsp all&nbsp microcontroller&nbsp RAM&nbsp is</code></td></tr>
<tr><td><code><i>   187</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //USB&nbsp module&nbsp accessible,&nbsp and&nbsp therefore,&nbsp no&nbsp specific&nbsp address&nbsp tag&nbsp value&nbsp is&nbsp needed.</code></td></tr>
<tr><td><code><i>   188</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #define&nbsp MSD_CBW_ADDR_TAG</code></td></tr>
<tr><td><code><i>   189</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #define&nbsp MSD_CSW_ADDR_TAG</code></td></tr>
<tr><td><code><i>   190</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   191</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp volatile&nbsp USB_MSD_CBW&nbsp msd_cbw&nbsp MSD_CBW_ADDR_TAG;&nbsp&nbsp //Must&nbsp be&nbsp located&nbsp in&nbsp USB&nbsp module&nbsp accessible&nbsp RAM</code></td></tr>
<tr><td><code><i>   192</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp volatile&nbsp USB_MSD_CSW&nbsp msd_csw&nbsp MSD_CSW_ADDR_TAG;&nbsp&nbsp //Must&nbsp be&nbsp located&nbsp in&nbsp USB&nbsp module&nbsp accessible&nbsp RAM</code></td></tr>
<tr><td><code><i>   193</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   194</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp defined(__18CXX)&nbsp ||&nbsp defined(__XC8)</code></td></tr>
<tr><td><code><i>   195</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp volatile&nbsp char&nbsp msd_buffer[512]&nbsp @&nbsp MSD_BUFFER_ADDRESS;</code></td></tr>
<tr><td><code><i>   196</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #else</code></td></tr>
<tr><td><code><i>   197</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp volatile&nbsp char&nbsp msd_buffer[512];</code></td></tr>
<tr><td><code><i>   198</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   199</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>   200</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   201</i> </code></td><td><code>&nbsp //Depricated&nbsp in&nbsp v2.2&nbsp -&nbsp will&nbsp be&nbsp removed&nbsp in&nbsp a&nbsp future&nbsp revision</code></td></tr>
<tr><td><code><i>   202</i> </code></td><td><code>&nbsp #if&nbsp !defined(USB_USER_DEVICE_DESCRIPTOR)</code></td></tr>
<tr><td><code><i>   203</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Device&nbsp descriptor</code></td></tr>
<tr><td><code><i>   204</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp extern&nbsp const&nbsp USB_DEVICE_DESCRIPTOR&nbsp device_dsc;</code></td></tr>
<tr><td><code><i>   205</i> </code></td><td><code>&nbsp #else</code></td></tr>
<tr><td><code><i>   206</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB_USER_DEVICE_DESCRIPTOR_INCLUDE;</code></td></tr>
<tr><td><code><i>   207</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>   208</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   209</i> </code></td><td><code>&nbsp #if&nbsp !defined(USB_USER_CONFIG_DESCRIPTOR)</code></td></tr>
<tr><td><code><i>   210</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Array&nbsp of&nbsp configuration&nbsp descriptors</code></td></tr>
<tr><td><code><i>   211</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp extern&nbsp const&nbsp uint8_t&nbsp *const&nbsp USB_CD_Ptr[];</code></td></tr>
<tr><td><code><i>   212</i> </code></td><td><code>&nbsp #else</code></td></tr>
<tr><td><code><i>   213</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB_USER_CONFIG_DESCRIPTOR_INCLUDE;</code></td></tr>
<tr><td><code><i>   214</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>   215</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   216</i> </code></td><td><code>&nbsp extern&nbsp const&nbsp uint8_t&nbsp *const&nbsp USB_SD_Ptr[];</code></td></tr>
<tr><td><code><i>   217</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   218</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   219</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   220</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   221</i> </code></td><td><code>&nbsp //&nbsp Section:&nbsp Private&nbsp and&nbsp External&nbsp Prototypes</code></td></tr>
<tr><td><code><i>   222</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   223</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   224</i> </code></td><td><code>&nbsp extern&nbsp bool&nbsp USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT&nbsp event,&nbsp void&nbsp *pdata,&nbsp uint16_t&nbsp size);</code></td></tr>
<tr><td><code><i>   225</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   226</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlEPService(void);</code></td></tr>
<tr><td><code><i>   227</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlTrfSetupHandler(void);</code></td></tr>
<tr><td><code><i>   228</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlTrfInHandler(void);</code></td></tr>
<tr><td><code><i>   229</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCheckStdRequest(void);</code></td></tr>
<tr><td><code><i>   230</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBStdGetDscHandler(void);</code></td></tr>
<tr><td><code><i>   231</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlEPServiceComplete(void);</code></td></tr>
<tr><td><code><i>   232</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlTrfTxService(void);</code></td></tr>
<tr><td><code><i>   233</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlTrfRxService(void);</code></td></tr>
<tr><td><code><i>   234</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBStdSetCfgHandler(void);</code></td></tr>
<tr><td><code><i>   235</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBStdGetStatusHandler(void);</code></td></tr>
<tr><td><code><i>   236</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBStdFeatureReqHandler(void);</code></td></tr>
<tr><td><code><i>   237</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlTrfOutHandler(void);</code></td></tr>
<tr><td><code><i>   238</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBConfigureEndpoint(uint8_t&nbsp EPNum,&nbsp uint8_t&nbsp direction);</code></td></tr>
<tr><td><code><i>   239</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBWakeFromSuspend(void);</code></td></tr>
<tr><td><code><i>   240</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBSuspend(void);</code></td></tr>
<tr><td><code><i>   241</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBStallHandler(void);</code></td></tr>
<tr><td><code><i>   242</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   243</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   244</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   245</i> </code></td><td><code>&nbsp //&nbsp Section:&nbsp Macros&nbsp or&nbsp Functions</code></td></tr>
<tr><td><code><i>   246</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   247</i> </code></td><td><code>&nbsp //&nbsp *****************************************************************************</code></td></tr>
<tr><td><code><i>   248</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   249</i> </code></td><td><code>&nbsp /****************************************************************************</code></td></tr>
<tr><td><code><i>   250</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   251</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp void&nbsp USBAdvancePingPongBuffer(BDT_ENTRY**&nbsp buffer)</code></td></tr>
<tr><td><code><i>   252</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   253</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   254</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp will&nbsp advance&nbsp the&nbsp passed&nbsp pointer&nbsp to&nbsp the&nbsp next&nbsp buffer&nbsp based&nbsp on</code></td></tr>
<tr><td><code><i>   255</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp ping&nbsp pong&nbsp option&nbsp setting.&nbsp&nbsp This&nbsp function&nbsp should&nbsp be&nbsp used&nbsp for&nbsp EP1-EP15</code></td></tr>
<tr><td><code><i>   256</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp only.&nbsp&nbsp This&nbsp function&nbsp is&nbsp not&nbsp valid&nbsp for&nbsp EP0.</code></td></tr>
<tr><td><code><i>   257</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   258</i> </code></td><td><code>&nbsp &nbsp&nbsp Precondition:</code></td></tr>
<tr><td><code><i>   259</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>   260</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   261</i> </code></td><td><code>&nbsp &nbsp&nbsp Parameters:</code></td></tr>
<tr><td><code><i>   262</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp BDT_ENTRY**&nbsp -&nbsp pointer&nbsp to&nbsp the&nbsp BDT_ENTRY&nbsp pointer&nbsp that&nbsp you&nbsp want&nbsp to&nbsp be&nbsp advanced</code></td></tr>
<tr><td><code><i>   263</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp to&nbsp the&nbsp next&nbsp buffer&nbsp state</code></td></tr>
<tr><td><code><i>   264</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   265</i> </code></td><td><code>&nbsp &nbsp&nbsp Return&nbsp Values:</code></td></tr>
<tr><td><code><i>   266</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>   267</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   268</i> </code></td><td><code>&nbsp &nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>   269</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>   270</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   271</i> </code></td><td><code>&nbsp &nbsp&nbsp ***************************************************************************/</code></td></tr>
<tr><td><code><i>   272</i> </code></td><td><code>&nbsp #define&nbsp USBAdvancePingPongBuffer(buffer)&nbsp {((uint8_t_VAL*)buffer)-&rsaquo  Val&nbsp ^=&nbsp USB_NEXT_PING_PONG;}</code></td></tr>
<tr><td><code><i>   273</i> </code></td><td><code>&nbsp #define&nbsp USBHALPingPongSetToOdd(buffer)&nbsp&nbsp&nbsp {((uint8_t_VAL*)buffer)-&rsaquo  Val&nbsp |=&nbsp USB_NEXT_PING_PONG;}</code></td></tr>
<tr><td><code><i>   274</i> </code></td><td><code>&nbsp #define&nbsp USBHALPingPongSetToEven(buffer)&nbsp&nbsp {((uint8_t_VAL*)buffer)-&rsaquo  Val&nbsp &=&nbsp ~USB_NEXT_PING_PONG;}</code></td></tr>
<tr><td><code><i>   275</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   276</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   277</i> </code></td><td><code>&nbsp /**************************************************************************</code></td></tr>
<tr><td><code><i>   278</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   279</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBDeviceInit(void)</code></td></tr>
<tr><td><code><i>   280</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   281</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   282</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp initializes&nbsp the&nbsp device&nbsp stack&nbsp it&nbsp in&nbsp the&nbsp default&nbsp state.&nbsp The</code></td></tr>
<tr><td><code><i>   283</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB&nbsp module&nbsp will&nbsp be&nbsp completely&nbsp reset&nbsp including&nbsp all&nbsp of&nbsp the&nbsp internal</code></td></tr>
<tr><td><code><i>   284</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp variables,&nbsp registers,&nbsp and&nbsp interrupt&nbsp flags.</code></td></tr>
<tr><td><code><i>   285</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   286</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Precondition:</code></td></tr>
<tr><td><code><i>   287</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp must&nbsp be&nbsp called&nbsp before&nbsp any&nbsp of&nbsp the&nbsp other&nbsp USB&nbsp Device</code></td></tr>
<tr><td><code><i>   288</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp functions&nbsp can&nbsp be&nbsp called,&nbsp including&nbsp USBDeviceTasks().</code></td></tr>
<tr><td><code><i>   289</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   290</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Parameters:</code></td></tr>
<tr><td><code><i>   291</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>   292</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   293</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Return&nbsp Values:</code></td></tr>
<tr><td><code><i>   294</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>   295</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   296</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>   297</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>   298</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   299</i> </code></td><td><code>&nbsp &nbsp&nbsp ***************************************************************************/</code></td></tr>
<tr><td><code><i>   300</i> </code></td><td><code>&nbsp void&nbsp USBDeviceInit(void)</code></td></tr>
<tr><td><code><i>   301</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   302</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp i;</code></td></tr>
<tr><td><code><i>   303</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   304</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDisableInterrupts();</code></td></tr>
<tr><td><code><i>   305</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   306</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp Clear&nbsp all&nbsp USB&nbsp error&nbsp flags</code></td></tr>
<tr><td><code><i>   307</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBClearInterruptRegister(U1EIR);&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   308</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   309</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp Clears&nbsp all&nbsp USB&nbsp interrupts&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   310</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBClearInterruptRegister(U1IR);&nbsp </code></td></tr>
<tr><td><code><i>   311</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   312</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Clear&nbsp all&nbsp of&nbsp the&nbsp endpoint&nbsp control&nbsp registers</code></td></tr>
<tr><td><code><i>   313</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp U1EP0&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   314</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   315</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);</code></td></tr>
<tr><td><code><i>   316</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   317</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp SetConfigurationOptions();</code></td></tr>
<tr><td><code><i>   318</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   319</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //power&nbsp up&nbsp the&nbsp module&nbsp (if&nbsp not&nbsp already&nbsp powered)</code></td></tr>
<tr><td><code><i>   320</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBPowerModule();</code></td></tr>
<tr><td><code><i>   321</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   322</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //set&nbsp the&nbsp address&nbsp of&nbsp the&nbsp BDT&nbsp (if&nbsp applicable)</code></td></tr>
<tr><td><code><i>   323</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBSetBDTAddress(BDT);</code></td></tr>
<tr><td><code><i>   324</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   325</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Clear&nbsp all&nbsp of&nbsp the&nbsp BDT&nbsp entries</code></td></tr>
<tr><td><code><i>   326</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp for(i&nbsp =&nbsp 0;&nbsp i&nbsp&lsaquo &nbsp (sizeof(BDT)/sizeof(BDT_ENTRY));&nbsp i++)</code></td></tr>
<tr><td><code><i>   327</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   328</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BDT[i].Val&nbsp =&nbsp 0x00;</code></td></tr>
<tr><td><code><i>   329</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   330</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   331</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp Assert&nbsp reset&nbsp request&nbsp to&nbsp all&nbsp of&nbsp the&nbsp Ping&nbsp Pong&nbsp buffer&nbsp pointers</code></td></tr>
<tr><td><code><i>   332</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBPingPongBufferReset&nbsp =&nbsp 1;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   333</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   334</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp Reset&nbsp to&nbsp default&nbsp address</code></td></tr>
<tr><td><code><i>   335</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp U1ADDR&nbsp =&nbsp 0x00;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   336</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   337</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp Make&nbsp sure&nbsp packet&nbsp processing&nbsp is&nbsp enabled</code></td></tr>
<tr><td><code><i>   338</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBPacketDisable&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   339</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   340</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Stop&nbsp trying&nbsp to&nbsp reset&nbsp ping&nbsp pong&nbsp buffer&nbsp pointers</code></td></tr>
<tr><td><code><i>   341</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBPingPongBufferReset&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   342</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   343</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp Flush&nbsp any&nbsp pending&nbsp transactions</code></td></tr>
<tr><td><code><i>   344</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp do</code></td></tr>
<tr><td><code><i>   345</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   346</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);</code></td></tr>
<tr><td><code><i>   347</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Initialize&nbsp USB&nbsp stack&nbsp software&nbsp state&nbsp variables</code></td></tr>
<tr><td><code><i>   348</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.Val&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   349</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp outPipes[0].info.Val&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   350</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp outPipes[0].wCount.Val&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   351</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }while(USBTransactionCompleteIF&nbsp ==&nbsp 1);</code></td></tr>
<tr><td><code><i>   352</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   353</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Set&nbsp flags&nbsp to&nbsp true,&nbsp so&nbsp the&nbsp USBCtrlEPAllowStatusStage()&nbsp function&nbsp knows&nbsp not&nbsp to</code></td></tr>
<tr><td><code><i>   354</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //try&nbsp and&nbsp arm&nbsp a&nbsp status&nbsp stage,&nbsp even&nbsp before&nbsp the&nbsp first&nbsp control&nbsp transfer&nbsp starts.</code></td></tr>
<tr><td><code><i>   355</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBStatusStageEnabledFlag1&nbsp =&nbsp true;</code></td></tr>
<tr><td><code><i>   356</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBStatusStageEnabledFlag2&nbsp =&nbsp true;</code></td></tr>
<tr><td><code><i>   357</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Initialize&nbsp other&nbsp flags</code></td></tr>
<tr><td><code><i>   358</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeferINDataStagePackets&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>   359</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeferOUTDataStagePackets&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>   360</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBBusIsSuspended&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>   361</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   362</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Initialize&nbsp all&nbsp pBDTEntryIn[]&nbsp and&nbsp pBDTEntryOut[]</code></td></tr>
<tr><td><code><i>   363</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //pointers&nbsp to&nbsp NULL,&nbsp so&nbsp they&nbsp don't&nbsp get&nbsp used&nbsp inadvertently.</code></td></tr>
<tr><td><code><i>   364</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp for(i&nbsp =&nbsp 0;&nbsp i&nbsp&lsaquo &nbsp (uint8_t)(USB_MAX_EP_NUMBER+1u);&nbsp i++)</code></td></tr>
<tr><td><code><i>   365</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   366</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[i]&nbsp =&nbsp 0u;</code></td></tr>
<tr><td><code><i>   367</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryOut[i]&nbsp =&nbsp 0u;</code></td></tr>
<tr><td><code><i>   368</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ep_data_in[i].Val&nbsp =&nbsp 0u;</code></td></tr>
<tr><td><code><i>   369</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ep_data_out[i].Val&nbsp =&nbsp 0u;</code></td></tr>
<tr><td><code><i>   370</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   371</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   372</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Get&nbsp ready&nbsp for&nbsp the&nbsp first&nbsp packet</code></td></tr>
<tr><td><code><i>   373</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]&nbsp =&nbsp (volatile&nbsp BDT_ENTRY*)&BDT[EP0_IN_EVEN];</code></td></tr>
<tr><td><code><i>   374</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp Initialize&nbsp EP0&nbsp as&nbsp a&nbsp Ctrl&nbsp EP</code></td></tr>
<tr><td><code><i>   375</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp U1EP0&nbsp =&nbsp EP_CTRL|USB_HANDSHAKE_ENABLED;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   376</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Prepare&nbsp for&nbsp the&nbsp first&nbsp SETUP&nbsp on&nbsp EP0&nbsp OUT</code></td></tr>
<tr><td><code><i>   377</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp BDT[EP0_OUT_EVEN].ADR&nbsp =&nbsp ConvertToPhysicalAddress(&SetupPkt);</code></td></tr>
<tr><td><code><i>   378</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp BDT[EP0_OUT_EVEN].CNT&nbsp =&nbsp USB_EP0_BUFF_SIZE;</code></td></tr>
<tr><td><code><i>   379</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp BDT[EP0_OUT_EVEN].STAT.Val&nbsp =&nbsp _DAT0|_BSTALL;</code></td></tr>
<tr><td><code><i>   380</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp BDT[EP0_OUT_EVEN].STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>   381</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   382</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp Clear&nbsp active&nbsp configuration</code></td></tr>
<tr><td><code><i>   383</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBActiveConfiguration&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   384</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   385</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB1msTickCount&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Keeps&nbsp track&nbsp of&nbsp total&nbsp number&nbsp of&nbsp milliseconds&nbsp since&nbsp calling&nbsp USBDeviceInit()&nbsp when&nbsp first&nbsp initializing&nbsp the&nbsp USB&nbsp module/stack&nbsp code.</code></td></tr>
<tr><td><code><i>   386</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBTicksSinceSuspendEnd&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp //Keeps&nbsp track&nbsp of&nbsp the&nbsp number&nbsp of&nbsp milliseconds&nbsp since&nbsp a&nbsp suspend&nbsp condition&nbsp has&nbsp ended.</code></td></tr>
<tr><td><code><i>   387</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   388</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Indicate&nbsp that&nbsp we&nbsp are&nbsp now&nbsp in&nbsp the&nbsp detached&nbsp state</code></td></tr>
<tr><td><code><i>   389</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeviceState&nbsp =&nbsp DETACHED_STATE;</code></td></tr>
<tr><td><code><i>   390</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>   391</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   392</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   393</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   394</i> </code></td><td><code>&nbsp /**************************************************************************</code></td></tr>
<tr><td><code><i>   395</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   396</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBDeviceTasks(void)</code></td></tr>
<tr><td><code><i>   397</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   398</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>   399</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp is&nbsp the&nbsp main&nbsp state&nbsp machine/transaction&nbsp handler&nbsp of&nbsp the&nbsp USB&nbsp </code></td></tr>
<tr><td><code><i>   400</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp device&nbsp side&nbsp stack.&nbsp&nbsp When&nbsp the&nbsp USB&nbsp stack&nbsp is&nbsp operated&nbsp in&nbsp "USB_POLLING"&nbsp mode&nbsp </code></td></tr>
<tr><td><code><i>   401</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp (usb_config.h&nbsp user&nbsp option)&nbsp the&nbsp USBDeviceTasks()&nbsp function&nbsp should&nbsp be&nbsp called&nbsp </code></td></tr>
<tr><td><code><i>   402</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp periodically&nbsp to&nbsp receive&nbsp and&nbsp transmit&nbsp packets&nbsp through&nbsp the&nbsp stack.&nbsp This&nbsp </code></td></tr>
<tr><td><code><i>   403</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp function&nbsp also&nbsp takes&nbsp care&nbsp of&nbsp control&nbsp transfers&nbsp associated&nbsp with&nbsp the&nbsp USB&nbsp </code></td></tr>
<tr><td><code><i>   404</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp enumeration&nbsp process,&nbsp and&nbsp detecting&nbsp various&nbsp USB&nbsp events&nbsp (such&nbsp as&nbsp suspend).&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   405</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp should&nbsp be&nbsp called&nbsp at&nbsp least&nbsp once&nbsp every&nbsp 1.8ms&nbsp during&nbsp the&nbsp USB&nbsp </code></td></tr>
<tr><td><code><i>   406</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp enumeration&nbsp process.&nbsp After&nbsp the&nbsp enumeration&nbsp process&nbsp is&nbsp complete&nbsp (which&nbsp can&nbsp </code></td></tr>
<tr><td><code><i>   407</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp be&nbsp determined&nbsp when&nbsp USBGetDeviceState()&nbsp returns&nbsp CONFIGURED_STATE),&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>   408</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeviceTasks()&nbsp handler&nbsp may&nbsp be&nbsp called&nbsp the&nbsp faster&nbsp of:&nbsp either&nbsp once&nbsp </code></td></tr>
<tr><td><code><i>   409</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp every&nbsp 9.8ms,&nbsp or&nbsp as&nbsp often&nbsp as&nbsp needed&nbsp to&nbsp make&nbsp sure&nbsp that&nbsp the&nbsp hardware&nbsp USTAT&nbsp </code></td></tr>
<tr><td><code><i>   410</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp FIFO&nbsp never&nbsp gets&nbsp full.&nbsp&nbsp A&nbsp good&nbsp rule&nbsp of&nbsp thumb&nbsp is&nbsp to&nbsp call&nbsp USBDeviceTasks()&nbsp at</code></td></tr>
<tr><td><code><i>   411</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp a&nbsp minimum&nbsp rate&nbsp of&nbsp either&nbsp the&nbsp frequency&nbsp that&nbsp USBTransferOnePacket()&nbsp gets&nbsp </code></td></tr>
<tr><td><code><i>   412</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp called,&nbsp or,&nbsp once/1.8ms,&nbsp whichever&nbsp is&nbsp faster.&nbsp&nbsp See&nbsp the&nbsp inline&nbsp code&nbsp comments&nbsp </code></td></tr>
<tr><td><code><i>   413</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp near&nbsp the&nbsp top&nbsp of&nbsp usb_device.c&nbsp for&nbsp more&nbsp details&nbsp about&nbsp minimum&nbsp timing&nbsp </code></td></tr>
<tr><td><code><i>   414</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp requirements&nbsp when&nbsp calling&nbsp USBDeviceTasks().</code></td></tr>
<tr><td><code><i>   415</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   416</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp When&nbsp the&nbsp USB&nbsp stack&nbsp is&nbsp operated&nbsp in&nbsp "USB_INTERRUPT"&nbsp mode,&nbsp it&nbsp is&nbsp not&nbsp necessary</code></td></tr>
<tr><td><code><i>   417</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp to&nbsp call&nbsp USBDeviceTasks()&nbsp from&nbsp the&nbsp main&nbsp loop&nbsp context.&nbsp&nbsp In&nbsp the&nbsp USB_INTERRUPT</code></td></tr>
<tr><td><code><i>   418</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp mode,&nbsp the&nbsp USBDeviceTasks()&nbsp handler&nbsp only&nbsp needs&nbsp to&nbsp execute&nbsp when&nbsp a&nbsp USB&nbsp </code></td></tr>
<tr><td><code><i>   419</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp interrupt&nbsp occurs,&nbsp and&nbsp therefore&nbsp only&nbsp needs&nbsp to&nbsp be&nbsp called&nbsp from&nbsp the&nbsp interrupt&nbsp </code></td></tr>
<tr><td><code><i>   420</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp context.</code></td></tr>
<tr><td><code><i>   421</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   422</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   423</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp is&nbsp the&nbsp main&nbsp state&nbsp machine/transaction&nbsp handler&nbsp of&nbsp the&nbsp USB&nbsp </code></td></tr>
<tr><td><code><i>   424</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp device&nbsp side&nbsp stack.&nbsp&nbsp When&nbsp the&nbsp USB&nbsp stack&nbsp is&nbsp operated&nbsp in&nbsp "USB_POLLING"&nbsp mode&nbsp </code></td></tr>
<tr><td><code><i>   425</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp (usb_config.h&nbsp user&nbsp option)&nbsp the&nbsp USBDeviceTasks()&nbsp function&nbsp should&nbsp be&nbsp called&nbsp </code></td></tr>
<tr><td><code><i>   426</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp periodically&nbsp to&nbsp receive&nbsp and&nbsp transmit&nbsp packets&nbsp through&nbsp the&nbsp stack.&nbsp This&nbsp </code></td></tr>
<tr><td><code><i>   427</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp function&nbsp also&nbsp takes&nbsp care&nbsp of&nbsp control&nbsp transfers&nbsp associated&nbsp with&nbsp the&nbsp USB&nbsp </code></td></tr>
<tr><td><code><i>   428</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp enumeration&nbsp process,&nbsp and&nbsp detecting&nbsp various&nbsp USB&nbsp events&nbsp (such&nbsp as&nbsp suspend).&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   429</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp should&nbsp be&nbsp called&nbsp at&nbsp least&nbsp once&nbsp every&nbsp 1.8ms&nbsp during&nbsp the&nbsp USB&nbsp </code></td></tr>
<tr><td><code><i>   430</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp enumeration&nbsp process.&nbsp After&nbsp the&nbsp enumeration&nbsp process&nbsp is&nbsp complete&nbsp (which&nbsp can&nbsp </code></td></tr>
<tr><td><code><i>   431</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp be&nbsp determined&nbsp when&nbsp USBGetDeviceState()&nbsp returns&nbsp CONFIGURED_STATE),&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>   432</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeviceTasks()&nbsp handler&nbsp may&nbsp be&nbsp called&nbsp the&nbsp faster&nbsp of:&nbsp either&nbsp once&nbsp </code></td></tr>
<tr><td><code><i>   433</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp every&nbsp 9.8ms,&nbsp or&nbsp as&nbsp often&nbsp as&nbsp needed&nbsp to&nbsp make&nbsp sure&nbsp that&nbsp the&nbsp hardware&nbsp USTAT&nbsp </code></td></tr>
<tr><td><code><i>   434</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp FIFO&nbsp never&nbsp gets&nbsp full.&nbsp&nbsp A&nbsp good&nbsp rule&nbsp of&nbsp thumb&nbsp is&nbsp to&nbsp call&nbsp USBDeviceTasks()&nbsp at</code></td></tr>
<tr><td><code><i>   435</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp a&nbsp minimum&nbsp rate&nbsp of&nbsp either&nbsp the&nbsp frequency&nbsp that&nbsp USBTransferOnePacket()&nbsp gets&nbsp </code></td></tr>
<tr><td><code><i>   436</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp called,&nbsp or,&nbsp once/1.8ms,&nbsp whichever&nbsp is&nbsp faster.&nbsp&nbsp See&nbsp the&nbsp inline&nbsp code&nbsp comments&nbsp </code></td></tr>
<tr><td><code><i>   437</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp near&nbsp the&nbsp top&nbsp of&nbsp usb_device.c&nbsp for&nbsp more&nbsp details&nbsp about&nbsp minimum&nbsp timing&nbsp </code></td></tr>
<tr><td><code><i>   438</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp requirements&nbsp when&nbsp calling&nbsp USBDeviceTasks().</code></td></tr>
<tr><td><code><i>   439</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   440</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp When&nbsp the&nbsp USB&nbsp stack&nbsp is&nbsp operated&nbsp in&nbsp "USB_INTERRUPT"&nbsp mode,&nbsp it&nbsp is&nbsp not&nbsp necessary</code></td></tr>
<tr><td><code><i>   441</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp to&nbsp call&nbsp USBDeviceTasks()&nbsp from&nbsp the&nbsp main&nbsp loop&nbsp context.&nbsp&nbsp In&nbsp the&nbsp USB_INTERRUPT</code></td></tr>
<tr><td><code><i>   442</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp mode,&nbsp the&nbsp USBDeviceTasks()&nbsp handler&nbsp only&nbsp needs&nbsp to&nbsp execute&nbsp when&nbsp a&nbsp USB&nbsp </code></td></tr>
<tr><td><code><i>   443</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp interrupt&nbsp occurs,&nbsp and&nbsp therefore&nbsp only&nbsp needs&nbsp to&nbsp be&nbsp called&nbsp from&nbsp the&nbsp interrupt&nbsp </code></td></tr>
<tr><td><code><i>   444</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp context.</code></td></tr>
<tr><td><code><i>   445</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   446</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Typical&nbsp usage:</code></td></tr>
<tr><td><code><i>   447</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  code&rsaquo  </code></td></tr>
<tr><td><code><i>   448</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp void&nbsp main(void)</code></td></tr>
<tr><td><code><i>   449</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   450</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceInit();</code></td></tr>
<tr><td><code><i>   451</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp while(1)</code></td></tr>
<tr><td><code><i>   452</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   453</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceTasks();&nbsp //Takes&nbsp care&nbsp of&nbsp enumeration&nbsp and&nbsp other&nbsp USB&nbsp events</code></td></tr>
<tr><td><code><i>   454</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if((USBGetDeviceState()&nbsp \&lsaquo &nbsp CONFIGURED_STATE)&nbsp ||</code></td></tr>
<tr><td><code><i>   455</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (USBIsDeviceSuspended()&nbsp ==&nbsp true))</code></td></tr>
<tr><td><code><i>   456</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   457</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Either&nbsp the&nbsp device&nbsp is&nbsp not&nbsp configured&nbsp or&nbsp we&nbsp are&nbsp suspended,</code></td></tr>
<tr><td><code><i>   458</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp so&nbsp we&nbsp don't&nbsp want&nbsp to&nbsp execute&nbsp any&nbsp USB&nbsp related&nbsp application&nbsp code</code></td></tr>
<tr><td><code><i>   459</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp continue;&nbsp&nbsp&nbsp //go&nbsp back&nbsp to&nbsp the&nbsp top&nbsp of&nbsp the&nbsp while&nbsp loop</code></td></tr>
<tr><td><code><i>   460</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   461</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>   462</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   463</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Otherwise&nbsp we&nbsp are&nbsp free&nbsp to&nbsp run&nbsp USB&nbsp and&nbsp non-USB&nbsp related&nbsp user&nbsp </code></td></tr>
<tr><td><code><i>   464</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //application&nbsp code.</code></td></tr>
<tr><td><code><i>   465</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UserApplication();</code></td></tr>
<tr><td><code><i>   466</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   467</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   468</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   469</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  /code&rsaquo  </code></td></tr>
<tr><td><code><i>   470</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   471</i> </code></td><td><code>&nbsp &nbsp&nbsp Precondition:</code></td></tr>
<tr><td><code><i>   472</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Make&nbsp sure&nbsp the&nbsp USBDeviceInit()&nbsp function&nbsp has&nbsp been&nbsp called&nbsp prior&nbsp to&nbsp calling</code></td></tr>
<tr><td><code><i>   473</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeviceTasks()&nbsp for&nbsp the&nbsp first&nbsp time.</code></td></tr>
<tr><td><code><i>   474</i> </code></td><td><code>&nbsp &nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>   475</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeviceTasks()&nbsp does&nbsp not&nbsp need&nbsp to&nbsp be&nbsp called&nbsp while&nbsp in&nbsp the&nbsp USB&nbsp suspend&nbsp mode,&nbsp </code></td></tr>
<tr><td><code><i>   476</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if&nbsp the&nbsp user&nbsp application&nbsp firmware&nbsp in&nbsp the&nbsp USBCBSuspend()&nbsp callback&nbsp function</code></td></tr>
<tr><td><code><i>   477</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp enables&nbsp the&nbsp ACTVIF&nbsp USB&nbsp interrupt&nbsp source&nbsp and&nbsp put&nbsp the&nbsp microcontroller&nbsp into&nbsp </code></td></tr>
<tr><td><code><i>   478</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp sleep&nbsp mode.&nbsp&nbsp If&nbsp the&nbsp application&nbsp firmware&nbsp decides&nbsp not&nbsp to&nbsp sleep&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>   479</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp microcontroller&nbsp core&nbsp during&nbsp USB&nbsp suspend&nbsp (ex:&nbsp continues&nbsp running&nbsp at&nbsp full&nbsp </code></td></tr>
<tr><td><code><i>   480</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp frequency,&nbsp or&nbsp clock&nbsp switches&nbsp to&nbsp a&nbsp lower&nbsp frequency),&nbsp then&nbsp the&nbsp USBDeviceTasks()</code></td></tr>
<tr><td><code><i>   481</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp function&nbsp must&nbsp still&nbsp be&nbsp called&nbsp periodically,&nbsp at&nbsp a&nbsp rate&nbsp frequent&nbsp enough&nbsp to&nbsp </code></td></tr>
<tr><td><code><i>   482</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp ensure&nbsp the&nbsp 10ms&nbsp resume&nbsp recovery&nbsp interval&nbsp USB&nbsp specification&nbsp is&nbsp met.&nbsp&nbsp Assuming</code></td></tr>
<tr><td><code><i>   483</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp a&nbsp worst&nbsp case&nbsp primary&nbsp oscillator&nbsp and&nbsp PLL&nbsp start&nbsp up&nbsp time&nbsp of&nbsp less&nbsp than&nbsp 5ms,&nbsp then</code></td></tr>
<tr><td><code><i>   484</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeviceTasks()&nbsp should&nbsp be&nbsp called&nbsp once&nbsp every&nbsp 5ms&nbsp in&nbsp this&nbsp scenario.</code></td></tr>
<tr><td><code><i>   485</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   486</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp When&nbsp the&nbsp USB&nbsp cable&nbsp is&nbsp detached,&nbsp or&nbsp the&nbsp USB&nbsp host&nbsp is&nbsp not&nbsp actively&nbsp powering&nbsp </code></td></tr>
<tr><td><code><i>   487</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp VBUS&nbsp line&nbsp to&nbsp +5V&nbsp nominal,&nbsp the&nbsp application&nbsp firmware&nbsp does&nbsp not&nbsp always&nbsp have&nbsp </code></td></tr>
<tr><td><code><i>   488</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp to&nbsp call&nbsp USBDeviceTasks()&nbsp frequently,&nbsp as&nbsp no&nbsp USB&nbsp activity&nbsp will&nbsp be&nbsp taking&nbsp </code></td></tr>
<tr><td><code><i>   489</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp place.&nbsp&nbsp However,&nbsp if&nbsp USBDeviceTasks()&nbsp is&nbsp not&nbsp called&nbsp regularly,&nbsp some&nbsp </code></td></tr>
<tr><td><code><i>   490</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp alternative&nbsp means&nbsp of&nbsp promptly&nbsp detecting&nbsp when&nbsp VBUS&nbsp is&nbsp powered&nbsp (indicating&nbsp </code></td></tr>
<tr><td><code><i>   491</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp host&nbsp attachment),&nbsp or&nbsp not&nbsp powered&nbsp (host&nbsp powered&nbsp down&nbsp or&nbsp USB&nbsp cable&nbsp unplugged)</code></td></tr>
<tr><td><code><i>   492</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp is&nbsp still&nbsp needed.&nbsp&nbsp For&nbsp self&nbsp or&nbsp dual&nbsp self/bus&nbsp powered&nbsp USB&nbsp applications,&nbsp see&nbsp </code></td></tr>
<tr><td><code><i>   493</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp USBDeviceAttach()&nbsp and&nbsp USBDeviceDetach()&nbsp API&nbsp documentation&nbsp for&nbsp additional&nbsp </code></td></tr>
<tr><td><code><i>   494</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp considerations.</code></td></tr>
<tr><td><code><i>   495</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp ***************************************************************************/</code></td></tr>
<tr><td><code><i>   496</i> </code></td><td><code>&nbsp void&nbsp USBDeviceTasks(void)</code></td></tr>
<tr><td><code><i>   497</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   498</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp i;</code></td></tr>
<tr><td><code><i>   499</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   500</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #ifdef&nbsp USB_SUPPORT_OTG</code></td></tr>
<tr><td><code><i>   501</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //SRP&nbsp Time&nbsp Out&nbsp Check</code></td></tr>
<tr><td><code><i>   502</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if&nbsp (USBOTGSRPIsReady())</code></td></tr>
<tr><td><code><i>   503</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   504</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if&nbsp (USBT1MSECIF&nbsp &&&nbsp USBT1MSECIE)</code></td></tr>
<tr><td><code><i>   505</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   506</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if&nbsp (USBOTGGetSRPTimeOutFlag())</code></td></tr>
<tr><td><code><i>   507</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   508</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if&nbsp (USBOTGIsSRPTimeOutExpired())</code></td></tr>
<tr><td><code><i>   509</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   510</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);</code></td></tr>
<tr><td><code><i>   511</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   512</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   513</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   514</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Clear&nbsp Interrupt&nbsp Flag</code></td></tr>
<tr><td><code><i>   515</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);</code></td></tr>
<tr><td><code><i>   516</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   517</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   518</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   519</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   520</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp defined(USB_POLLING)</code></td></tr>
<tr><td><code><i>   521</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //If&nbsp the&nbsp interrupt&nbsp option&nbsp is&nbsp selected&nbsp then&nbsp the&nbsp customer&nbsp is&nbsp required</code></td></tr>
<tr><td><code><i>   522</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp to&nbsp notify&nbsp the&nbsp stack&nbsp when&nbsp the&nbsp device&nbsp is&nbsp attached&nbsp or&nbsp removed&nbsp from&nbsp the</code></td></tr>
<tr><td><code><i>   523</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp bus&nbsp by&nbsp calling&nbsp the&nbsp USBDeviceAttach()&nbsp and&nbsp USBDeviceDetach()&nbsp functions.</code></td></tr>
<tr><td><code><i>   524</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if&nbsp (USB_BUS_SENSE&nbsp !=&nbsp 1)</code></td></tr>
<tr><td><code><i>   525</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   526</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Disable&nbsp module&nbsp &&nbsp detach&nbsp from&nbsp bus</code></td></tr>
<tr><td><code><i>   527</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1CON&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   528</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   529</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Mask&nbsp all&nbsp USB&nbsp interrupts&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   530</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1IE&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   531</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   532</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Move&nbsp to&nbsp the&nbsp detached&nbsp state&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   533</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceState&nbsp =&nbsp DETACHED_STATE;</code></td></tr>
<tr><td><code><i>   534</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   535</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #ifdef&nbsp&nbsp USB_SUPPORT_OTG&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   536</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Disable&nbsp D+&nbsp Pullup</code></td></tr>
<tr><td><code><i>   537</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1OTGCONbits.DPPULUP&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   538</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   539</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Disable&nbsp HNP</code></td></tr>
<tr><td><code><i>   540</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGDisableHnp();</code></td></tr>
<tr><td><code><i>   541</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   542</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Deactivate&nbsp HNP</code></td></tr>
<tr><td><code><i>   543</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGDeactivateHnp();</code></td></tr>
<tr><td><code><i>   544</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   545</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //If&nbsp ID&nbsp Pin&nbsp Changed&nbsp State</code></td></tr>
<tr><td><code><i>   546</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if&nbsp (USBIDIF&nbsp &&&nbsp USBIDIE)</code></td></tr>
<tr><td><code><i>   547</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   548</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Re-detect&nbsp &&nbsp Initialize</code></td></tr>
<tr><td><code><i>   549</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGInitialize();</code></td></tr>
<tr><td><code><i>   550</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   551</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Clear&nbsp ID&nbsp Interrupt&nbsp Flag</code></td></tr>
<tr><td><code><i>   552</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);</code></td></tr>
<tr><td><code><i>   553</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   554</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   555</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   556</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined&nbsp __C30__&nbsp ||&nbsp defined&nbsp __XC16__</code></td></tr>
<tr><td><code><i>   557</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //USBClearInterruptFlag(U1OTGIR,&nbsp 3);&nbsp </code></td></tr>
<tr><td><code><i>   558</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   559</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //return&nbsp so&nbsp that&nbsp we&nbsp don't&nbsp go&nbsp through&nbsp the&nbsp rest&nbsp of&nbsp </code></td></tr>
<tr><td><code><i>   560</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //the&nbsp state&nbsp machine</code></td></tr>
<tr><td><code><i>   561</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearUSBInterrupt();</code></td></tr>
<tr><td><code><i>   562</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return;</code></td></tr>
<tr><td><code><i>   563</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   564</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   565</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #ifdef&nbsp USB_SUPPORT_OTG</code></td></tr>
<tr><td><code><i>   566</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //If&nbsp Session&nbsp Is&nbsp Started&nbsp Then</code></td></tr>
<tr><td><code><i>   567</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>   568</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   569</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //If&nbsp SRP&nbsp Is&nbsp Ready</code></td></tr>
<tr><td><code><i>   570</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if&nbsp (USBOTGSRPIsReady())</code></td></tr>
<tr><td><code><i>   571</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   572</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Clear&nbsp SRPReady</code></td></tr>
<tr><td><code><i>   573</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGClearSRPReady();</code></td></tr>
<tr><td><code><i>   574</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   575</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Clear&nbsp SRP&nbsp Timeout&nbsp Flag</code></td></tr>
<tr><td><code><i>   576</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGClearSRPTimeOutFlag();</code></td></tr>
<tr><td><code><i>   577</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   578</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Indicate&nbsp Session&nbsp Started</code></td></tr>
<tr><td><code><i>   579</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UART2PrintString(&nbsp "\r\n*****&nbsp USB&nbsp OTG&nbsp B&nbsp Event&nbsp -&nbsp Session&nbsp Started&nbsp&nbsp *****\r\n"&nbsp );</code></td></tr>
<tr><td><code><i>   580</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   581</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   582</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif&nbsp //#ifdef&nbsp USB_SUPPORT_OTG</code></td></tr>
<tr><td><code><i>   583</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   584</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //if&nbsp we&nbsp are&nbsp in&nbsp the&nbsp detached&nbsp state</code></td></tr>
<tr><td><code><i>   585</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBDeviceState&nbsp ==&nbsp DETACHED_STATE)</code></td></tr>
<tr><td><code><i>   586</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   587</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp //Initialize&nbsp register&nbsp to&nbsp known&nbsp value</code></td></tr>
<tr><td><code><i>   588</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1CON&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   589</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   590</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Mask&nbsp all&nbsp USB&nbsp interrupts</code></td></tr>
<tr><td><code><i>   591</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1IE&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   592</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   593</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Enable/set&nbsp things&nbsp like:&nbsp pull&nbsp ups,&nbsp full/low-speed&nbsp mode,&nbsp </code></td></tr>
<tr><td><code><i>   594</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //set&nbsp the&nbsp ping&nbsp pong&nbsp mode,&nbsp and&nbsp set&nbsp internal&nbsp transceiver</code></td></tr>
<tr><td><code><i>   595</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SetConfigurationOptions();</code></td></tr>
<tr><td><code><i>   596</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   597</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Enable&nbsp module&nbsp &&nbsp attach&nbsp to&nbsp bus</code></td></tr>
<tr><td><code><i>   598</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp while(!U1CONbits.USBEN){U1CONbits.USBEN&nbsp =&nbsp 1;}</code></td></tr>
<tr><td><code><i>   599</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   600</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //moved&nbsp to&nbsp the&nbsp attached&nbsp state</code></td></tr>
<tr><td><code><i>   601</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceState&nbsp =&nbsp ATTACHED_STATE;</code></td></tr>
<tr><td><code><i>   602</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   603</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #ifdef&nbsp&nbsp USB_SUPPORT_OTG</code></td></tr>
<tr><td><code><i>   604</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1OTGCON&nbsp |=&nbsp USB_OTG_DPLUS_ENABLE&nbsp |&nbsp USB_OTG_ENABLE;&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   605</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   606</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   607</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif&nbsp&nbsp //#if&nbsp defined(USB_POLLING)</code></td></tr>
<tr><td><code><i>   608</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   609</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBDeviceState&nbsp ==&nbsp ATTACHED_STATE)</code></td></tr>
<tr><td><code><i>   610</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   611</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   612</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp After&nbsp enabling&nbsp the&nbsp USB&nbsp module,&nbsp it&nbsp takes&nbsp some&nbsp time&nbsp for&nbsp the</code></td></tr>
<tr><td><code><i>   613</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp voltage&nbsp on&nbsp the&nbsp D+&nbsp or&nbsp D-&nbsp line&nbsp to&nbsp rise&nbsp high&nbsp enough&nbsp to&nbsp get&nbsp out</code></td></tr>
<tr><td><code><i>   614</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp of&nbsp the&nbsp SE0&nbsp condition.&nbsp The&nbsp USB&nbsp Reset&nbsp interrupt&nbsp should&nbsp not&nbsp be</code></td></tr>
<tr><td><code><i>   615</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp unmasked&nbsp until&nbsp the&nbsp SE0&nbsp condition&nbsp is&nbsp cleared.&nbsp This&nbsp helps</code></td></tr>
<tr><td><code><i>   616</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp prevent&nbsp the&nbsp firmware&nbsp from&nbsp misinterpreting&nbsp this&nbsp unique&nbsp event</code></td></tr>
<tr><td><code><i>   617</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp as&nbsp a&nbsp USB&nbsp bus&nbsp reset&nbsp from&nbsp the&nbsp USB&nbsp host.</code></td></tr>
<tr><td><code><i>   618</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   619</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   620</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(!USBSE0Event)</code></td></tr>
<tr><td><code><i>   621</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   622</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //We&nbsp recently&nbsp attached,&nbsp make&nbsp sure&nbsp we&nbsp are&nbsp in&nbsp a&nbsp clean&nbsp state</code></td></tr>
<tr><td><code><i>   623</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(__dsPIC33E__)&nbsp ||&nbsp defined(_PIC24E__)</code></td></tr>
<tr><td><code><i>   624</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1IR&nbsp =&nbsp 0xFFEF;&nbsp&nbsp //Preserve&nbsp IDLEIF&nbsp info,&nbsp so&nbsp we&nbsp can&nbsp detect&nbsp suspend</code></td></tr>
<tr><td><code><i>   625</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //during&nbsp attach&nbsp debounce&nbsp interval</code></td></tr>
<tr><td><code><i>   626</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #else</code></td></tr>
<tr><td><code><i>   627</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptRegister(U1IR);</code></td></tr>
<tr><td><code><i>   628</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   629</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   630</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(USB_POLLING)</code></td></tr>
<tr><td><code><i>   631</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1IE=0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Mask&nbsp all&nbsp USB&nbsp interrupts</code></td></tr>
<tr><td><code><i>   632</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   633</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBResetIE&nbsp =&nbsp 1;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Unmask&nbsp RESET&nbsp interrupt</code></td></tr>
<tr><td><code><i>   634</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBIdleIE&nbsp =&nbsp 1;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Unmask&nbsp IDLE&nbsp interrupt</code></td></tr>
<tr><td><code><i>   635</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceState&nbsp =&nbsp POWERED_STATE;</code></td></tr>
<tr><td><code><i>   636</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   637</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   638</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   639</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #ifdef&nbsp&nbsp USB_SUPPORT_OTG</code></td></tr>
<tr><td><code><i>   640</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //If&nbsp ID&nbsp Pin&nbsp Changed&nbsp State</code></td></tr>
<tr><td><code><i>   641</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if&nbsp (USBIDIF&nbsp &&&nbsp USBIDIE)</code></td></tr>
<tr><td><code><i>   642</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   643</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Re-detect&nbsp &&nbsp Initialize</code></td></tr>
<tr><td><code><i>   644</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGInitialize();</code></td></tr>
<tr><td><code><i>   645</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   646</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);</code></td></tr>
<tr><td><code><i>   647</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   648</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   649</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   650</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   651</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Task&nbsp A:&nbsp Service&nbsp USB&nbsp Activity&nbsp Interrupt</code></td></tr>
<tr><td><code><i>   652</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   653</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBActivityIF&nbsp &&&nbsp USBActivityIE)</code></td></tr>
<tr><td><code><i>   654</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   655</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);</code></td></tr>
<tr><td><code><i>   656</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(USB_SUPPORT_OTG)</code></td></tr>
<tr><td><code><i>   657</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1OTGIR&nbsp =&nbsp 0x10;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   658</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #else</code></td></tr>
<tr><td><code><i>   659</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBWakeFromSuspend();</code></td></tr>
<tr><td><code><i>   660</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   661</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   662</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   663</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   664</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Pointless&nbsp to&nbsp continue&nbsp servicing&nbsp if&nbsp the&nbsp device&nbsp is&nbsp in&nbsp suspend&nbsp mode.</code></td></tr>
<tr><td><code><i>   665</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   666</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBSuspendControl==1)</code></td></tr>
<tr><td><code><i>   667</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   668</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearUSBInterrupt();</code></td></tr>
<tr><td><code><i>   669</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return;</code></td></tr>
<tr><td><code><i>   670</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   671</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   672</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   673</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Task&nbsp B:&nbsp Service&nbsp USB&nbsp Bus&nbsp Reset&nbsp Interrupt.</code></td></tr>
<tr><td><code><i>   674</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp When&nbsp bus&nbsp reset&nbsp is&nbsp received&nbsp during&nbsp suspend,&nbsp ACTVIF&nbsp will&nbsp be&nbsp set&nbsp first,</code></td></tr>
<tr><td><code><i>   675</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp once&nbsp the&nbsp UCONbits.SUSPND&nbsp is&nbsp clear,&nbsp then&nbsp the&nbsp URSTIF&nbsp bit&nbsp will&nbsp be&nbsp asserted.</code></td></tr>
<tr><td><code><i>   676</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp This&nbsp is&nbsp why&nbsp URSTIF&nbsp is&nbsp checked&nbsp after&nbsp ACTVIF.</code></td></tr>
<tr><td><code><i>   677</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   678</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp The&nbsp USB&nbsp reset&nbsp flag&nbsp is&nbsp masked&nbsp when&nbsp the&nbsp USB&nbsp state&nbsp is&nbsp in</code></td></tr>
<tr><td><code><i>   679</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp DETACHED_STATE&nbsp or&nbsp ATTACHED_STATE,&nbsp and&nbsp therefore&nbsp cannot</code></td></tr>
<tr><td><code><i>   680</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp cause&nbsp a&nbsp USB&nbsp reset&nbsp event&nbsp during&nbsp these&nbsp two&nbsp states.</code></td></tr>
<tr><td><code><i>   681</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   682</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBResetIF&nbsp &&&nbsp USBResetIE)</code></td></tr>
<tr><td><code><i>   683</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   684</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceInit();</code></td></tr>
<tr><td><code><i>   685</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   686</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Re-enable&nbsp the&nbsp interrupts&nbsp since&nbsp the&nbsp USBDeviceInit()&nbsp function&nbsp will</code></td></tr>
<tr><td><code><i>   687</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp disable&nbsp them.&nbsp&nbsp This&nbsp will&nbsp do&nbsp nothing&nbsp in&nbsp a&nbsp polling&nbsp setup</code></td></tr>
<tr><td><code><i>   688</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBUnmaskInterrupts();</code></td></tr>
<tr><td><code><i>   689</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   690</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceState&nbsp =&nbsp DEFAULT_STATE;</code></td></tr>
<tr><td><code><i>   691</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   692</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #ifdef&nbsp USB_SUPPORT_OTG</code></td></tr>
<tr><td><code><i>   693</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Disable&nbsp HNP</code></td></tr>
<tr><td><code><i>   694</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGDisableHnp();</code></td></tr>
<tr><td><code><i>   695</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   696</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Deactivate&nbsp HNP</code></td></tr>
<tr><td><code><i>   697</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGDeactivateHnp();</code></td></tr>
<tr><td><code><i>   698</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   699</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   700</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);</code></td></tr>
<tr><td><code><i>   701</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   702</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   703</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   704</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Task&nbsp C:&nbsp Service&nbsp other&nbsp USB&nbsp interrupts</code></td></tr>
<tr><td><code><i>   705</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   706</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBIdleIF&nbsp &&&nbsp USBIdleIE)</code></td></tr>
<tr><td><code><i>   707</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {&nbsp </code></td></tr>
<tr><td><code><i>   708</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #ifdef&nbsp&nbsp USB_SUPPORT_OTG&nbsp </code></td></tr>
<tr><td><code><i>   709</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //If&nbsp Suspended,&nbsp Try&nbsp to&nbsp switch&nbsp to&nbsp Host</code></td></tr>
<tr><td><code><i>   710</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGSelectRole(ROLE_HOST);</code></td></tr>
<tr><td><code><i>   711</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);</code></td></tr>
<tr><td><code><i>   712</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #else</code></td></tr>
<tr><td><code><i>   713</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBSuspend();</code></td></tr>
<tr><td><code><i>   714</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   715</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   716</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   717</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp defined(__XC16__)&nbsp ||&nbsp defined(__C30__)&nbsp ||&nbsp defined(__XC32__)</code></td></tr>
<tr><td><code><i>   718</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Check&nbsp if&nbsp a&nbsp 1ms&nbsp interval&nbsp has&nbsp elapsed.&nbsp </code></td></tr>
<tr><td><code><i>   719</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBT1MSECIF)</code></td></tr>
<tr><td><code><i>   720</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   721</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBT1MSECIFReg,&nbsp USBT1MSECIFBitNum);</code></td></tr>
<tr><td><code><i>   722</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBIncrement1msInternalTimers();</code></td></tr>
<tr><td><code><i>   723</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   724</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   725</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   726</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Start-of-Frame&nbsp Interrupt</code></td></tr>
<tr><td><code><i>   727</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBSOFIF)</code></td></tr>
<tr><td><code><i>   728</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   729</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Call&nbsp the&nbsp user&nbsp SOF&nbsp event&nbsp callback&nbsp if&nbsp enabled.</code></td></tr>
<tr><td><code><i>   730</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBSOFIE)</code></td></tr>
<tr><td><code><i>   731</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   732</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB_SOF_HANDLER(EVENT_SOF,0,1);</code></td></tr>
<tr><td><code><i>   733</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   734</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);</code></td></tr>
<tr><td><code><i>   735</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   736</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(__XC8__)&nbsp ||&nbsp defined(__C18__)</code></td></tr>
<tr><td><code><i>   737</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBIncrement1msInternalTimers();</code></td></tr>
<tr><td><code><i>   738</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   739</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   740</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)</code></td></tr>
<tr><td><code><i>   741</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Supporting&nbsp this&nbsp feature&nbsp requires&nbsp a&nbsp 1ms&nbsp timebase&nbsp for&nbsp keeping&nbsp track&nbsp of&nbsp the&nbsp timeout&nbsp interval.</code></td></tr>
<tr><td><code><i>   742</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if(USB_SPEED_OPTION&nbsp ==&nbsp USB_LOW_SPEED)</code></td></tr>
<tr><td><code><i>   743</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #warning&nbsp "Double&nbsp click&nbsp this&nbsp message.&nbsp&nbsp See&nbsp inline&nbsp code&nbsp comments."</code></td></tr>
<tr><td><code><i>   744</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //The&nbsp "USB_ENABLE_STATUS_STAGE_TIMEOUTS"&nbsp feature&nbsp is&nbsp optional&nbsp and&nbsp is</code></td></tr>
<tr><td><code><i>   745</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //not&nbsp strictly&nbsp needed&nbsp in&nbsp all&nbsp applications&nbsp (ex:&nbsp those&nbsp that&nbsp never&nbsp call&nbsp </code></td></tr>
<tr><td><code><i>   746</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //USBDeferStatusStage()&nbsp and&nbsp don't&nbsp use&nbsp host&nbsp to&nbsp device&nbsp (OUT)&nbsp control</code></td></tr>
<tr><td><code><i>   747</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //transfers&nbsp with&nbsp data&nbsp stage).&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   748</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //However,&nbsp if&nbsp this&nbsp feature&nbsp is&nbsp enabled&nbsp and&nbsp used&nbsp in&nbsp a&nbsp low&nbsp speed&nbsp application,</code></td></tr>
<tr><td><code><i>   749</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //it&nbsp is&nbsp required&nbsp for&nbsp the&nbsp application&nbsp code&nbsp to&nbsp periodically&nbsp call&nbsp the</code></td></tr>
<tr><td><code><i>   750</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //USBIncrement1msInternalTimers()&nbsp function&nbsp at&nbsp a&nbsp nominally&nbsp 1ms&nbsp rate.</code></td></tr>
<tr><td><code><i>   751</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   752</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   753</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Decrement&nbsp our&nbsp status&nbsp stage&nbsp counter.</code></td></tr>
<tr><td><code><i>   754</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBStatusStageTimeoutCounter&nbsp !=&nbsp 0u)</code></td></tr>
<tr><td><code><i>   755</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   756</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStatusStageTimeoutCounter--;</code></td></tr>
<tr><td><code><i>   757</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   758</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Check&nbsp if&nbsp too&nbsp much&nbsp time&nbsp has&nbsp elapsed&nbsp since&nbsp progress&nbsp was&nbsp made&nbsp in&nbsp </code></td></tr>
<tr><td><code><i>   759</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //processing&nbsp the&nbsp control&nbsp transfer,&nbsp without&nbsp arming&nbsp the&nbsp status&nbsp stage.&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   760</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //If&nbsp so,&nbsp auto-arm&nbsp the&nbsp status&nbsp stage&nbsp to&nbsp ensure&nbsp that&nbsp the&nbsp control&nbsp </code></td></tr>
<tr><td><code><i>   761</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //transfer&nbsp can&nbsp [eventually]&nbsp complete,&nbsp within&nbsp the&nbsp timing&nbsp limits</code></td></tr>
<tr><td><code><i>   762</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //dictated&nbsp by&nbsp section&nbsp 9.2.6&nbsp of&nbsp the&nbsp official&nbsp USB&nbsp 2.0&nbsp specifications.</code></td></tr>
<tr><td><code><i>   763</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBStatusStageTimeoutCounter&nbsp ==&nbsp 0)</code></td></tr>
<tr><td><code><i>   764</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   765</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlEPAllowStatusStage();&nbsp&nbsp&nbsp&nbsp //Does&nbsp nothing&nbsp if&nbsp the&nbsp status&nbsp stage&nbsp was&nbsp already&nbsp armed.</code></td></tr>
<tr><td><code><i>   766</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }&nbsp </code></td></tr>
<tr><td><code><i>   767</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   768</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   769</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   770</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBStallIF&nbsp &&&nbsp USBStallIE)</code></td></tr>
<tr><td><code><i>   771</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   772</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStallHandler();</code></td></tr>
<tr><td><code><i>   773</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   774</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   775</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBErrorIF&nbsp &&&nbsp USBErrorIE)</code></td></tr>
<tr><td><code><i>   776</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   777</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);</code></td></tr>
<tr><td><code><i>   778</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptRegister(U1EIR);&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp This&nbsp clears&nbsp UERRIF</code></td></tr>
<tr><td><code><i>   779</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   780</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //On&nbsp PIC18,&nbsp clearing&nbsp the&nbsp source&nbsp of&nbsp the&nbsp error&nbsp will&nbsp automatically&nbsp clear</code></td></tr>
<tr><td><code><i>   781</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp the&nbsp interrupt&nbsp flag.&nbsp&nbsp On&nbsp other&nbsp devices&nbsp the&nbsp interrupt&nbsp flag&nbsp must&nbsp be&nbsp </code></td></tr>
<tr><td><code><i>   782</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp manually&nbsp cleared.&nbsp </code></td></tr>
<tr><td><code><i>   783</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(__C32__)&nbsp ||&nbsp defined(__C30__)&nbsp ||&nbsp defined&nbsp __XC16__</code></td></tr>
<tr><td><code><i>   784</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(&nbsp USBErrorIFReg,&nbsp USBErrorIFBitNum&nbsp );</code></td></tr>
<tr><td><code><i>   785</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   786</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   787</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   788</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   789</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Pointless&nbsp to&nbsp continue&nbsp servicing&nbsp if&nbsp the&nbsp host&nbsp has&nbsp not&nbsp sent&nbsp a&nbsp bus&nbsp reset.</code></td></tr>
<tr><td><code><i>   790</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Once&nbsp bus&nbsp reset&nbsp is&nbsp received,&nbsp the&nbsp device&nbsp transitions&nbsp into&nbsp the&nbsp DEFAULT</code></td></tr>
<tr><td><code><i>   791</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp state&nbsp and&nbsp is&nbsp ready&nbsp for&nbsp communication.</code></td></tr>
<tr><td><code><i>   792</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   793</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBDeviceState&nbsp&lsaquo &nbsp DEFAULT_STATE)</code></td></tr>
<tr><td><code><i>   794</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   795</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearUSBInterrupt();</code></td></tr>
<tr><td><code><i>   796</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return;</code></td></tr>
<tr><td><code><i>   797</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   798</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   799</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   800</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Task&nbsp D:&nbsp Servicing&nbsp USB&nbsp Transaction&nbsp Complete&nbsp Interrupt</code></td></tr>
<tr><td><code><i>   801</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   802</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBTransactionCompleteIE)</code></td></tr>
<tr><td><code><i>   803</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   804</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp for(i&nbsp =&nbsp 0;&nbsp i&nbsp&lsaquo &nbsp 4u;&nbsp i++) //Drain&nbsp or&nbsp deplete&nbsp the&nbsp USAT&nbsp FIFO&nbsp entries.&nbsp&nbsp If&nbsp the&nbsp USB&nbsp FIFO&nbsp ever&nbsp gets&nbsp full,&nbsp USB&nbsp bandwidth</code></td></tr>
<tr><td><code><i>   805</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //utilization&nbsp can&nbsp be&nbsp compromised,&nbsp and&nbsp the&nbsp device&nbsp won't&nbsp be&nbsp able&nbsp to&nbsp receive&nbsp SETUP&nbsp packets.</code></td></tr>
<tr><td><code><i>   806</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBTransactionCompleteIF)</code></td></tr>
<tr><td><code><i>   807</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   808</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Save&nbsp and&nbsp extract&nbsp USTAT&nbsp register&nbsp info.&nbsp&nbsp Will&nbsp use&nbsp this&nbsp info&nbsp later.</code></td></tr>
<tr><td><code><i>   809</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USTATcopy.Val&nbsp =&nbsp U1STAT;</code></td></tr>
<tr><td><code><i>   810</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp endpoint_number&nbsp =&nbsp USBHALGetLastEndpoint(USTATcopy);</code></td></tr>
<tr><td><code><i>   811</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   812</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);</code></td></tr>
<tr><td><code><i>   813</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   814</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Keep&nbsp track&nbsp of&nbsp the&nbsp hardware&nbsp ping&nbsp pong&nbsp state&nbsp for&nbsp endpoints&nbsp other</code></td></tr>
<tr><td><code><i>   815</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //than&nbsp EP0,&nbsp if&nbsp ping&nbsp pong&nbsp buffering&nbsp is&nbsp enabled.</code></td></tr>
<tr><td><code><i>   816</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__ALL_BUT_EP0)&nbsp ||&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__FULL_PING_PONG)</code></td></tr>
<tr><td><code><i>   817</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBHALGetLastDirection(USTATcopy)&nbsp ==&nbsp OUT_FROM_HOST)</code></td></tr>
<tr><td><code><i>   818</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   819</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ep_data_out[endpoint_number].bits.ping_pong_state&nbsp ^=&nbsp 1;</code></td></tr>
<tr><td><code><i>   820</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   821</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>   822</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   823</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ep_data_in[endpoint_number].bits.ping_pong_state&nbsp ^=&nbsp 1;</code></td></tr>
<tr><td><code><i>   824</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   825</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   826</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   827</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //USBCtrlEPService&nbsp only&nbsp services&nbsp transactions&nbsp over&nbsp EP0.</code></td></tr>
<tr><td><code><i>   828</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //It&nbsp ignores&nbsp all&nbsp other&nbsp EP&nbsp transactions.</code></td></tr>
<tr><td><code><i>   829</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(endpoint_number&nbsp ==&nbsp 0)</code></td></tr>
<tr><td><code><i>   830</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   831</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlEPService();</code></td></tr>
<tr><td><code><i>   832</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   833</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>   834</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   835</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER,&nbsp (uint8_t*)&USTATcopy.Val,&nbsp 0);</code></td></tr>
<tr><td><code><i>   836</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   837</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }//end&nbsp if(USBTransactionCompleteIF)</code></td></tr>
<tr><td><code><i>   838</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>   839</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   840</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;&nbsp //USTAT&nbsp FIFO&nbsp must&nbsp be&nbsp empty.</code></td></tr>
<tr><td><code><i>   841</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   842</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }//end&nbsp for()</code></td></tr>
<tr><td><code><i>   843</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp if(USBTransactionCompleteIE)</code></td></tr>
<tr><td><code><i>   844</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   845</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBClearUSBInterrupt();</code></td></tr>
<tr><td><code><i>   846</i> </code></td><td><code>&nbsp }//end&nbsp of&nbsp USBDeviceTasks()</code></td></tr>
<tr><td><code><i>   847</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   848</i> </code></td><td><code>&nbsp /*******************************************************************************</code></td></tr>
<tr><td><code><i>   849</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   850</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBEnableEndpoint(uint8_t&nbsp ep,&nbsp uint8_t&nbsp options)</code></td></tr>
<tr><td><code><i>   851</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   852</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>   853</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp will&nbsp enable&nbsp the&nbsp specified&nbsp endpoint&nbsp with&nbsp the&nbsp specified</code></td></tr>
<tr><td><code><i>   854</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp options</code></td></tr>
<tr><td><code><i>   855</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   856</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp will&nbsp enable&nbsp the&nbsp specified&nbsp endpoint&nbsp with&nbsp the&nbsp specified</code></td></tr>
<tr><td><code><i>   857</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp options.</code></td></tr>
<tr><td><code><i>   858</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   859</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Typical&nbsp Usage:</code></td></tr>
<tr><td><code><i>   860</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  code&rsaquo  </code></td></tr>
<tr><td><code><i>   861</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp void&nbsp USBCBInitEP(void)</code></td></tr>
<tr><td><code><i>   862</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   863</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);</code></td></tr>
<tr><td><code><i>   864</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBMSDInit();</code></td></tr>
<tr><td><code><i>   865</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   866</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  /code&rsaquo  </code></td></tr>
<tr><td><code><i>   867</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   868</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp In&nbsp the&nbsp above&nbsp example&nbsp endpoint&nbsp number&nbsp MSD_DATA_IN_EP&nbsp is&nbsp being&nbsp configured</code></td></tr>
<tr><td><code><i>   869</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp for&nbsp both&nbsp IN&nbsp and&nbsp OUT&nbsp traffic&nbsp with&nbsp handshaking&nbsp enabled.&nbsp Also&nbsp since</code></td></tr>
<tr><td><code><i>   870</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp MSD_DATA_IN_EP&nbsp is&nbsp not&nbsp endpoint&nbsp 0&nbsp (MSD&nbsp does&nbsp not&nbsp allow&nbsp this),&nbsp then&nbsp we&nbsp can</code></td></tr>
<tr><td><code><i>   871</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp explicitly&nbsp disable&nbsp SETUP&nbsp packets&nbsp on&nbsp this&nbsp endpoint.</code></td></tr>
<tr><td><code><i>   872</i> </code></td><td><code>&nbsp &nbsp&nbsp Conditions:</code></td></tr>
<tr><td><code><i>   873</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>   874</i> </code></td><td><code>&nbsp &nbsp&nbsp Input:</code></td></tr>
<tr><td><code><i>   875</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp ep&nbsp -&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp endpoint&nbsp to&nbsp be&nbsp configured</code></td></tr>
<tr><td><code><i>   876</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp options&nbsp -&nbsp&nbsp optional&nbsp settings&nbsp for&nbsp the&nbsp endpoint.&nbsp The&nbsp options&nbsp should</code></td></tr>
<tr><td><code><i>   877</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp be&nbsp ORed&nbsp together&nbsp to&nbsp form&nbsp a&nbsp single&nbsp options&nbsp string.&nbsp The</code></td></tr>
<tr><td><code><i>   878</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp available&nbsp optional&nbsp settings&nbsp for&nbsp the&nbsp endpoint.&nbsp The</code></td></tr>
<tr><td><code><i>   879</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp options&nbsp should&nbsp be&nbsp ORed&nbsp together&nbsp to&nbsp form&nbsp a&nbsp single&nbsp options</code></td></tr>
<tr><td><code><i>   880</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp string.&nbsp The&nbsp available&nbsp options&nbsp are&nbsp the&nbsp following\:</code></td></tr>
<tr><td><code><i>   881</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp USB_HANDSHAKE_ENABLED&nbsp enables&nbsp USB&nbsp handshaking&nbsp (ACK,</code></td></tr>
<tr><td><code><i>   882</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp NAK)</code></td></tr>
<tr><td><code><i>   883</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp USB_HANDSHAKE_DISABLED&nbsp disables&nbsp USB&nbsp handshaking&nbsp (ACK,</code></td></tr>
<tr><td><code><i>   884</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp NAK)</code></td></tr>
<tr><td><code><i>   885</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp USB_OUT_ENABLED&nbsp enables&nbsp the&nbsp out&nbsp direction</code></td></tr>
<tr><td><code><i>   886</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp USB_OUT_DISABLED&nbsp disables&nbsp the&nbsp out&nbsp direction</code></td></tr>
<tr><td><code><i>   887</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp USB_IN_ENABLED&nbsp enables&nbsp the&nbsp in&nbsp direction</code></td></tr>
<tr><td><code><i>   888</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp USB_IN_DISABLED&nbsp disables&nbsp the&nbsp in&nbsp direction</code></td></tr>
<tr><td><code><i>   889</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp USB_ALLOW_SETUP&nbsp enables&nbsp control&nbsp transfers</code></td></tr>
<tr><td><code><i>   890</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp USB_DISALLOW_SETUP&nbsp disables&nbsp control&nbsp transfers</code></td></tr>
<tr><td><code><i>   891</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp USB_STALL_ENDPOINT&nbsp STALLs&nbsp this&nbsp endpoint</code></td></tr>
<tr><td><code><i>   892</i> </code></td><td><code>&nbsp &nbsp&nbsp Return:</code></td></tr>
<tr><td><code><i>   893</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>   894</i> </code></td><td><code>&nbsp &nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>   895</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp None&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   896</i> </code></td><td><code>&nbsp &nbsp&nbsp *****************************************************************************/</code></td></tr>
<tr><td><code><i>   897</i> </code></td><td><code>&nbsp void&nbsp USBEnableEndpoint(uint8_t&nbsp ep,&nbsp uint8_t&nbsp options)</code></td></tr>
<tr><td><code><i>   898</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   899</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp unsigned&nbsp char*&nbsp p;</code></td></tr>
<tr><td><code><i>   900</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   901</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Use&nbsp USBConfigureEndpoint()&nbsp to&nbsp set&nbsp up&nbsp the&nbsp pBDTEntryIn/Out[ep]&nbsp pointer&nbsp and&nbsp </code></td></tr>
<tr><td><code><i>   902</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //starting&nbsp DTS&nbsp state&nbsp in&nbsp the&nbsp BDT&nbsp entry.</code></td></tr>
<tr><td><code><i>   903</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(options&nbsp &&nbsp USB_OUT_ENABLED)</code></td></tr>
<tr><td><code><i>   904</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   905</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBConfigureEndpoint(ep,&nbsp OUT_FROM_HOST);</code></td></tr>
<tr><td><code><i>   906</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   907</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(options&nbsp &&nbsp USB_IN_ENABLED)</code></td></tr>
<tr><td><code><i>   908</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   909</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBConfigureEndpoint(ep,&nbsp IN_TO_HOST);</code></td></tr>
<tr><td><code><i>   910</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   911</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   912</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Update&nbsp the&nbsp relevant&nbsp UEPx&nbsp register&nbsp to&nbsp actually&nbsp enable&nbsp the&nbsp endpoint&nbsp with</code></td></tr>
<tr><td><code><i>   913</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //the&nbsp specified&nbsp options&nbsp (ex:&nbsp handshaking&nbsp enabled,&nbsp control&nbsp transfers&nbsp allowed,</code></td></tr>
<tr><td><code><i>   914</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //etc.)</code></td></tr>
<tr><td><code><i>   915</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp defined(__C32__)</code></td></tr>
<tr><td><code><i>   916</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p&nbsp =&nbsp (unsigned&nbsp char*)(&U1EP0+(4*ep));</code></td></tr>
<tr><td><code><i>   917</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #else</code></td></tr>
<tr><td><code><i>   918</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p&nbsp =&nbsp (unsigned&nbsp char*)(&U1EP0+ep);</code></td></tr>
<tr><td><code><i>   919</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   920</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp *p&nbsp =&nbsp options;</code></td></tr>
<tr><td><code><i>   921</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>   922</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   923</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   924</i> </code></td><td><code>&nbsp /*************************************************************************</code></td></tr>
<tr><td><code><i>   925</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   926</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB_HANDLE&nbsp USBTransferOnePacket(uint8_t&nbsp ep,&nbsp uint8_t&nbsp dir,&nbsp uint8_t*&nbsp data,&nbsp uint8_t&nbsp len)</code></td></tr>
<tr><td><code><i>   927</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   928</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>   929</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Transfers&nbsp a&nbsp single&nbsp packet&nbsp (one&nbsp transaction)&nbsp of&nbsp data&nbsp on&nbsp the&nbsp USB&nbsp bus.</code></td></tr>
<tr><td><code><i>   930</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   931</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   932</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp The&nbsp USBTransferOnePacket()&nbsp function&nbsp prepares&nbsp a&nbsp USB&nbsp endpoint</code></td></tr>
<tr><td><code><i>   933</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp so&nbsp that&nbsp it&nbsp may&nbsp send&nbsp data&nbsp to&nbsp the&nbsp host&nbsp (an&nbsp IN&nbsp transaction),&nbsp or&nbsp </code></td></tr>
<tr><td><code><i>   934</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp receive&nbsp data&nbsp from&nbsp the&nbsp host&nbsp (an&nbsp OUT&nbsp transaction).&nbsp&nbsp The&nbsp </code></td></tr>
<tr><td><code><i>   935</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBTransferOnePacket()&nbsp function&nbsp can&nbsp be&nbsp used&nbsp both&nbsp to&nbsp receive and&nbsp </code></td></tr>
<tr><td><code><i>   936</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp send&nbsp data&nbsp to&nbsp the&nbsp host.&nbsp&nbsp This&nbsp function&nbsp is&nbsp the&nbsp primary&nbsp API&nbsp function&nbsp </code></td></tr>
<tr><td><code><i>   937</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp provided&nbsp by&nbsp the&nbsp USB&nbsp stack&nbsp firmware&nbsp for&nbsp sending&nbsp or&nbsp receiving&nbsp application&nbsp </code></td></tr>
<tr><td><code><i>   938</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp data&nbsp over&nbsp the&nbsp USB&nbsp port.&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   939</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   940</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp The&nbsp USBTransferOnePacket()&nbsp is&nbsp intended&nbsp for&nbsp use&nbsp with&nbsp all&nbsp application&nbsp </code></td></tr>
<tr><td><code><i>   941</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp endpoints.&nbsp&nbsp It&nbsp is&nbsp not&nbsp used&nbsp for&nbsp sending&nbsp or&nbsp receiving&nbsp applicaiton&nbsp data&nbsp </code></td></tr>
<tr><td><code><i>   942</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp through&nbsp endpoint&nbsp 0&nbsp by&nbsp using&nbsp control&nbsp transfers.&nbsp&nbsp Separate&nbsp API&nbsp </code></td></tr>
<tr><td><code><i>   943</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp functions,&nbsp such&nbsp as&nbsp USBEP0Receive(),&nbsp USBEP0SendRAMPtr(),&nbsp and</code></td></tr>
<tr><td><code><i>   944</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBEP0SendROMPtr()&nbsp are&nbsp provided&nbsp for&nbsp this&nbsp purpose.</code></td></tr>
<tr><td><code><i>   945</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   946</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp The USBTransferOnePacket()&nbsp writes&nbsp to&nbsp the&nbsp Buffer&nbsp Descriptor&nbsp Table&nbsp (BDT)</code></td></tr>
<tr><td><code><i>   947</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp entry&nbsp associated&nbsp with&nbsp an&nbsp endpoint&nbsp buffer,&nbsp and&nbsp sets&nbsp the&nbsp UOWN&nbsp bit,&nbsp which&nbsp </code></td></tr>
<tr><td><code><i>   948</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp prepares&nbsp the&nbsp USB&nbsp hardware&nbsp to&nbsp allow&nbsp the&nbsp transaction&nbsp to&nbsp complete.&nbsp&nbsp The&nbsp </code></td></tr>
<tr><td><code><i>   949</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp application&nbsp firmware&nbsp can&nbsp use&nbsp the&nbsp USBHandleBusy()&nbsp macro&nbsp to&nbsp check&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>   950</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp status&nbsp of&nbsp the&nbsp transaction,&nbsp to&nbsp see&nbsp if&nbsp the&nbsp data&nbsp has&nbsp been&nbsp successfully&nbsp </code></td></tr>
<tr><td><code><i>   951</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp transmitted&nbsp yet.</code></td></tr>
<tr><td><code><i>   952</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   953</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   954</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Typical&nbsp Usage</code></td></tr>
<tr><td><code><i>   955</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  code&rsaquo  </code></td></tr>
<tr><td><code><i>   956</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //make&nbsp sure&nbsp that&nbsp the&nbsp we&nbsp are&nbsp in&nbsp the&nbsp configured&nbsp state</code></td></tr>
<tr><td><code><i>   957</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBGetDeviceState()&nbsp ==&nbsp CONFIGURED_STATE)</code></td></tr>
<tr><td><code><i>   958</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   959</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //make&nbsp sure&nbsp that&nbsp the&nbsp last&nbsp transaction&nbsp isn't&nbsp busy&nbsp by&nbsp checking&nbsp the&nbsp handle</code></td></tr>
<tr><td><code><i>   960</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(!USBHandleBusy(USBInHandle))</code></td></tr>
<tr><td><code><i>   961</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   962</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Write&nbsp the&nbsp new&nbsp data&nbsp that&nbsp we&nbsp wish&nbsp to&nbsp send&nbsp to&nbsp the&nbsp host&nbsp to&nbsp the&nbsp INPacket[]&nbsp array</code></td></tr>
<tr><td><code><i>   963</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp INPacket[0]&nbsp =&nbsp USEFUL_APPLICATION_VALUE1;</code></td></tr>
<tr><td><code><i>   964</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp INPacket[1]&nbsp =&nbsp USEFUL_APPLICATION_VALUE2;</code></td></tr>
<tr><td><code><i>   965</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //INPacket[2]&nbsp =&nbsp ...&nbsp (fill&nbsp in&nbsp the&nbsp rest&nbsp of&nbsp the&nbsp packet&nbsp data)</code></td></tr>
<tr><td><code><i>   966</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   967</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Send&nbsp the&nbsp data&nbsp contained&nbsp in&nbsp the&nbsp INPacket[]&nbsp array&nbsp through&nbsp endpoint&nbsp "EP_NUM"</code></td></tr>
<tr><td><code><i>   968</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBInHandle&nbsp =&nbsp USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));</code></td></tr>
<tr><td><code><i>   969</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   970</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   971</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  /code&rsaquo  </code></td></tr>
<tr><td><code><i>   972</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   973</i> </code></td><td><code>&nbsp &nbsp&nbsp Conditions:</code></td></tr>
<tr><td><code><i>   974</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Before&nbsp calling&nbsp USBTransferOnePacket(),&nbsp the&nbsp following&nbsp should&nbsp be&nbsp true.</code></td></tr>
<tr><td><code><i>   975</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp 1.&nbsp&nbsp The&nbsp USB&nbsp stack&nbsp has&nbsp already&nbsp been&nbsp initialized&nbsp (USBDeviceInit()&nbsp was&nbsp called).</code></td></tr>
<tr><td><code><i>   976</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp 2.&nbsp&nbsp A&nbsp transaction&nbsp is&nbsp not&nbsp already&nbsp pending&nbsp on&nbsp the&nbsp specified&nbsp endpoint.&nbsp&nbsp This</code></td></tr>
<tr><td><code><i>   977</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp is&nbsp done&nbsp by&nbsp checking&nbsp the&nbsp previous&nbsp request&nbsp using&nbsp the&nbsp USBHandleBusy()&nbsp </code></td></tr>
<tr><td><code><i>   978</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp macro&nbsp (see&nbsp the&nbsp typical&nbsp usage&nbsp example).</code></td></tr>
<tr><td><code><i>   979</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp 3.&nbsp&nbsp The&nbsp host&nbsp has&nbsp already&nbsp sent&nbsp a&nbsp set&nbsp configuration&nbsp request&nbsp and&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>   980</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp enumeration&nbsp process&nbsp is&nbsp complete.</code></td></tr>
<tr><td><code><i>   981</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp can&nbsp be&nbsp checked&nbsp by&nbsp verifying&nbsp that&nbsp the&nbsp USBGetDeviceState()&nbsp </code></td></tr>
<tr><td><code><i>   982</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp macro&nbsp returns&nbsp "CONFIGURED_STATE",&nbsp prior&nbsp to&nbsp calling&nbsp </code></td></tr>
<tr><td><code><i>   983</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBTransferOnePacket().</code></td></tr>
<tr><td><code><i>   984</i> </code></td><td><code>&nbsp &nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   985</i> </code></td><td><code>&nbsp &nbsp&nbsp Input:</code></td></tr>
<tr><td><code><i>   986</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp ep&nbsp -&nbsp The&nbsp endpoint&nbsp number&nbsp that&nbsp the&nbsp data&nbsp will&nbsp be&nbsp transmitted&nbsp or</code></td></tr>
<tr><td><code><i>   987</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp received&nbsp on</code></td></tr>
<tr><td><code><i>   988</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp dir&nbsp -&nbsp The&nbsp direction&nbsp of&nbsp the&nbsp transfer</code></td></tr>
<tr><td><code><i>   989</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp value&nbsp is&nbsp either&nbsp OUT_FROM_HOST&nbsp or&nbsp IN_TO_HOST</code></td></tr>
<tr><td><code><i>   990</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t*&nbsp data&nbsp -&nbsp For&nbsp IN&nbsp transactions:&nbsp pointer&nbsp to&nbsp the&nbsp RAM&nbsp buffer&nbsp containing</code></td></tr>
<tr><td><code><i>   991</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp data&nbsp to&nbsp be&nbsp sent&nbsp to&nbsp the&nbsp host.&nbsp&nbsp For&nbsp OUT&nbsp transactions:&nbsp pointer</code></td></tr>
<tr><td><code><i>   992</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp to&nbsp the&nbsp RAM&nbsp buffer&nbsp that&nbsp the&nbsp received&nbsp data&nbsp should&nbsp get&nbsp written&nbsp to.</code></td></tr>
<tr><td><code><i>   993</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp uint8_t&nbsp len&nbsp -&nbsp Length&nbsp of&nbsp the&nbsp data&nbsp needing&nbsp to&nbsp be&nbsp sent&nbsp (for&nbsp IN&nbsp transactions).</code></td></tr>
<tr><td><code><i>   994</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp For&nbsp OUT&nbsp transactions,&nbsp the&nbsp len&nbsp parameter&nbsp should&nbsp normally&nbsp be&nbsp set</code></td></tr>
<tr><td><code><i>   995</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp to&nbsp the&nbsp endpoint&nbsp size&nbsp specified&nbsp in&nbsp the&nbsp endpoint&nbsp descriptor.&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   996</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   997</i> </code></td><td><code>&nbsp &nbsp&nbsp Return&nbsp Values:</code></td></tr>
<tr><td><code><i>   998</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB_HANDLE&nbsp -&nbsp handle&nbsp to&nbsp the&nbsp transfer.&nbsp&nbsp The&nbsp handle&nbsp is&nbsp a&nbsp pointer&nbsp to&nbsp </code></td></tr>
<tr><td><code><i>   999</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp BDT&nbsp entry&nbsp associated&nbsp with&nbsp this&nbsp transaction.&nbsp&nbsp The</code></td></tr>
<tr><td><code><i>  1000</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp status&nbsp of&nbsp the&nbsp transaction&nbsp (ex:&nbsp if&nbsp it&nbsp is&nbsp complete&nbsp or&nbsp still</code></td></tr>
<tr><td><code><i>  1001</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pending)&nbsp can&nbsp be&nbsp checked&nbsp using&nbsp the&nbsp USBHandleBusy()&nbsp macro</code></td></tr>
<tr><td><code><i>  1002</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp and&nbsp supplying&nbsp the&nbsp USB_HANDLE&nbsp provided&nbsp by</code></td></tr>
<tr><td><code><i>  1003</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBTransferOnePacket().</code></td></tr>
<tr><td><code><i>  1004</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1005</i> </code></td><td><code>&nbsp &nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>  1006</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp If&nbsp calling&nbsp the&nbsp USBTransferOnePacket()&nbsp function&nbsp from&nbsp within&nbsp the&nbsp USBCBInitEP()</code></td></tr>
<tr><td><code><i>  1007</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp callback&nbsp function,&nbsp the&nbsp set&nbsp configuration&nbsp is&nbsp still&nbsp being&nbsp processed&nbsp and&nbsp the</code></td></tr>
<tr><td><code><i>  1008</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeviceState&nbsp may&nbsp not&nbsp be&nbsp ==&nbsp CONFIGURED_STATE&nbsp yet.&nbsp&nbsp In&nbsp this special&nbsp case,&nbsp </code></td></tr>
<tr><td><code><i>  1009</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp USBTransferOnePacket()&nbsp may&nbsp still&nbsp be&nbsp called,&nbsp but&nbsp make&nbsp sure&nbsp that&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  1010</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp endpoint&nbsp has&nbsp been&nbsp enabled&nbsp and&nbsp initialized&nbsp by&nbsp the&nbsp USBEnableEndpoint()&nbsp </code></td></tr>
<tr><td><code><i>  1011</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp function&nbsp first.&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1012</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1013</i> </code></td><td><code>&nbsp &nbsp&nbsp *************************************************************************/</code></td></tr>
<tr><td><code><i>  1014</i> </code></td><td><code>&nbsp USB_HANDLE&nbsp USBTransferOnePacket(uint8_t&nbsp ep,uint8_t&nbsp dir,uint8_t*&nbsp data,uint8_t&nbsp len)</code></td></tr>
<tr><td><code><i>  1015</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  1016</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp volatile&nbsp BDT_ENTRY*&nbsp handle;</code></td></tr>
<tr><td><code><i>  1017</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1018</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //If&nbsp the&nbsp direction&nbsp is&nbsp IN</code></td></tr>
<tr><td><code><i>  1019</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(dir&nbsp !=&nbsp 0)</code></td></tr>
<tr><td><code><i>  1020</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1021</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //point&nbsp to&nbsp the&nbsp IN&nbsp BDT&nbsp of&nbsp the&nbsp specified&nbsp endpoint</code></td></tr>
<tr><td><code><i>  1022</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp handle&nbsp =&nbsp pBDTEntryIn[ep];</code></td></tr>
<tr><td><code><i>  1023</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1024</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  1025</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1026</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //else&nbsp point&nbsp to&nbsp the&nbsp OUT&nbsp BDT&nbsp of&nbsp the&nbsp specified&nbsp endpoint</code></td></tr>
<tr><td><code><i>  1027</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp handle&nbsp =&nbsp pBDTEntryOut[ep];</code></td></tr>
<tr><td><code><i>  1028</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1029</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1030</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Error&nbsp checking&nbsp code.&nbsp&nbsp Make&nbsp sure&nbsp the&nbsp handle&nbsp (pBDTEntryIn[ep]&nbsp or</code></td></tr>
<tr><td><code><i>  1031</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //pBDTEntryOut[ep])&nbsp is&nbsp initialized&nbsp before&nbsp using&nbsp it.</code></td></tr>
<tr><td><code><i>  1032</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(handle&nbsp ==&nbsp 0)</code></td></tr>
<tr><td><code><i>  1033</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1034</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return&nbsp 0;</code></td></tr>
<tr><td><code><i>  1035</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1036</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1037</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Toggle&nbsp the&nbsp DTS&nbsp bit&nbsp if&nbsp required</code></td></tr>
<tr><td><code><i>  1038</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__NO_PING_PONG)</code></td></tr>
<tr><td><code><i>  1039</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp handle-&rsaquo  STAT.Val&nbsp ^=&nbsp _DTSMASK;</code></td></tr>
<tr><td><code><i>  1040</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #elif&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__EP0_OUT_ONLY)</code></td></tr>
<tr><td><code><i>  1041</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(ep&nbsp !=&nbsp 0)</code></td></tr>
<tr><td><code><i>  1042</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1043</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp handle-&rsaquo  STAT.Val&nbsp ^=&nbsp _DTSMASK;</code></td></tr>
<tr><td><code><i>  1044</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1045</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  1046</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1047</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Set&nbsp the&nbsp data&nbsp pointer,&nbsp data&nbsp length,&nbsp and&nbsp enable&nbsp the&nbsp endpoint</code></td></tr>
<tr><td><code><i>  1048</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp handle-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(data);</code></td></tr>
<tr><td><code><i>  1049</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp handle-&rsaquo  CNT&nbsp =&nbsp len;</code></td></tr>
<tr><td><code><i>  1050</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp handle-&rsaquo  STAT.Val&nbsp &=&nbsp _DTSMASK;</code></td></tr>
<tr><td><code><i>  1051</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp handle-&rsaquo  STAT.Val&nbsp |=&nbsp (_DTSEN&nbsp &&nbsp _DTS_CHECKING_ENABLED);</code></td></tr>
<tr><td><code><i>  1052</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp handle-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1053</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1054</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Point&nbsp to&nbsp the&nbsp next&nbsp buffer&nbsp for&nbsp ping&nbsp pong&nbsp purposes.</code></td></tr>
<tr><td><code><i>  1055</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(dir&nbsp !=&nbsp OUT_FROM_HOST)</code></td></tr>
<tr><td><code><i>  1056</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1057</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //toggle&nbsp over&nbsp the&nbsp to&nbsp the&nbsp next&nbsp buffer&nbsp for&nbsp an&nbsp IN&nbsp endpoint</code></td></tr>
<tr><td><code><i>  1058</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBAdvancePingPongBuffer(&pBDTEntryIn[ep]);&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1059</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1060</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  1061</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1062</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //toggle&nbsp over&nbsp the&nbsp to&nbsp the&nbsp next&nbsp buffer&nbsp for&nbsp an&nbsp OUT&nbsp endpoint</code></td></tr>
<tr><td><code><i>  1063</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBAdvancePingPongBuffer(&pBDTEntryOut[ep]);&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1064</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1065</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp return&nbsp (USB_HANDLE)handle;</code></td></tr>
<tr><td><code><i>  1066</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>  1067</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1068</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1069</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  1070</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>  1071</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBStallEndpoint(uint8_t&nbsp ep,&nbsp uint8_t&nbsp dir)</code></td></tr>
<tr><td><code><i>  1072</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1073</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>  1074</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Configures&nbsp the&nbsp specified&nbsp endpoint&nbsp to&nbsp send&nbsp STALL&nbsp to&nbsp the&nbsp host,&nbsp the&nbsp next</code></td></tr>
<tr><td><code><i>  1075</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp time&nbsp the&nbsp host&nbsp tries&nbsp to&nbsp access&nbsp the&nbsp endpoint.</code></td></tr>
<tr><td><code><i>  1076</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1077</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp PreCondition:</code></td></tr>
<tr><td><code><i>  1078</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1079</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1080</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Parameters:</code></td></tr>
<tr><td><code><i>  1081</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp uint8_t&nbsp ep&nbsp -&nbsp The&nbsp endpoint&nbsp number&nbsp that&nbsp should&nbsp be&nbsp configured&nbsp to&nbsp send&nbsp STALL.</code></td></tr>
<tr><td><code><i>  1082</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp uint8_t&nbsp dir&nbsp -&nbsp The&nbsp direction&nbsp of&nbsp the&nbsp endpoint&nbsp to&nbsp STALL,&nbsp either</code></td></tr>
<tr><td><code><i>  1083</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IN_TO_HOST&nbsp or&nbsp OUT_FROM_HOST.</code></td></tr>
<tr><td><code><i>  1084</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1085</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Return&nbsp Values:</code></td></tr>
<tr><td><code><i>  1086</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1087</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1088</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>  1089</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1090</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1091</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>  1092</i> </code></td><td><code>&nbsp void&nbsp USBStallEndpoint(uint8_t&nbsp ep,&nbsp uint8_t&nbsp dir)</code></td></tr>
<tr><td><code><i>  1093</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  1094</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp BDT_ENTRY&nbsp *p;</code></td></tr>
<tr><td><code><i>  1095</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1096</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(ep&nbsp ==&nbsp 0)</code></td></tr>
<tr><td><code><i>  1097</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1098</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //For&nbsp control&nbsp endpoints&nbsp (ex:&nbsp EP0),&nbsp we&nbsp need&nbsp to&nbsp STALL&nbsp both&nbsp IN&nbsp and&nbsp OUT</code></td></tr>
<tr><td><code><i>  1099</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //endpoints.&nbsp&nbsp EP0&nbsp OUT&nbsp must&nbsp also&nbsp be&nbsp prepared&nbsp to&nbsp receive&nbsp the&nbsp next&nbsp SETUP&nbsp </code></td></tr>
<tr><td><code><i>  1100</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //packet&nbsp that&nbsp will&nbsp arrrive.</code></td></tr>
<tr><td><code><i>  1101</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  CNT&nbsp =&nbsp USB_EP0_BUFF_SIZE;</code></td></tr>
<tr><td><code><i>  1102</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(&SetupPkt);</code></td></tr>
<tr><td><code><i>  1103</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp =&nbsp _DAT0|(_DTSEN&nbsp &&nbsp _DTS_CHECKING_ENABLED)|_BSTALL;</code></td></tr>
<tr><td><code><i>  1104</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1105</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp =&nbsp _BSTALL;&nbsp </code></td></tr>
<tr><td><code><i>  1106</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1107</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1108</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1109</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  1110</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1111</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p&nbsp =&nbsp (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);</code></td></tr>
<tr><td><code><i>  1112</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp |=&nbsp _BSTALL;</code></td></tr>
<tr><td><code><i>  1113</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1114</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1115</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //If&nbsp the&nbsp device&nbsp is&nbsp in&nbsp FULL&nbsp or&nbsp ALL_BUT_EP0&nbsp ping&nbsp pong&nbsp modes</code></td></tr>
<tr><td><code><i>  1116</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //then&nbsp stall&nbsp that&nbsp entry&nbsp as&nbsp well</code></td></tr>
<tr><td><code><i>  1117</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__FULL_PING_PONG)&nbsp ||&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__ALL_BUT_EP0)</code></td></tr>
<tr><td><code><i>  1118</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p&nbsp =&nbsp (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);</code></td></tr>
<tr><td><code><i>  1119</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp |=&nbsp _BSTALL;</code></td></tr>
<tr><td><code><i>  1120</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1121</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  1122</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1123</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>  1124</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1125</i> </code></td><td><code>&nbsp /**************************************************************************</code></td></tr>
<tr><td><code><i>  1126</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>  1127</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBCancelIO(uint8_t&nbsp endpoint)</code></td></tr>
<tr><td><code><i>  1128</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1129</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>  1130</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp cancels&nbsp the&nbsp transfers&nbsp pending&nbsp on&nbsp the&nbsp specified&nbsp endpoint.</code></td></tr>
<tr><td><code><i>  1131</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp can&nbsp only&nbsp be&nbsp used&nbsp after&nbsp a&nbsp SETUP&nbsp packet&nbsp is&nbsp received&nbsp and&nbsp </code></td></tr>
<tr><td><code><i>  1132</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp before&nbsp that&nbsp setup&nbsp packet&nbsp is&nbsp handled.&nbsp&nbsp This&nbsp is&nbsp the&nbsp time&nbsp period&nbsp in&nbsp which</code></td></tr>
<tr><td><code><i>  1133</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp EVENT_EP0_REQUEST&nbsp is&nbsp thrown,&nbsp before&nbsp the&nbsp event&nbsp handler&nbsp function</code></td></tr>
<tr><td><code><i>  1134</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp returns&nbsp to&nbsp the&nbsp stack.</code></td></tr>
<tr><td><code><i>  1135</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1136</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Precondition:</code></td></tr>
<tr><td><code><i>  1137</i> </code></td><td><code>&nbsp &nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1138</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Parameters:</code></td></tr>
<tr><td><code><i>  1139</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp uint8_t&nbsp endpoint&nbsp -&nbsp the&nbsp endpoint&nbsp number&nbsp you&nbsp wish&nbsp to&nbsp cancel&nbsp the&nbsp transfers&nbsp for</code></td></tr>
<tr><td><code><i>  1140</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1141</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Return&nbsp Values:</code></td></tr>
<tr><td><code><i>  1142</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1143</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1144</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>  1145</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1146</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1147</i> </code></td><td><code>&nbsp &nbsp&nbsp **************************************************************************/</code></td></tr>
<tr><td><code><i>  1148</i> </code></td><td><code>&nbsp void&nbsp USBCancelIO(uint8_t&nbsp endpoint)</code></td></tr>
<tr><td><code><i>  1149</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  1150</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBPacketDisable&nbsp ==&nbsp 1)</code></td></tr>
<tr><td><code><i>  1151</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1152</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp //The&nbsp PKTDIS&nbsp bit&nbsp is&nbsp currently&nbsp set&nbsp right&nbsp now.&nbsp&nbsp It&nbsp is&nbsp therefore&nbsp "safe"</code></td></tr>
<tr><td><code><i>  1153</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp //to&nbsp mess&nbsp with&nbsp the&nbsp BDT&nbsp right&nbsp now.</code></td></tr>
<tr><td><code><i>  1154</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp pBDTEntryIn[endpoint]-&rsaquo  Val&nbsp &=&nbsp _DTSMASK;&nbsp&nbsp&nbsp&nbsp //Makes&nbsp UOWN&nbsp =&nbsp 0&nbsp (_UCPU&nbsp mode).&nbsp&nbsp Deactivates&nbsp endpoint.&nbsp&nbsp Only&nbsp sends&nbsp NAKs.</code></td></tr>
<tr><td><code><i>  1155</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp pBDTEntryIn[endpoint]-&rsaquo  Val&nbsp ^=&nbsp _DTSMASK;&nbsp&nbsp&nbsp&nbsp //Toggle&nbsp the&nbsp DTS&nbsp bit.&nbsp&nbsp This&nbsp packet&nbsp didn't&nbsp get&nbsp sent&nbsp yet,&nbsp and&nbsp the&nbsp next&nbsp call&nbsp to&nbsp USBTransferOnePacket()&nbsp will&nbsp re-toggle&nbsp the&nbsp DTS&nbsp bit&nbsp back&nbsp to&nbsp the&nbsp original&nbsp (correct)&nbsp value.</code></td></tr>
<tr><td><code><i>  1156</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1157</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp //Need&nbsp to&nbsp do&nbsp additional&nbsp handling&nbsp if&nbsp ping-pong&nbsp buffering&nbsp is&nbsp being&nbsp used</code></td></tr>
<tr><td><code><i>  1158</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp ((USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__FULL_PING_PONG)&nbsp ||&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__ALL_BUT_EP0))</code></td></tr>
<tr><td><code><i>  1159</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Point&nbsp to&nbsp the&nbsp next&nbsp buffer&nbsp for&nbsp ping&nbsp pong&nbsp purposes.&nbsp&nbsp UOWN&nbsp getting&nbsp cleared</code></td></tr>
<tr><td><code><i>  1160</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //(either&nbsp due&nbsp to&nbsp SIE&nbsp clearing&nbsp it&nbsp after&nbsp a&nbsp transaction,&nbsp or&nbsp the&nbsp firmware</code></td></tr>
<tr><td><code><i>  1161</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //clearing&nbsp it)&nbsp makes&nbsp hardware&nbsp ping&nbsp pong&nbsp pointer&nbsp advance.</code></td></tr>
<tr><td><code><i>  1162</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBAdvancePingPongBuffer(&pBDTEntryIn[endpoint]);&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1163</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1164</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp pBDTEntryIn[endpoint]-&rsaquo  STAT.Val&nbsp &=&nbsp _DTSMASK;</code></td></tr>
<tr><td><code><i>  1165</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp pBDTEntryIn[endpoint]-&rsaquo  STAT.Val&nbsp ^=&nbsp _DTSMASK;</code></td></tr>
<tr><td><code><i>  1166</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  1167</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1168</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>  1169</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1170</i> </code></td><td><code>&nbsp /**************************************************************************</code></td></tr>
<tr><td><code><i>  1171</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>  1172</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBDeviceDetach(void)</code></td></tr>
<tr><td><code><i>  1173</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1174</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>  1175</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp configures&nbsp the&nbsp USB&nbsp module&nbsp to&nbsp "soft&nbsp detach"&nbsp itself&nbsp from</code></td></tr>
<tr><td><code><i>  1176</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp USB&nbsp host.</code></td></tr>
<tr><td><code><i>  1177</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1178</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>  1179</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp configures&nbsp the&nbsp USB&nbsp module&nbsp to&nbsp perform&nbsp a&nbsp "soft&nbsp detach"</code></td></tr>
<tr><td><code><i>  1180</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp operation,&nbsp by&nbsp disabling&nbsp the&nbsp D+&nbsp (or&nbsp D-)&nbsp ~1.5k&nbsp pull&nbsp up&nbsp resistor,&nbsp which</code></td></tr>
<tr><td><code><i>  1181</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp lets&nbsp the&nbsp host&nbsp know&nbsp the&nbsp device&nbsp is&nbsp present&nbsp and&nbsp attached.&nbsp&nbsp This&nbsp will&nbsp make</code></td></tr>
<tr><td><code><i>  1182</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp host&nbsp think&nbsp that&nbsp the&nbsp device&nbsp has&nbsp been&nbsp unplugged.&nbsp&nbsp This&nbsp is&nbsp potentially</code></td></tr>
<tr><td><code><i>  1183</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp useful,&nbsp as&nbsp it&nbsp allows&nbsp the&nbsp USB&nbsp device&nbsp to&nbsp force&nbsp the&nbsp host&nbsp to&nbsp re-enumerate</code></td></tr>
<tr><td><code><i>  1184</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp device&nbsp (on&nbsp the&nbsp firmware&nbsp has&nbsp re-enabled&nbsp the&nbsp USB&nbsp module/pull&nbsp up,&nbsp by</code></td></tr>
<tr><td><code><i>  1185</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp calling&nbsp USBDeviceAttach(),&nbsp to&nbsp "soft&nbsp re-attach"&nbsp to&nbsp the&nbsp host).</code></td></tr>
<tr><td><code><i>  1186</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1187</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Precondition:</code></td></tr>
<tr><td><code><i>  1188</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Should&nbsp only&nbsp be&nbsp called&nbsp when&nbsp USB_INTERRUPT&nbsp is&nbsp defined.&nbsp&nbsp See&nbsp remarks</code></td></tr>
<tr><td><code><i>  1189</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp section&nbsp if&nbsp USB_POLLING&nbsp mode&nbsp option&nbsp is&nbsp being&nbsp used&nbsp (usb_config.h&nbsp option).</code></td></tr>
<tr><td><code><i>  1190</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1191</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Additionally,&nbsp this&nbsp function&nbsp should&nbsp only&nbsp be&nbsp called&nbsp from&nbsp the&nbsp main()&nbsp loop&nbsp </code></td></tr>
<tr><td><code><i>  1192</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp context.&nbsp&nbsp Do&nbsp not&nbsp call&nbsp this&nbsp function&nbsp from&nbsp within&nbsp an&nbsp interrupt&nbsp handler,&nbsp as&nbsp </code></td></tr>
<tr><td><code><i>  1193</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp this&nbsp function&nbsp may&nbsp modify&nbsp global&nbsp interrupt&nbsp enable&nbsp bits&nbsp and&nbsp settings.</code></td></tr>
<tr><td><code><i>  1194</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1195</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Parameters:</code></td></tr>
<tr><td><code><i>  1196</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1197</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1198</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Return&nbsp Values:</code></td></tr>
<tr><td><code><i>  1199</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1200</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1201</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>  1202</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp If&nbsp the&nbsp application&nbsp firmware&nbsp calls&nbsp USBDeviceDetach(),&nbsp it&nbsp is&nbsp strongly</code></td></tr>
<tr><td><code><i>  1203</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp recommended&nbsp that&nbsp the&nbsp firmware&nbsp wait&nbsp at&nbsp least&nbsp&rsaquo  =&nbsp 80ms&nbsp before&nbsp calling</code></td></tr>
<tr><td><code><i>  1204</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceAttach().&nbsp&nbsp If&nbsp the&nbsp firmeware&nbsp performs&nbsp a&nbsp soft&nbsp detach,&nbsp and&nbsp then</code></td></tr>
<tr><td><code><i>  1205</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp re-attaches&nbsp too&nbsp soon&nbsp (ex:&nbsp after&nbsp a&nbsp few&nbsp micro&nbsp seconds&nbsp for&nbsp instance),&nbsp some</code></td></tr>
<tr><td><code><i>  1206</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp hosts&nbsp may&nbsp interpret&nbsp this&nbsp as&nbsp an&nbsp unexpected&nbsp "glitch"&nbsp rather&nbsp than&nbsp as&nbsp a</code></td></tr>
<tr><td><code><i>  1207</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp physical&nbsp removal/re-attachment&nbsp of&nbsp the&nbsp USB&nbsp device.&nbsp&nbsp In&nbsp this&nbsp case&nbsp the&nbsp host</code></td></tr>
<tr><td><code><i>  1208</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp may&nbsp simply&nbsp ignore&nbsp the&nbsp event&nbsp without&nbsp re-enumerating&nbsp the&nbsp device.&nbsp&nbsp To&nbsp </code></td></tr>
<tr><td><code><i>  1209</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ensure&nbsp that&nbsp the&nbsp host&nbsp properly&nbsp detects&nbsp and&nbsp processes&nbsp the&nbsp device&nbsp soft</code></td></tr>
<tr><td><code><i>  1210</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp detach/re-attach,&nbsp it&nbsp is&nbsp recommended&nbsp to&nbsp make&nbsp sure&nbsp the&nbsp device&nbsp remains&nbsp </code></td></tr>
<tr><td><code><i>  1211</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp detached&nbsp long&nbsp enough&nbsp to&nbsp mimic&nbsp a&nbsp real&nbsp human&nbsp controlled&nbsp USB&nbsp </code></td></tr>
<tr><td><code><i>  1212</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp unplug/re-attach&nbsp event&nbsp (ex:&nbsp after&nbsp calling&nbsp USBDeviceDetach(),&nbsp do&nbsp not</code></td></tr>
<tr><td><code><i>  1213</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp call&nbsp USBDeviceAttach()&nbsp for&nbsp at&nbsp least&nbsp 80+ms,&nbsp preferrably&nbsp longer.</code></td></tr>
<tr><td><code><i>  1214</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1215</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Neither&nbsp the&nbsp USBDeviceDetach()&nbsp or&nbsp USBDeviceAttach()&nbsp functions&nbsp are&nbsp blocking</code></td></tr>
<tr><td><code><i>  1216</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp or&nbsp take&nbsp long&nbsp to&nbsp execute.&nbsp&nbsp It&nbsp is&nbsp the&nbsp application&nbsp firmware's&nbsp </code></td></tr>
<tr><td><code><i>  1217</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp responsibility&nbsp for&nbsp adding&nbsp the&nbsp 80+ms&nbsp delay,&nbsp when&nbsp using&nbsp these&nbsp API&nbsp </code></td></tr>
<tr><td><code><i>  1218</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp functions.</code></td></tr>
<tr><td><code><i>  1219</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1220</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Note:&nbsp The&nbsp Windows&nbsp plug&nbsp and&nbsp play&nbsp event&nbsp handler&nbsp processing&nbsp is&nbsp fairly&nbsp </code></td></tr>
<tr><td><code><i>  1221</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp slow,&nbsp especially&nbsp in&nbsp certain&nbsp versions&nbsp of&nbsp Windows,&nbsp and&nbsp for&nbsp certain&nbsp USB</code></td></tr>
<tr><td><code><i>  1222</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp device&nbsp classes.&nbsp&nbsp It&nbsp has&nbsp been&nbsp observed&nbsp that&nbsp some&nbsp device&nbsp classes&nbsp need&nbsp to</code></td></tr>
<tr><td><code><i>  1223</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp provide&nbsp even&nbsp more&nbsp USB&nbsp detach&nbsp dwell&nbsp interval&nbsp (before&nbsp calling&nbsp </code></td></tr>
<tr><td><code><i>  1224</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceAttach()),&nbsp in&nbsp order&nbsp to&nbsp work&nbsp correctly&nbsp after&nbsp re-enumeration.</code></td></tr>
<tr><td><code><i>  1225</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp If&nbsp the&nbsp USB&nbsp device&nbsp is&nbsp a&nbsp CDC&nbsp class&nbsp device,&nbsp it&nbsp is&nbsp recommended&nbsp to&nbsp wait</code></td></tr>
<tr><td><code><i>  1226</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp at&nbsp least&nbsp 1.5&nbsp seconds&nbsp or&nbsp longer,&nbsp before&nbsp soft&nbsp re-attaching&nbsp to&nbsp the&nbsp host,</code></td></tr>
<tr><td><code><i>  1227</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp to&nbsp provide&nbsp the&nbsp plug&nbsp and&nbsp play&nbsp event&nbsp handler&nbsp enough&nbsp time&nbsp to&nbsp finish&nbsp </code></td></tr>
<tr><td><code><i>  1228</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp processing&nbsp the&nbsp removal&nbsp event,&nbsp before&nbsp the&nbsp re-attach&nbsp occurs.</code></td></tr>
<tr><td><code><i>  1229</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1230</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp If&nbsp the&nbsp application&nbsp is&nbsp using&nbsp the&nbsp USB_POLLING&nbsp mode&nbsp option,&nbsp then&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  1231</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceDetach()&nbsp and&nbsp USBDeviceAttach()&nbsp functions&nbsp are&nbsp not&nbsp available.&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1232</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp In&nbsp this&nbsp mode,&nbsp the&nbsp USB&nbsp stack&nbsp relies&nbsp on&nbsp the&nbsp "#define&nbsp USE_USB_BUS_SENSE_IO"&nbsp </code></td></tr>
<tr><td><code><i>  1233</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp and&nbsp "#define&nbsp USB_BUS_SENSE"&nbsp options&nbsp in&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  1234</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp HardwareProfile&nbsp –&nbsp [platform&nbsp name].h&nbsp file.&nbsp </code></td></tr>
<tr><td><code><i>  1235</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1236</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp When&nbsp using&nbsp the&nbsp USB_POLLING&nbsp mode&nbsp option,&nbsp and&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  1237</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp "#define&nbsp USE_USB_BUS_SENSE_IO"&nbsp definition&nbsp has&nbsp been&nbsp commented&nbsp out,&nbsp then&nbsp </code></td></tr>
<tr><td><code><i>  1238</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp USB&nbsp stack&nbsp assumes&nbsp that&nbsp it&nbsp should&nbsp always&nbsp enable&nbsp the&nbsp USB&nbsp module&nbsp at&nbsp </code></td></tr>
<tr><td><code><i>  1239</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pretty&nbsp much&nbsp all&nbsp times.&nbsp&nbsp Basically,&nbsp anytime&nbsp the&nbsp application&nbsp firmware&nbsp </code></td></tr>
<tr><td><code><i>  1240</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp calls&nbsp USBDeviceTasks(),&nbsp the&nbsp firmware&nbsp will&nbsp automatically&nbsp enable&nbsp the&nbsp USB&nbsp </code></td></tr>
<tr><td><code><i>  1241</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp module.&nbsp&nbsp This&nbsp mode&nbsp would&nbsp typically&nbsp be&nbsp selected&nbsp if&nbsp the&nbsp application&nbsp was&nbsp </code></td></tr>
<tr><td><code><i>  1242</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp designed&nbsp to&nbsp be&nbsp a&nbsp purely&nbsp bus&nbsp powered&nbsp device.&nbsp&nbsp In&nbsp this&nbsp case,&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  1243</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp application&nbsp is&nbsp powered&nbsp from&nbsp the&nbsp +5V&nbsp VBUS&nbsp supply&nbsp from&nbsp the&nbsp USB&nbsp port,&nbsp so&nbsp </code></td></tr>
<tr><td><code><i>  1244</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp it&nbsp is&nbsp correct&nbsp and&nbsp sensible&nbsp in&nbsp this&nbsp type&nbsp of&nbsp application&nbsp to&nbsp power&nbsp up&nbsp and&nbsp </code></td></tr>
<tr><td><code><i>  1245</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp turn&nbsp on&nbsp the&nbsp USB&nbsp module,&nbsp at&nbsp anytime&nbsp that&nbsp the&nbsp microcontroller&nbsp is&nbsp </code></td></tr>
<tr><td><code><i>  1246</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp powered&nbsp (which&nbsp implies&nbsp the&nbsp USB&nbsp cable&nbsp is&nbsp attached&nbsp and&nbsp the&nbsp host&nbsp is&nbsp also&nbsp </code></td></tr>
<tr><td><code><i>  1247</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp powered).</code></td></tr>
<tr><td><code><i>  1248</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1249</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp In&nbsp a&nbsp self&nbsp powered&nbsp application,&nbsp the&nbsp USB&nbsp stack&nbsp is&nbsp designed&nbsp with&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  1250</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp intention&nbsp that&nbsp the&nbsp user&nbsp will&nbsp enable&nbsp the&nbsp "#define&nbsp USE_USB_BUS_SENSE_IO"&nbsp </code></td></tr>
<tr><td><code><i>  1251</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp option&nbsp in&nbsp the&nbsp HardwareProfile&nbsp –&nbsp [platform&nbsp name].h&nbsp file.&nbsp&nbsp When&nbsp this&nbsp </code></td></tr>
<tr><td><code><i>  1252</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp option&nbsp is&nbsp defined,&nbsp then&nbsp the&nbsp USBDeviceTasks()&nbsp function&nbsp will&nbsp automatically&nbsp </code></td></tr>
<tr><td><code><i>  1253</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp check&nbsp the&nbsp I/O&nbsp pin&nbsp port&nbsp value&nbsp of&nbsp the&nbsp designated&nbsp pin&nbsp (based&nbsp on&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  1254</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #define&nbsp USB_BUS_SENSE&nbsp option&nbsp in&nbsp the&nbsp HardwareProfile&nbsp –&nbsp [platform&nbsp name].h&nbsp </code></td></tr>
<tr><td><code><i>  1255</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp file),&nbsp every&nbsp time&nbsp the&nbsp application&nbsp calls&nbsp USBDeviceTasks().&nbsp&nbsp If&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  1256</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceTasks()&nbsp function&nbsp is&nbsp executed&nbsp and&nbsp finds&nbsp that&nbsp the&nbsp pin&nbsp defined&nbsp by&nbsp </code></td></tr>
<tr><td><code><i>  1257</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp #define&nbsp USB_BUS_SENSE&nbsp is&nbsp in&nbsp a&nbsp logic&nbsp low&nbsp state,&nbsp then&nbsp it&nbsp will&nbsp </code></td></tr>
<tr><td><code><i>  1258</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp automatically&nbsp disable&nbsp the&nbsp USB&nbsp module&nbsp and&nbsp tri-state&nbsp the&nbsp D+&nbsp and&nbsp D-&nbsp pins.&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1259</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp If&nbsp however&nbsp the&nbsp USBDeviceTasks()&nbsp function&nbsp is&nbsp executed&nbsp and&nbsp finds&nbsp the&nbsp pin&nbsp </code></td></tr>
<tr><td><code><i>  1260</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp defined&nbsp by&nbsp the&nbsp #define&nbsp USB_BUS_SENSE&nbsp is&nbsp in&nbsp a&nbsp logic&nbsp high&nbsp state,&nbsp then&nbsp it&nbsp </code></td></tr>
<tr><td><code><i>  1261</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp will&nbsp automatically&nbsp enable&nbsp the&nbsp USB&nbsp module,&nbsp if&nbsp it&nbsp has&nbsp not&nbsp already&nbsp been&nbsp </code></td></tr>
<tr><td><code><i>  1262</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp enabled.&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1263</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1264</i> </code></td><td><code>&nbsp &nbsp&nbsp **************************************************************************/</code></td></tr>
<tr><td><code><i>  1265</i> </code></td><td><code>&nbsp #if&nbsp defined(USB_INTERRUPT)</code></td></tr>
<tr><td><code><i>  1266</i> </code></td><td><code>&nbsp void&nbsp USBDeviceDetach(void)</code></td></tr>
<tr><td><code><i>  1267</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  1268</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //If&nbsp the&nbsp interrupt&nbsp option&nbsp is&nbsp selected&nbsp then&nbsp the&nbsp customer&nbsp is&nbsp required</code></td></tr>
<tr><td><code><i>  1269</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp to&nbsp notify&nbsp the&nbsp stack&nbsp when&nbsp the&nbsp device&nbsp is&nbsp attached&nbsp or&nbsp removed&nbsp from&nbsp the</code></td></tr>
<tr><td><code><i>  1270</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp bus&nbsp by&nbsp calling&nbsp the&nbsp USBDeviceAttach()&nbsp and&nbsp USBDeviceDetach()&nbsp functions.</code></td></tr>
<tr><td><code><i>  1271</i> </code></td><td><code>&nbsp #ifdef&nbsp USB_SUPPORT_OTG</code></td></tr>
<tr><td><code><i>  1272</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if&nbsp (USB_BUS_SENSE&nbsp !=&nbsp 1)</code></td></tr>
<tr><td><code><i>  1273</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>  1274</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1275</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Disable&nbsp module&nbsp &&nbsp detach&nbsp from&nbsp bus</code></td></tr>
<tr><td><code><i>  1276</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1CON&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1277</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1278</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Mask&nbsp all&nbsp USB&nbsp interrupts&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1279</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1IE&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1280</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1281</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Move&nbsp to&nbsp the&nbsp detached&nbsp state&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1282</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceState&nbsp =&nbsp DETACHED_STATE;</code></td></tr>
<tr><td><code><i>  1283</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1284</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #ifdef&nbsp&nbsp USB_SUPPORT_OTG&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1285</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Disable&nbsp D+&nbsp Pullup</code></td></tr>
<tr><td><code><i>  1286</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1OTGCONbits.DPPULUP&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  1287</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1288</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Disable&nbsp HNP</code></td></tr>
<tr><td><code><i>  1289</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGDisableHnp();</code></td></tr>
<tr><td><code><i>  1290</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1291</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Deactivate&nbsp HNP</code></td></tr>
<tr><td><code><i>  1292</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGDeactivateHnp();</code></td></tr>
<tr><td><code><i>  1293</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1294</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //If&nbsp ID&nbsp Pin&nbsp Changed&nbsp State</code></td></tr>
<tr><td><code><i>  1295</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if&nbsp (USBIDIF&nbsp &&&nbsp USBIDIE)</code></td></tr>
<tr><td><code><i>  1296</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1297</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Re-detect&nbsp &&nbsp Initialize</code></td></tr>
<tr><td><code><i>  1298</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGInitialize();</code></td></tr>
<tr><td><code><i>  1299</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1300</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Clear&nbsp ID&nbsp Interrupt&nbsp Flag</code></td></tr>
<tr><td><code><i>  1301</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);</code></td></tr>
<tr><td><code><i>  1302</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1303</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  1304</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1305</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined&nbsp __C30__&nbsp ||&nbsp defined&nbsp __XC16__</code></td></tr>
<tr><td><code><i>  1306</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //USBClearInterruptFlag(U1OTGIR,&nbsp 3);&nbsp </code></td></tr>
<tr><td><code><i>  1307</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  1308</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //return&nbsp so&nbsp that&nbsp we&nbsp don't&nbsp go&nbsp through&nbsp the&nbsp rest&nbsp of&nbsp </code></td></tr>
<tr><td><code><i>  1309</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //the&nbsp state&nbsp machine</code></td></tr>
<tr><td><code><i>  1310</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return;</code></td></tr>
<tr><td><code><i>  1311</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1312</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1313</i> </code></td><td><code>&nbsp #ifdef&nbsp USB_SUPPORT_OTG</code></td></tr>
<tr><td><code><i>  1314</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //If&nbsp Session&nbsp Is&nbsp Started&nbsp Then</code></td></tr>
<tr><td><code><i>  1315</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  1316</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1317</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //If&nbsp SRP&nbsp Is&nbsp Ready</code></td></tr>
<tr><td><code><i>  1318</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if&nbsp (USBOTGSRPIsReady())</code></td></tr>
<tr><td><code><i>  1319</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1320</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Clear&nbsp SRPReady</code></td></tr>
<tr><td><code><i>  1321</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGClearSRPReady();</code></td></tr>
<tr><td><code><i>  1322</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1323</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Clear&nbsp SRP&nbsp Timeout&nbsp Flag</code></td></tr>
<tr><td><code><i>  1324</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGClearSRPTimeOutFlag();</code></td></tr>
<tr><td><code><i>  1325</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1326</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Indicate&nbsp Session&nbsp Started</code></td></tr>
<tr><td><code><i>  1327</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UART2PrintString(&nbsp "\r\n*****&nbsp USB&nbsp OTG&nbsp B&nbsp Event&nbsp -&nbsp Session&nbsp Started&nbsp&nbsp *****\r\n"&nbsp );</code></td></tr>
<tr><td><code><i>  1328</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1329</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1330</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>  1331</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>  1332</i> </code></td><td><code>&nbsp #endif&nbsp&nbsp //#if&nbsp defined(USB_INTERRUPT)</code></td></tr>
<tr><td><code><i>  1333</i> </code></td><td><code>&nbsp /**************************************************************************</code></td></tr>
<tr><td><code><i>  1334</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>  1335</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBDeviceAttach(void)</code></td></tr>
<tr><td><code><i>  1336</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1337</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>  1338</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Checks&nbsp if&nbsp VBUS&nbsp is&nbsp present,&nbsp and&nbsp that&nbsp the&nbsp USB&nbsp module&nbsp is&nbsp not&nbsp already&nbsp </code></td></tr>
<tr><td><code><i>  1339</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp initalized,&nbsp and&nbsp if&nbsp so,&nbsp enables&nbsp the&nbsp USB&nbsp module&nbsp so&nbsp as&nbsp to&nbsp signal&nbsp device&nbsp </code></td></tr>
<tr><td><code><i>  1340</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp attachment&nbsp to&nbsp the&nbsp USB&nbsp host.&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1341</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1342</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>  1343</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp indicates&nbsp to&nbsp the&nbsp USB&nbsp host&nbsp that&nbsp the&nbsp USB&nbsp device&nbsp has&nbsp been</code></td></tr>
<tr><td><code><i>  1344</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp attached&nbsp to&nbsp the&nbsp bus.&nbsp&nbsp This&nbsp function&nbsp needs&nbsp to&nbsp be&nbsp called&nbsp in&nbsp order&nbsp for&nbsp the</code></td></tr>
<tr><td><code><i>  1345</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp device&nbsp to&nbsp start&nbsp to&nbsp enumerate&nbsp on&nbsp the&nbsp bus.</code></td></tr>
<tr><td><code><i>  1346</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1347</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Precondition:</code></td></tr>
<tr><td><code><i>  1348</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Should&nbsp only&nbsp be&nbsp called&nbsp when&nbsp USB_INTERRUPT&nbsp is&nbsp defined.&nbsp&nbsp Also,&nbsp should&nbsp only&nbsp </code></td></tr>
<tr><td><code><i>  1349</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp be&nbsp called&nbsp from&nbsp the&nbsp main()&nbsp loop&nbsp context.&nbsp&nbsp Do&nbsp not&nbsp call&nbsp USBDeviceAttach()</code></td></tr>
<tr><td><code><i>  1350</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp from&nbsp within&nbsp an&nbsp interrupt&nbsp handler,&nbsp as&nbsp the&nbsp USBDeviceAttach()&nbsp function</code></td></tr>
<tr><td><code><i>  1351</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp may&nbsp modify&nbsp global&nbsp interrupt&nbsp enable&nbsp bits&nbsp and&nbsp settings.</code></td></tr>
<tr><td><code><i>  1352</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1353</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp For&nbsp normal&nbsp USB&nbsp devices:</code></td></tr>
<tr><td><code><i>  1354</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Make&nbsp sure&nbsp that&nbsp if&nbsp the&nbsp module&nbsp was&nbsp previously&nbsp on,&nbsp that&nbsp it&nbsp has&nbsp been&nbsp turned&nbsp off&nbsp </code></td></tr>
<tr><td><code><i>  1355</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp for&nbsp a&nbsp long&nbsp time&nbsp (ex:&nbsp 100ms+)&nbsp before&nbsp calling&nbsp this&nbsp function&nbsp to&nbsp re-enable&nbsp the&nbsp module.</code></td></tr>
<tr><td><code><i>  1356</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp If&nbsp the&nbsp device&nbsp turns&nbsp off&nbsp the&nbsp D+&nbsp (for&nbsp full&nbsp speed)&nbsp or&nbsp D-&nbsp (for&nbsp low&nbsp speed)&nbsp ~1.5k&nbsp ohm</code></td></tr>
<tr><td><code><i>  1357</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pull&nbsp up&nbsp resistor,&nbsp and&nbsp then&nbsp turns&nbsp it&nbsp back&nbsp on&nbsp very&nbsp quickly,&nbsp common&nbsp hosts&nbsp will&nbsp sometimes&nbsp </code></td></tr>
<tr><td><code><i>  1358</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp reject&nbsp this&nbsp event,&nbsp since&nbsp no&nbsp human&nbsp could&nbsp ever&nbsp unplug&nbsp and&nbsp reattach&nbsp a&nbsp USB&nbsp device&nbsp in&nbsp a&nbsp </code></td></tr>
<tr><td><code><i>  1359</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp microseconds&nbsp (or&nbsp nanoseconds)&nbsp timescale.&nbsp&nbsp The&nbsp host&nbsp could&nbsp simply&nbsp treat&nbsp this&nbsp as&nbsp some&nbsp kind&nbsp </code></td></tr>
<tr><td><code><i>  1360</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp of&nbsp glitch&nbsp and&nbsp ignore&nbsp the&nbsp event&nbsp altogether.&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1361</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Parameters:</code></td></tr>
<tr><td><code><i>  1362</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1363</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1364</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Return&nbsp Values:</code></td></tr>
<tr><td><code><i>  1365</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1366</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1367</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Remarks:&nbsp </code></td></tr>
<tr><td><code><i>  1368</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp See&nbsp also&nbsp the&nbsp USBDeviceDetach()&nbsp API&nbsp function&nbsp documentation.&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1369</i> </code></td><td><code>&nbsp ****************************************************************************/</code></td></tr>
<tr><td><code><i>  1370</i> </code></td><td><code>&nbsp #if&nbsp defined(USB_INTERRUPT)</code></td></tr>
<tr><td><code><i>  1371</i> </code></td><td><code>&nbsp void&nbsp USBDeviceAttach(void)</code></td></tr>
<tr><td><code><i>  1372</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  1373</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //if&nbsp we&nbsp are&nbsp in&nbsp the&nbsp detached&nbsp state</code></td></tr>
<tr><td><code><i>  1374</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBDeviceState&nbsp ==&nbsp DETACHED_STATE)</code></td></tr>
<tr><td><code><i>  1375</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1376</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USB_BUS_SENSE&nbsp ==&nbsp 1)</code></td></tr>
<tr><td><code><i>  1377</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1378</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp //Initialize&nbsp registers&nbsp to&nbsp known&nbsp states.</code></td></tr>
<tr><td><code><i>  1379</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1CON&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1380</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1381</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Mask&nbsp all&nbsp USB&nbsp interrupts</code></td></tr>
<tr><td><code><i>  1382</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1IE&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1383</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1384</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Configure&nbsp things&nbsp like:&nbsp pull&nbsp ups,&nbsp full/low-speed&nbsp mode,&nbsp </code></td></tr>
<tr><td><code><i>  1385</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //set&nbsp the&nbsp ping&nbsp pong&nbsp mode,&nbsp and&nbsp set&nbsp internal&nbsp transceiver</code></td></tr>
<tr><td><code><i>  1386</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SetConfigurationOptions();</code></td></tr>
<tr><td><code><i>  1387</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1388</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBEnableInterrupts();&nbsp&nbsp //Modifies&nbsp global&nbsp interrupt&nbsp settings</code></td></tr>
<tr><td><code><i>  1389</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1390</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Enable&nbsp module&nbsp &&nbsp attach&nbsp to&nbsp bus</code></td></tr>
<tr><td><code><i>  1391</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp while(!U1CONbits.USBEN){U1CONbits.USBEN&nbsp =&nbsp 1;}</code></td></tr>
<tr><td><code><i>  1392</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1393</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //moved&nbsp to&nbsp the&nbsp attached&nbsp state</code></td></tr>
<tr><td><code><i>  1394</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceState&nbsp =&nbsp ATTACHED_STATE;</code></td></tr>
<tr><td><code><i>  1395</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1396</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #ifdef&nbsp&nbsp USB_SUPPORT_OTG</code></td></tr>
<tr><td><code><i>  1397</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1OTGCON&nbsp =&nbsp USB_OTG_DPLUS_ENABLE&nbsp |&nbsp USB_OTG_ENABLE;&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1398</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  1399</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1400</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1401</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>  1402</i> </code></td><td><code>&nbsp #endif&nbsp&nbsp //#if&nbsp defined(USB_INTERRUPT)</code></td></tr>
<tr><td><code><i>  1403</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1404</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1405</i> </code></td><td><code>&nbsp /*******************************************************************************</code></td></tr>
<tr><td><code><i>  1406</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:&nbsp void&nbsp USBCtrlEPAllowStatusStage(void);</code></td></tr>
<tr><td><code><i>  1407</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1408</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:&nbsp This&nbsp function&nbsp prepares&nbsp the&nbsp proper&nbsp endpoint&nbsp 0&nbsp IN&nbsp or&nbsp endpoint&nbsp 0&nbsp OUT</code></td></tr>
<tr><td><code><i>  1409</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (based&nbsp on&nbsp the&nbsp controlTransferState)&nbsp to&nbsp allow&nbsp the&nbsp status&nbsp stage&nbsp packet</code></td></tr>
<tr><td><code><i>  1410</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp of&nbsp a&nbsp control&nbsp transfer&nbsp to&nbsp complete.&nbsp&nbsp This&nbsp function&nbsp gets&nbsp used</code></td></tr>
<tr><td><code><i>  1411</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp internally&nbsp by&nbsp the&nbsp USB&nbsp stack&nbsp itself,&nbsp but&nbsp it&nbsp may&nbsp also&nbsp be&nbsp called&nbsp from</code></td></tr>
<tr><td><code><i>  1412</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp application&nbsp firmware,&nbsp IF&nbsp the&nbsp application&nbsp firmware&nbsp called</code></td></tr>
<tr><td><code><i>  1413</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp USBDeferStatusStage()&nbsp function&nbsp during&nbsp the&nbsp initial&nbsp processing</code></td></tr>
<tr><td><code><i>  1414</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp of&nbsp the&nbsp control&nbsp transfer&nbsp request.&nbsp&nbsp In&nbsp this&nbsp case,&nbsp the&nbsp application</code></td></tr>
<tr><td><code><i>  1415</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp must&nbsp call&nbsp the&nbsp USBCtrlEPAllowStatusStage()&nbsp once,&nbsp after&nbsp it&nbsp has&nbsp fully</code></td></tr>
<tr><td><code><i>  1416</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp completed&nbsp processing&nbsp and&nbsp handling&nbsp the&nbsp data&nbsp stage&nbsp portion&nbsp of&nbsp the</code></td></tr>
<tr><td><code><i>  1417</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp request.</code></td></tr>
<tr><td><code><i>  1418</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1419</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp If&nbsp the&nbsp application&nbsp firmware&nbsp has&nbsp no&nbsp need&nbsp for&nbsp delaying&nbsp control</code></td></tr>
<tr><td><code><i>  1420</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp transfers,&nbsp and&nbsp therefore&nbsp never&nbsp calls&nbsp USBDeferStatusStage(),&nbsp then&nbsp the</code></td></tr>
<tr><td><code><i>  1421</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp application&nbsp firmware&nbsp should&nbsp not&nbsp call&nbsp USBCtrlEPAllowStatusStage().</code></td></tr>
<tr><td><code><i>  1422</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1423</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>  1424</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1425</i> </code></td><td><code>&nbsp &nbsp&nbsp Conditions:</code></td></tr>
<tr><td><code><i>  1426</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1427</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1428</i> </code></td><td><code>&nbsp &nbsp&nbsp Input:</code></td></tr>
<tr><td><code><i>  1429</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1430</i> </code></td><td><code>&nbsp &nbsp&nbsp Return:</code></td></tr>
<tr><td><code><i>  1431</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1432</i> </code></td><td><code>&nbsp &nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>  1433</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1434</i> </code></td><td><code>&nbsp &nbsp&nbsp *****************************************************************************/</code></td></tr>
<tr><td><code><i>  1435</i> </code></td><td><code>&nbsp void&nbsp USBCtrlEPAllowStatusStage(void)</code></td></tr>
<tr><td><code><i>  1436</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  1437</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Check&nbsp and&nbsp set&nbsp two&nbsp flags,&nbsp prior&nbsp to&nbsp actually&nbsp modifying&nbsp any&nbsp BDT&nbsp entries.</code></td></tr>
<tr><td><code><i>  1438</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //This&nbsp double&nbsp checking&nbsp is&nbsp necessary&nbsp to&nbsp make&nbsp certain&nbsp that&nbsp </code></td></tr>
<tr><td><code><i>  1439</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //USBCtrlEPAllowStatusStage()&nbsp can&nbsp be&nbsp called&nbsp twice&nbsp simultaneously&nbsp (ex:&nbsp once&nbsp </code></td></tr>
<tr><td><code><i>  1440</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //in&nbsp main&nbsp loop&nbsp context,&nbsp while&nbsp simultaneously&nbsp getting&nbsp an&nbsp interrupt&nbsp which&nbsp </code></td></tr>
<tr><td><code><i>  1441</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //tries&nbsp to&nbsp call&nbsp USBCtrlEPAllowStatusStage()&nbsp again,&nbsp at&nbsp the&nbsp same&nbsp time).</code></td></tr>
<tr><td><code><i>  1442</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBStatusStageEnabledFlag1&nbsp ==&nbsp false)</code></td></tr>
<tr><td><code><i>  1443</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1444</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStatusStageEnabledFlag1&nbsp =&nbsp true;</code></td></tr>
<tr><td><code><i>  1445</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBStatusStageEnabledFlag2&nbsp ==&nbsp false)</code></td></tr>
<tr><td><code><i>  1446</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1447</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStatusStageEnabledFlag2&nbsp =&nbsp true;</code></td></tr>
<tr><td><code><i>  1448</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1449</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Determine&nbsp which&nbsp endpoints&nbsp (EP0&nbsp IN&nbsp or&nbsp OUT&nbsp needs&nbsp arming&nbsp for&nbsp the&nbsp status</code></td></tr>
<tr><td><code><i>  1450</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //stage),&nbsp based&nbsp on&nbsp the&nbsp type&nbsp of&nbsp control&nbsp transfer&nbsp currently&nbsp pending.</code></td></tr>
<tr><td><code><i>  1451</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(controlTransferState&nbsp ==&nbsp CTRL_TRF_RX)</code></td></tr>
<tr><td><code><i>  1452</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1453</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  CNT&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  1454</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp =&nbsp _DAT1|(_DTSEN&nbsp &&nbsp _DTS_CHECKING_ENABLED);&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1455</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1456</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1457</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else&nbsp if(controlTransferState&nbsp ==&nbsp CTRL_TRF_TX)</code></td></tr>
<tr><td><code><i>  1458</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1459</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BothEP0OutUOWNsSet&nbsp =&nbsp false;&nbsp&nbsp&nbsp&nbsp //Indicator&nbsp flag&nbsp used&nbsp in&nbsp USBCtrlTrfOutHandler()</code></td></tr>
<tr><td><code><i>  1460</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1461</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //This&nbsp buffer&nbsp (when&nbsp ping&nbsp pong&nbsp buffering&nbsp is&nbsp enabled&nbsp on&nbsp EP0&nbsp OUT)&nbsp receives&nbsp the</code></td></tr>
<tr><td><code><i>  1462</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //next&nbsp SETUP&nbsp packet.</code></td></tr>
<tr><td><code><i>  1463</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if((USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__EP0_OUT_ONLY)&nbsp ||&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__FULL_PING_PONG))</code></td></tr>
<tr><td><code><i>  1464</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutCurrent-&rsaquo  CNT&nbsp =&nbsp USB_EP0_BUFF_SIZE;</code></td></tr>
<tr><td><code><i>  1465</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutCurrent-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(&SetupPkt);</code></td></tr>
<tr><td><code><i>  1466</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutCurrent-&rsaquo  STAT.Val&nbsp =&nbsp _BSTALL;&nbsp //Prepare&nbsp endpoint&nbsp to&nbsp accept&nbsp a&nbsp SETUP&nbsp transaction</code></td></tr>
<tr><td><code><i>  1467</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutCurrent-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1468</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BothEP0OutUOWNsSet&nbsp =&nbsp true;&nbsp //Indicator&nbsp flag&nbsp used&nbsp in&nbsp USBCtrlTrfOutHandler()</code></td></tr>
<tr><td><code><i>  1469</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  1470</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1471</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //This&nbsp EP0&nbsp OUT&nbsp buffer&nbsp receives&nbsp the&nbsp 0-byte&nbsp OUT&nbsp status&nbsp stage&nbsp packet.</code></td></tr>
<tr><td><code><i>  1472</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  CNT&nbsp =&nbsp USB_EP0_BUFF_SIZE;</code></td></tr>
<tr><td><code><i>  1473</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(&SetupPkt);</code></td></tr>
<tr><td><code><i>  1474</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp =&nbsp _USIE;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Note:&nbsp DTSEN&nbsp is&nbsp 0</code></td></tr>
<tr><td><code><i>  1475</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1476</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1477</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1478</i> </code></td><td><code>&nbsp }&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1479</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1480</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1481</i> </code></td><td><code>&nbsp /*******************************************************************************</code></td></tr>
<tr><td><code><i>  1482</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:&nbsp void&nbsp USBCtrlEPAllowDataStage(void);</code></td></tr>
<tr><td><code><i>  1483</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1484</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:&nbsp This&nbsp function&nbsp allows&nbsp the&nbsp data&nbsp stage&nbsp of&nbsp either&nbsp a&nbsp host-to-device&nbsp or</code></td></tr>
<tr><td><code><i>  1485</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp device-to-host&nbsp control&nbsp transfer&nbsp (with&nbsp data&nbsp stage)&nbsp to&nbsp complete.</code></td></tr>
<tr><td><code><i>  1486</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp is&nbsp meant&nbsp to&nbsp be&nbsp used&nbsp in&nbsp conjunction&nbsp with&nbsp either&nbsp the</code></td></tr>
<tr><td><code><i>  1487</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeferOUTDataStage()&nbsp or&nbsp USBDeferINDataStage().&nbsp&nbsp If&nbsp the&nbsp firmware</code></td></tr>
<tr><td><code><i>  1488</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp does&nbsp not&nbsp call&nbsp either&nbsp USBDeferOUTDataStage()&nbsp or&nbsp USBDeferINDataStage(),</code></td></tr>
<tr><td><code><i>  1489</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp then&nbsp the&nbsp firmware&nbsp does&nbsp not&nbsp need&nbsp to&nbsp manually&nbsp call&nbsp </code></td></tr>
<tr><td><code><i>  1490</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlEPAllowDataStage(),&nbsp as&nbsp the&nbsp USB&nbsp stack&nbsp will&nbsp call&nbsp this&nbsp function</code></td></tr>
<tr><td><code><i>  1491</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp instead.</code></td></tr>
<tr><td><code><i>  1492</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1493</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>  1494</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1495</i> </code></td><td><code>&nbsp &nbsp&nbsp Conditions:&nbsp A&nbsp control&nbsp transfer&nbsp (with&nbsp data&nbsp stage)&nbsp should&nbsp already&nbsp be&nbsp pending,&nbsp </code></td></tr>
<tr><td><code><i>  1496</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if&nbsp the&nbsp firmware&nbsp calls&nbsp this&nbsp function.&nbsp&nbsp Additionally,&nbsp the&nbsp firmware</code></td></tr>
<tr><td><code><i>  1497</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp should&nbsp have&nbsp called&nbsp either&nbsp USBDeferOUTDataStage()&nbsp or&nbsp </code></td></tr>
<tr><td><code><i>  1498</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeferINDataStage()&nbsp at&nbsp the&nbsp start&nbsp of&nbsp the&nbsp control&nbsp transfer,&nbsp if</code></td></tr>
<tr><td><code><i>  1499</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp firmware&nbsp will&nbsp be&nbsp calling&nbsp this&nbsp function&nbsp manually.</code></td></tr>
<tr><td><code><i>  1500</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1501</i> </code></td><td><code>&nbsp &nbsp&nbsp Input:</code></td></tr>
<tr><td><code><i>  1502</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1503</i> </code></td><td><code>&nbsp &nbsp&nbsp Return:</code></td></tr>
<tr><td><code><i>  1504</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1505</i> </code></td><td><code>&nbsp &nbsp&nbsp Remarks:&nbsp </code></td></tr>
<tr><td><code><i>  1506</i> </code></td><td><code>&nbsp &nbsp&nbsp *****************************************************************************/</code></td></tr>
<tr><td><code><i>  1507</i> </code></td><td><code>&nbsp void&nbsp USBCtrlEPAllowDataStage(void)</code></td></tr>
<tr><td><code><i>  1508</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  1509</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeferINDataStagePackets&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  1510</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeferOUTDataStagePackets&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  1511</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1512</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(controlTransferState&nbsp ==&nbsp CTRL_TRF_RX)&nbsp //(&lsaquo  setup&rsaquo &lsaquo  out&rsaquo &lsaquo  out&rsaquo  ...&lsaquo  out&rsaquo &lsaquo  in&rsaquo  )</code></td></tr>
<tr><td><code><i>  1513</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1514</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Prepare&nbsp EP0&nbsp OUT&nbsp to&nbsp receive&nbsp the&nbsp first&nbsp OUT&nbsp data&nbsp packet&nbsp in&nbsp the&nbsp data&nbsp stage&nbsp sequence.</code></td></tr>
<tr><td><code><i>  1515</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  CNT&nbsp =&nbsp USB_EP0_BUFF_SIZE;</code></td></tr>
<tr><td><code><i>  1516</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(&CtrlTrfData);</code></td></tr>
<tr><td><code><i>  1517</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp =&nbsp _DAT1|(_DTSEN&nbsp &&nbsp _DTS_CHECKING_ENABLED);</code></td></tr>
<tr><td><code><i>  1518</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1519</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1520</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else&nbsp&nbsp&nbsp&nbsp //else&nbsp must&nbsp be&nbsp controlTransferState&nbsp ==&nbsp CTRL_TRF_TX&nbsp (&lsaquo  setup&rsaquo &lsaquo  in&rsaquo &lsaquo  in&rsaquo  ...&lsaquo  in&rsaquo &lsaquo  out&rsaquo  )</code></td></tr>
<tr><td><code><i>  1521</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1522</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Error&nbsp check&nbsp the&nbsp data&nbsp stage&nbsp byte&nbsp count.&nbsp&nbsp Make&nbsp sure&nbsp the&nbsp user&nbsp specified</code></td></tr>
<tr><td><code><i>  1523</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //value&nbsp was&nbsp no&nbsp greater&nbsp than&nbsp the&nbsp number&nbsp of&nbsp bytes&nbsp the&nbsp host&nbsp requested.</code></td></tr>
<tr><td><code><i>  1524</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.wLength&nbsp&lsaquo &nbsp inPipes[0].wCount.Val)</code></td></tr>
<tr><td><code><i>  1525</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1526</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].wCount.Val&nbsp =&nbsp SetupPkt.wLength;</code></td></tr>
<tr><td><code><i>  1527</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1528</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlTrfTxService();&nbsp&nbsp //Copies&nbsp one&nbsp IN&nbsp data&nbsp packet&nbsp worth&nbsp of&nbsp data&nbsp from&nbsp application&nbsp buffer</code></td></tr>
<tr><td><code><i>  1529</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //to&nbsp CtrlTrfData&nbsp buffer.&nbsp&nbsp Also&nbsp keeps&nbsp track&nbsp of&nbsp how&nbsp many&nbsp bytes&nbsp remaining.</code></td></tr>
<tr><td><code><i>  1530</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1531</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp //Cnt&nbsp should&nbsp have&nbsp been&nbsp initialized&nbsp by&nbsp responsible&nbsp request&nbsp owner&nbsp (ex:&nbsp by</code></td></tr>
<tr><td><code><i>  1532</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp //using&nbsp the&nbsp USBEP0SendRAMPtr()&nbsp or&nbsp USBEP0SendROMPtr()&nbsp API&nbsp function).</code></td></tr>
<tr><td><code><i>  1533</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(&CtrlTrfData);</code></td></tr>
<tr><td><code><i>  1534</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp =&nbsp _DAT1|(_DTSEN&nbsp &&nbsp _DTS_CHECKING_ENABLED);</code></td></tr>
<tr><td><code><i>  1535</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1536</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1537</i> </code></td><td><code>&nbsp }&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1538</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1539</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1540</i> </code></td><td><code>&nbsp /******************************************************************************/</code></td></tr>
<tr><td><code><i>  1541</i> </code></td><td><code>&nbsp /**&nbsp Internal&nbsp Functions&nbsp *********************************************************/</code></td></tr>
<tr><td><code><i>  1542</i> </code></td><td><code>&nbsp /******************************************************************************/</code></td></tr>
<tr><td><code><i>  1543</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1544</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  1545</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBConfigureEndpoint(uint8_t&nbsp EPNum,&nbsp uint8_t&nbsp direction)</code></td></tr>
<tr><td><code><i>  1546</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1547</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1548</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1549</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp uint8_t&nbsp EPNum&nbsp -&nbsp the&nbsp endpoint&nbsp to&nbsp be&nbsp configured</code></td></tr>
<tr><td><code><i>  1550</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp uint8_t&nbsp direction&nbsp -&nbsp the&nbsp direction&nbsp to&nbsp be&nbsp configured</code></td></tr>
<tr><td><code><i>  1551</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (either&nbsp OUT_FROM_HOST&nbsp or&nbsp IN_TO_HOST)</code></td></tr>
<tr><td><code><i>  1552</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1553</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1554</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1555</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1556</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1557</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp will&nbsp configure&nbsp the&nbsp specified&nbsp </code></td></tr>
<tr><td><code><i>  1558</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp endpoint</code></td></tr>
<tr><td><code><i>  1559</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1560</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1561</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>  1562</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBConfigureEndpoint(uint8_t&nbsp EPNum,&nbsp uint8_t&nbsp direction)</code></td></tr>
<tr><td><code><i>  1563</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  1564</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp volatile&nbsp BDT_ENTRY*&nbsp handle;</code></td></tr>
<tr><td><code><i>  1565</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1566</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Compute&nbsp a&nbsp pointer&nbsp to&nbsp the&nbsp even&nbsp BDT&nbsp entry&nbsp corresponding&nbsp to&nbsp the</code></td></tr>
<tr><td><code><i>  1567</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //EPNum&nbsp and&nbsp direction&nbsp values&nbsp passed&nbsp to&nbsp this&nbsp function.</code></td></tr>
<tr><td><code><i>  1568</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp handle&nbsp =&nbsp (volatile&nbsp BDT_ENTRY*)&BDT[EP0_OUT_EVEN];&nbsp //Get&nbsp address&nbsp of&nbsp start&nbsp of&nbsp BDT</code></td></tr>
<tr><td><code><i>  1569</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp handle&nbsp +=&nbsp EP(EPNum,direction,0u);&nbsp&nbsp&nbsp&nbsp&nbsp //Add&nbsp in&nbsp offset&nbsp to&nbsp the&nbsp BDT&nbsp of&nbsp interest</code></td></tr>
<tr><td><code><i>  1570</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1571</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp handle-&rsaquo  STAT.UOWN&nbsp =&nbsp 0;&nbsp&nbsp //mostly&nbsp redundant,&nbsp since&nbsp USBStdSetCfgHandler()&nbsp </code></td></tr>
<tr><td><code><i>  1572</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //already&nbsp cleared&nbsp the&nbsp entire&nbsp BDT&nbsp table</code></td></tr>
<tr><td><code><i>  1573</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1574</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Make&nbsp sure&nbsp our&nbsp pBDTEntryIn/Out[]&nbsp pointer&nbsp is&nbsp initialized.&nbsp&nbsp Needed&nbsp later</code></td></tr>
<tr><td><code><i>  1575</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //for&nbsp USBTransferOnePacket()&nbsp API&nbsp calls.</code></td></tr>
<tr><td><code><i>  1576</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(direction&nbsp ==&nbsp OUT_FROM_HOST)</code></td></tr>
<tr><td><code><i>  1577</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1578</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryOut[EPNum]&nbsp =&nbsp handle;</code></td></tr>
<tr><td><code><i>  1579</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1580</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  1581</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1582</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[EPNum]&nbsp =&nbsp handle;</code></td></tr>
<tr><td><code><i>  1583</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1584</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1585</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__FULL_PING_PONG)</code></td></tr>
<tr><td><code><i>  1586</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp handle-&rsaquo  STAT.DTS&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  1587</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (handle+1)-&rsaquo  STAT.DTS&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  1588</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #elif&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__NO_PING_PONG)</code></td></tr>
<tr><td><code><i>  1589</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Set&nbsp DTS&nbsp to&nbsp one&nbsp because&nbsp the&nbsp first&nbsp thing&nbsp we&nbsp will&nbsp do</code></td></tr>
<tr><td><code><i>  1590</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //when&nbsp transmitting&nbsp is&nbsp toggle&nbsp the&nbsp bit</code></td></tr>
<tr><td><code><i>  1591</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp handle-&rsaquo  STAT.DTS&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  1592</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #elif&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__EP0_OUT_ONLY)</code></td></tr>
<tr><td><code><i>  1593</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(EPNum&nbsp !=&nbsp 0)</code></td></tr>
<tr><td><code><i>  1594</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1595</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp handle-&rsaquo  STAT.DTS&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  1596</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1597</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #elif&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__ALL_BUT_EP0)&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1598</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(EPNum&nbsp !=&nbsp 0)</code></td></tr>
<tr><td><code><i>  1599</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1600</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp handle-&rsaquo  STAT.DTS&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  1601</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (handle+1)-&rsaquo  STAT.DTS&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  1602</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1603</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  1604</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>  1605</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1606</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1607</i> </code></td><td><code>&nbsp /******************************************************************************</code></td></tr>
<tr><td><code><i>  1608</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBCtrlEPServiceComplete(void)</code></td></tr>
<tr><td><code><i>  1609</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1610</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1611</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1612</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1613</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1614</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1615</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1616</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1617</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1618</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp wrap&nbsp up&nbsp the&nbsp remaining&nbsp tasks&nbsp in&nbsp servicing</code></td></tr>
<tr><td><code><i>  1619</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp a&nbsp Setup&nbsp Request.&nbsp Its&nbsp main&nbsp task&nbsp is&nbsp to&nbsp set&nbsp the&nbsp endpoint</code></td></tr>
<tr><td><code><i>  1620</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp controls&nbsp appropriately&nbsp for&nbsp a&nbsp given&nbsp situation.&nbsp See&nbsp code</code></td></tr>
<tr><td><code><i>  1621</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp below.</code></td></tr>
<tr><td><code><i>  1622</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp There&nbsp are&nbsp three&nbsp main&nbsp scenarios:</code></td></tr>
<tr><td><code><i>  1623</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp a)&nbsp There&nbsp was&nbsp no&nbsp handler&nbsp for&nbsp the&nbsp Request,&nbsp in&nbsp this&nbsp case</code></td></tr>
<tr><td><code><i>  1624</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp a&nbsp STALL&nbsp should&nbsp be&nbsp sent&nbsp out.</code></td></tr>
<tr><td><code><i>  1625</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp b)&nbsp The&nbsp host&nbsp has&nbsp requested&nbsp a&nbsp read&nbsp control&nbsp transfer,</code></td></tr>
<tr><td><code><i>  1626</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp endpoints&nbsp are&nbsp required&nbsp to&nbsp be&nbsp setup&nbsp in&nbsp a&nbsp specific&nbsp way.</code></td></tr>
<tr><td><code><i>  1627</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp c)&nbsp The&nbsp host&nbsp has&nbsp requested&nbsp a&nbsp write&nbsp control&nbsp transfer,&nbsp or</code></td></tr>
<tr><td><code><i>  1628</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp a&nbsp control&nbsp data&nbsp stage&nbsp is&nbsp not&nbsp required,&nbsp endpoints&nbsp are</code></td></tr>
<tr><td><code><i>  1629</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp required&nbsp to&nbsp be&nbsp setup&nbsp in&nbsp a&nbsp specific&nbsp way.</code></td></tr>
<tr><td><code><i>  1630</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1631</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Packet&nbsp processing&nbsp is&nbsp resumed&nbsp by&nbsp clearing&nbsp PKTDIS&nbsp bit.</code></td></tr>
<tr><td><code><i>  1632</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1633</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1634</i> </code></td><td><code>&nbsp &nbsp *****************************************************************************/</code></td></tr>
<tr><td><code><i>  1635</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlEPServiceComplete(void)</code></td></tr>
<tr><td><code><i>  1636</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  1637</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>  1638</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp PKTDIS&nbsp bit&nbsp is&nbsp set&nbsp when&nbsp a&nbsp Setup&nbsp Transaction&nbsp is&nbsp received.</code></td></tr>
<tr><td><code><i>  1639</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Clear&nbsp to&nbsp resume&nbsp packet&nbsp processing.</code></td></tr>
<tr><td><code><i>  1640</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>  1641</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBPacketDisable&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  1642</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1643</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Check&nbsp the&nbsp busy&nbsp bits&nbsp and&nbsp the&nbsp SetupPtk.DataDir&nbsp variables&nbsp to&nbsp determine&nbsp what&nbsp type&nbsp of</code></td></tr>
<tr><td><code><i>  1644</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //control&nbsp transfer&nbsp is&nbsp currently&nbsp in&nbsp progress.&nbsp&nbsp We&nbsp need&nbsp to&nbsp know&nbsp the&nbsp type&nbsp of&nbsp control</code></td></tr>
<tr><td><code><i>  1645</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //transfer&nbsp that&nbsp is&nbsp currently&nbsp pending,&nbsp in&nbsp order&nbsp to&nbsp know&nbsp how&nbsp to&nbsp properly&nbsp arm&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  1646</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //EP0&nbsp IN&nbsp and&nbsp EP0&nbsp OUT&nbsp endpoints.</code></td></tr>
<tr><td><code><i>  1647</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(inPipes[0].info.bits.busy&nbsp ==&nbsp 0)</code></td></tr>
<tr><td><code><i>  1648</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1649</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(outPipes[0].info.bits.busy&nbsp ==&nbsp 1)</code></td></tr>
<tr><td><code><i>  1650</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1651</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp controlTransferState&nbsp =&nbsp CTRL_TRF_RX;</code></td></tr>
<tr><td><code><i>  1652</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>  1653</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Control&nbsp Write:</code></td></tr>
<tr><td><code><i>  1654</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&lsaquo  SETUP[0]&rsaquo &lsaquo  OUT[1]&rsaquo &lsaquo  OUT[0]&rsaquo  ...&lsaquo  IN[1]&rsaquo &nbsp |&nbsp&lsaquo  SETUP[0]&rsaquo  </code></td></tr>
<tr><td><code><i>  1655</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>  1656</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1657</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //1.&nbsp Prepare&nbsp OUT&nbsp EP&nbsp to&nbsp receive&nbsp data,&nbsp unless&nbsp a&nbsp USB&nbsp class&nbsp request&nbsp handler</code></td></tr>
<tr><td><code><i>  1658</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp function&nbsp decided&nbsp to&nbsp defer&nbsp the&nbsp data&nbsp stage&nbsp (ex:&nbsp because&nbsp the&nbsp intended</code></td></tr>
<tr><td><code><i>  1659</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp RAM&nbsp buffer&nbsp wasn't&nbsp available&nbsp yet)&nbsp by&nbsp calling&nbsp USBDeferDataStage().</code></td></tr>
<tr><td><code><i>  1660</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp If&nbsp it&nbsp did&nbsp so,&nbsp it&nbsp is&nbsp then&nbsp responsible&nbsp for&nbsp calling&nbsp USBCtrlEPAllowDataStage(),</code></td></tr>
<tr><td><code><i>  1661</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp once&nbsp it&nbsp is&nbsp ready&nbsp to&nbsp begin&nbsp receiving&nbsp the&nbsp data.</code></td></tr>
<tr><td><code><i>  1662</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBDeferOUTDataStagePackets&nbsp ==&nbsp false)</code></td></tr>
<tr><td><code><i>  1663</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1664</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlEPAllowDataStage();</code></td></tr>
<tr><td><code><i>  1665</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1666</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1667</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //2.&nbsp&nbsp IN&nbsp endpoint&nbsp 0&nbsp status&nbsp stage&nbsp will&nbsp be&nbsp armed&nbsp by&nbsp USBCtrlEPAllowStatusStage()&nbsp </code></td></tr>
<tr><td><code><i>  1668</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //after&nbsp all&nbsp of&nbsp the&nbsp OUT&nbsp data&nbsp has&nbsp been&nbsp received&nbsp and&nbsp consumed,&nbsp or&nbsp if&nbsp a&nbsp timeout&nbsp occurs.</code></td></tr>
<tr><td><code><i>  1669</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStatusStageEnabledFlag2&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  1670</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStatusStageEnabledFlag1&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  1671</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1672</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  1673</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1674</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>  1675</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp If&nbsp no&nbsp one&nbsp knows&nbsp how&nbsp to&nbsp service&nbsp this&nbsp request&nbsp then&nbsp stall.</code></td></tr>
<tr><td><code><i>  1676</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Must&nbsp also&nbsp prepare&nbsp EP0&nbsp to&nbsp receive&nbsp the&nbsp next&nbsp SETUP&nbsp transaction.</code></td></tr>
<tr><td><code><i>  1677</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>  1678</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  CNT&nbsp =&nbsp USB_EP0_BUFF_SIZE;</code></td></tr>
<tr><td><code><i>  1679</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(&SetupPkt);</code></td></tr>
<tr><td><code><i>  1680</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp =&nbsp _DAT0|(_DTSEN&nbsp &&nbsp _DTS_CHECKING_ENABLED)|_BSTALL;</code></td></tr>
<tr><td><code><i>  1681</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1682</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp =&nbsp _BSTALL;</code></td></tr>
<tr><td><code><i>  1683</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1684</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1685</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1686</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else&nbsp&nbsp&nbsp&nbsp //&nbsp A&nbsp module&nbsp has&nbsp claimed&nbsp ownership&nbsp of&nbsp the&nbsp control&nbsp transfer&nbsp session.</code></td></tr>
<tr><td><code><i>  1687</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1688</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.DataDir&nbsp ==&nbsp USB_SETUP_DEVICE_TO_HOST_BITFIELD)</code></td></tr>
<tr><td><code><i>  1689</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1690</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp controlTransferState&nbsp =&nbsp CTRL_TRF_TX;</code></td></tr>
<tr><td><code><i>  1691</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>  1692</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp *&nbsp Control&nbsp Read:</code></td></tr>
<tr><td><code><i>  1693</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp *&nbsp&lsaquo  SETUP[0]&rsaquo &lsaquo  IN[1]&rsaquo &lsaquo  IN[0]&rsaquo  ...&lsaquo  OUT[1]&rsaquo &nbsp |&nbsp&lsaquo  SETUP[0]&rsaquo  </code></td></tr>
<tr><td><code><i>  1694</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1695</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp *&nbsp 1.&nbsp Prepare&nbsp IN&nbsp EP&nbsp to&nbsp transfer&nbsp data&nbsp to&nbsp the&nbsp host.&nbsp&nbsp If&nbsp however&nbsp the&nbsp data</code></td></tr>
<tr><td><code><i>  1696</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp wasn't&nbsp ready&nbsp yet&nbsp (ex:&nbsp because&nbsp the&nbsp firmware&nbsp needs&nbsp to&nbsp go&nbsp and&nbsp read&nbsp it&nbsp from</code></td></tr>
<tr><td><code><i>  1697</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp some&nbsp slow/currently&nbsp unavailable&nbsp resource,&nbsp such&nbsp as&nbsp an&nbsp external&nbsp I2C&nbsp EEPconst),</code></td></tr>
<tr><td><code><i>  1698</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp Then&nbsp the&nbsp class&nbsp request&nbsp handler&nbsp reponsible&nbsp should&nbsp call&nbsp the&nbsp USBDeferDataStage()</code></td></tr>
<tr><td><code><i>  1699</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp macro.&nbsp&nbsp In&nbsp this&nbsp case,&nbsp the&nbsp firmware&nbsp may&nbsp wait&nbsp up&nbsp to&nbsp 500ms,&nbsp before&nbsp it&nbsp is&nbsp required</code></td></tr>
<tr><td><code><i>  1700</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp to&nbsp transmit&nbsp the&nbsp first&nbsp IN&nbsp data&nbsp packet.&nbsp&nbsp Once&nbsp the&nbsp data&nbsp is&nbsp ready,&nbsp and&nbsp the&nbsp firmware</code></td></tr>
<tr><td><code><i>  1701</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp is&nbsp ready&nbsp to&nbsp begin&nbsp sending&nbsp the&nbsp data,&nbsp it&nbsp should&nbsp then&nbsp call&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  1702</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp USBCtrlEPAllowDataStage()&nbsp function&nbsp to&nbsp start&nbsp the&nbsp data&nbsp stage.</code></td></tr>
<tr><td><code><i>  1703</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp */</code></td></tr>
<tr><td><code><i>  1704</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBDeferINDataStagePackets&nbsp ==&nbsp false)</code></td></tr>
<tr><td><code><i>  1705</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1706</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlEPAllowDataStage();</code></td></tr>
<tr><td><code><i>  1707</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1708</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1709</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp 2.&nbsp (Optionally)&nbsp allow&nbsp the&nbsp status&nbsp stage&nbsp now,&nbsp to&nbsp prepare&nbsp for&nbsp early&nbsp termination.</code></td></tr>
<tr><td><code><i>  1710</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp Note:&nbsp If&nbsp a&nbsp class&nbsp request&nbsp handler&nbsp decided&nbsp to&nbsp set&nbsp USBDeferStatusStagePacket&nbsp ==&nbsp true,</code></td></tr>
<tr><td><code><i>  1711</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp then&nbsp it&nbsp is&nbsp responsible&nbsp for&nbsp eventually&nbsp calling&nbsp USBCtrlEPAllowStatusStage()&nbsp once&nbsp it</code></td></tr>
<tr><td><code><i>  1712</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp is&nbsp ready.&nbsp&nbsp If&nbsp the&nbsp class&nbsp request&nbsp handler&nbsp does&nbsp this,&nbsp it&nbsp needs&nbsp to&nbsp be&nbsp careful&nbsp to</code></td></tr>
<tr><td><code><i>  1713</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp be&nbsp written&nbsp so&nbsp that&nbsp it&nbsp can&nbsp handle&nbsp the&nbsp early&nbsp termination&nbsp scenario.</code></td></tr>
<tr><td><code><i>  1714</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp Ex:&nbsp It&nbsp should&nbsp call&nbsp USBCtrlEPAllowStatusStage()&nbsp when&nbsp any&nbsp of&nbsp the&nbsp following&nbsp occurs:</code></td></tr>
<tr><td><code><i>  1715</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp 1.&nbsp&nbsp The&nbsp desired&nbsp total&nbsp number&nbsp of&nbsp bytes&nbsp were&nbsp sent&nbsp to&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>  1716</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp 2.&nbsp&nbsp The&nbsp number&nbsp of&nbsp bytes&nbsp that&nbsp the&nbsp host&nbsp originally&nbsp requested&nbsp (in&nbsp the&nbsp SETUP&nbsp packet&nbsp that&nbsp </code></td></tr>
<tr><td><code><i>  1717</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp started&nbsp the&nbsp control&nbsp transfer)&nbsp has&nbsp been&nbsp reached.</code></td></tr>
<tr><td><code><i>  1718</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp 3.&nbsp&nbsp Or,&nbsp if&nbsp a&nbsp timeout&nbsp occurs&nbsp (ex:&nbsp&lsaquo  50ms&nbsp since&nbsp the&nbsp last&nbsp successful&nbsp EP0&nbsp IN&nbsp transaction),&nbsp regardless&nbsp </code></td></tr>
<tr><td><code><i>  1719</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp of&nbsp how&nbsp many&nbsp bytes&nbsp have&nbsp actually&nbsp been&nbsp sent.&nbsp&nbsp This&nbsp is&nbsp necessary&nbsp to&nbsp prevent&nbsp a&nbsp deadlock&nbsp situation</code></td></tr>
<tr><td><code><i>  1720</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (where&nbsp the&nbsp control&nbsp transfer&nbsp can't&nbsp complete,&nbsp due&nbsp to&nbsp continuous&nbsp NAK&nbsp on&nbsp status&nbsp stage)&nbsp if&nbsp the</code></td></tr>
<tr><td><code><i>  1721</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp host&nbsp performs&nbsp early&nbsp termination.&nbsp&nbsp If&nbsp enabled,&nbsp the&nbsp USB_ENABLE_STATUS_STAGE_TIMEOUTS&nbsp usb_config.h</code></td></tr>
<tr><td><code><i>  1722</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp option&nbsp can&nbsp take&nbsp care&nbsp of&nbsp this&nbsp for&nbsp you.</code></td></tr>
<tr><td><code><i>  1723</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp Note:&nbsp For&nbsp this&nbsp type&nbsp of&nbsp control&nbsp transfer,&nbsp there&nbsp is&nbsp normally&nbsp no&nbsp harm&nbsp in&nbsp simply&nbsp arming&nbsp the</code></td></tr>
<tr><td><code><i>  1724</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp status&nbsp stage&nbsp packet&nbsp right&nbsp now,&nbsp even&nbsp if&nbsp the&nbsp IN&nbsp data&nbsp is&nbsp not&nbsp ready&nbsp yet.&nbsp&nbsp This&nbsp allows&nbsp for</code></td></tr>
<tr><td><code><i>  1725</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp immediate&nbsp early&nbsp termination,&nbsp without&nbsp adding&nbsp unecessary&nbsp delay.&nbsp&nbsp Therefore,&nbsp it&nbsp is&nbsp generally&nbsp not</code></td></tr>
<tr><td><code><i>  1726</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp recommended&nbsp for&nbsp the&nbsp USB&nbsp class&nbsp handler&nbsp firmware&nbsp to&nbsp call&nbsp USBDeferStatusStage(),&nbsp for&nbsp this&nbsp </code></td></tr>
<tr><td><code><i>  1727</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp type&nbsp of&nbsp control&nbsp transfer.&nbsp&nbsp If&nbsp the&nbsp USB&nbsp class&nbsp handler&nbsp firmware&nbsp needs&nbsp more&nbsp time&nbsp to&nbsp fetch&nbsp the&nbsp IN</code></td></tr>
<tr><td><code><i>  1728</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp&nbsp data&nbsp that&nbsp needs&nbsp to&nbsp be&nbsp sent&nbsp to&nbsp the&nbsp host,&nbsp it&nbsp should&nbsp instead&nbsp use&nbsp the&nbsp USBDeferDataStage()&nbsp function.</code></td></tr>
<tr><td><code><i>  1729</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStatusStageEnabledFlag2&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  1730</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStatusStageEnabledFlag1&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  1731</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBDeferStatusStagePacket&nbsp ==&nbsp false)</code></td></tr>
<tr><td><code><i>  1732</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1733</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlEPAllowStatusStage();</code></td></tr>
<tr><td><code><i>  1734</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }&nbsp </code></td></tr>
<tr><td><code><i>  1735</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1736</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else&nbsp&nbsp&nbsp //&nbsp (SetupPkt.DataDir&nbsp ==&nbsp USB_SETUP_DIRECTION_HOST_TO_DEVICE)</code></td></tr>
<tr><td><code><i>  1737</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1738</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //This&nbsp situation&nbsp occurs&nbsp for&nbsp special&nbsp types&nbsp of&nbsp control&nbsp transfers,</code></td></tr>
<tr><td><code><i>  1739</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //such&nbsp as&nbsp that&nbsp which&nbsp occurs&nbsp when&nbsp the&nbsp host&nbsp sends&nbsp a&nbsp SET_ADDRESS</code></td></tr>
<tr><td><code><i>  1740</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //control&nbsp transfer.&nbsp&nbsp Ex:</code></td></tr>
<tr><td><code><i>  1741</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //</code></td></tr>
<tr><td><code><i>  1742</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&lsaquo  SETUP[0]&rsaquo &lsaquo  IN[1]&rsaquo &nbsp |&nbsp&lsaquo  SETUP[0]&rsaquo  </code></td></tr>
<tr><td><code><i>  1743</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1744</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Although&nbsp the&nbsp data&nbsp direction&nbsp is&nbsp HOST_TO_DEVICE,&nbsp there&nbsp is&nbsp no&nbsp data&nbsp stage</code></td></tr>
<tr><td><code><i>  1745</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //(hence:&nbsp outPipes[0].info.bits.busy&nbsp ==&nbsp 0).&nbsp&nbsp There&nbsp is&nbsp however&nbsp still</code></td></tr>
<tr><td><code><i>  1746</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //an&nbsp IN&nbsp status&nbsp stage.</code></td></tr>
<tr><td><code><i>  1747</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1748</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp controlTransferState&nbsp =&nbsp CTRL_TRF_RX;&nbsp&nbsp&nbsp&nbsp&nbsp //Since&nbsp this&nbsp is&nbsp a&nbsp HOST_TO_DEVICE&nbsp control&nbsp transfer</code></td></tr>
<tr><td><code><i>  1749</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1750</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //1.&nbsp Prepare&nbsp OUT&nbsp EP&nbsp to&nbsp receive&nbsp the&nbsp next&nbsp SETUP&nbsp packet.</code></td></tr>
<tr><td><code><i>  1751</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  CNT&nbsp =&nbsp USB_EP0_BUFF_SIZE;</code></td></tr>
<tr><td><code><i>  1752</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(&SetupPkt);</code></td></tr>
<tr><td><code><i>  1753</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp =&nbsp _BSTALL;</code></td></tr>
<tr><td><code><i>  1754</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1755</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1756</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //2.&nbsp Prepare&nbsp for&nbsp IN&nbsp status&nbsp stage&nbsp of&nbsp the&nbsp control&nbsp transfer</code></td></tr>
<tr><td><code><i>  1757</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStatusStageEnabledFlag2&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  1758</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStatusStageEnabledFlag1&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  1759</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBDeferStatusStagePacket&nbsp ==&nbsp false)</code></td></tr>
<tr><td><code><i>  1760</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1761</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlEPAllowStatusStage();</code></td></tr>
<tr><td><code><i>  1762</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }&nbsp </code></td></tr>
<tr><td><code><i>  1763</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1764</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1765</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp if(ctrl_trf_session_owner&nbsp ==&nbsp MUID_NULL)</code></td></tr>
<tr><td><code><i>  1766</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1767</i> </code></td><td><code>&nbsp }//end&nbsp USBCtrlEPServiceComplete</code></td></tr>
<tr><td><code><i>  1768</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1769</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1770</i> </code></td><td><code>&nbsp /******************************************************************************</code></td></tr>
<tr><td><code><i>  1771</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBCtrlTrfTxService(void)</code></td></tr>
<tr><td><code><i>  1772</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1773</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp pSrc,&nbsp wCount,&nbsp and&nbsp usb_stat.ctrl_trf_mem&nbsp are&nbsp setup&nbsp properly.</code></td></tr>
<tr><td><code><i>  1774</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1775</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1776</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1777</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1778</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1779</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1780</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1781</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp is&nbsp used&nbsp for&nbsp device&nbsp to&nbsp host&nbsp control&nbsp transfers&nbsp </code></td></tr>
<tr><td><code><i>  1782</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp (IN&nbsp transactions).&nbsp&nbsp This&nbsp function&nbsp takes&nbsp care&nbsp of&nbsp managing&nbsp a</code></td></tr>
<tr><td><code><i>  1783</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp transfer&nbsp over&nbsp multiple&nbsp USB&nbsp transactions.</code></td></tr>
<tr><td><code><i>  1784</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp should&nbsp be&nbsp called&nbsp from&nbsp only&nbsp two&nbsp places.</code></td></tr>
<tr><td><code><i>  1785</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp One&nbsp from&nbsp USBCtrlEPServiceComplete()&nbsp and&nbsp one&nbsp from</code></td></tr>
<tr><td><code><i>  1786</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlTrfInHandler().</code></td></tr>
<tr><td><code><i>  1787</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1788</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1789</i> </code></td><td><code>&nbsp &nbsp *****************************************************************************/</code></td></tr>
<tr><td><code><i>  1790</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlTrfTxService(void)</code></td></tr>
<tr><td><code><i>  1791</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  1792</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp byteToSend;</code></td></tr>
<tr><td><code><i>  1793</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1794</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Figure&nbsp out&nbsp how&nbsp many&nbsp bytes&nbsp of&nbsp data&nbsp to&nbsp send&nbsp in&nbsp the&nbsp next&nbsp IN&nbsp transaction.</code></td></tr>
<tr><td><code><i>  1795</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Assume&nbsp a&nbsp full&nbsp size&nbsp packet,&nbsp unless&nbsp otherwise&nbsp determined&nbsp below.</code></td></tr>
<tr><td><code><i>  1796</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp byteToSend&nbsp =&nbsp USB_EP0_BUFF_SIZE;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1797</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(inPipes[0].wCount.Val&nbsp&lsaquo &nbsp (uint8_t)USB_EP0_BUFF_SIZE)</code></td></tr>
<tr><td><code><i>  1798</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1799</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp byteToSend&nbsp =&nbsp inPipes[0].wCount.Val;</code></td></tr>
<tr><td><code><i>  1800</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1801</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Keep&nbsp track&nbsp of&nbsp whether&nbsp or&nbsp not&nbsp we&nbsp have&nbsp sent&nbsp a&nbsp "short&nbsp packet"&nbsp yet.</code></td></tr>
<tr><td><code><i>  1802</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //This&nbsp is&nbsp useful&nbsp so&nbsp that&nbsp later&nbsp on,&nbsp we&nbsp can&nbsp configure&nbsp EP0&nbsp IN&nbsp to&nbsp STALL,</code></td></tr>
<tr><td><code><i>  1803</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //after&nbsp we&nbsp have&nbsp sent&nbsp all&nbsp of&nbsp the&nbsp intended&nbsp data.&nbsp&nbsp This&nbsp makes&nbsp sure&nbsp the</code></td></tr>
<tr><td><code><i>  1804</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //hardware&nbsp STALLs&nbsp if&nbsp the&nbsp host&nbsp erroneously&nbsp tries&nbsp to&nbsp send&nbsp more&nbsp IN&nbsp token&nbsp </code></td></tr>
<tr><td><code><i>  1805</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //packets,&nbsp requesting&nbsp more&nbsp data&nbsp than&nbsp intended&nbsp in&nbsp the&nbsp control&nbsp transfer.</code></td></tr>
<tr><td><code><i>  1806</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(shortPacketStatus&nbsp ==&nbsp SHORT_PKT_NOT_USED)</code></td></tr>
<tr><td><code><i>  1807</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1808</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp shortPacketStatus&nbsp =&nbsp SHORT_PKT_PENDING;</code></td></tr>
<tr><td><code><i>  1809</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1810</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else&nbsp if(shortPacketStatus&nbsp ==&nbsp SHORT_PKT_PENDING)</code></td></tr>
<tr><td><code><i>  1811</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1812</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp shortPacketStatus&nbsp =&nbsp SHORT_PKT_SENT;</code></td></tr>
<tr><td><code><i>  1813</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1814</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1815</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1816</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Keep&nbsp track&nbsp of&nbsp how&nbsp many&nbsp bytes&nbsp remain&nbsp to&nbsp be&nbsp sent&nbsp in&nbsp the&nbsp transfer,&nbsp by</code></td></tr>
<tr><td><code><i>  1817</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //subtracting&nbsp the&nbsp number&nbsp of&nbsp bytes&nbsp about&nbsp to&nbsp be&nbsp sent&nbsp from&nbsp the&nbsp total.</code></td></tr>
<tr><td><code><i>  1818</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp inPipes[0].wCount.Val&nbsp -=&nbsp byteToSend;</code></td></tr>
<tr><td><code><i>  1819</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1820</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Next,&nbsp load&nbsp the&nbsp number&nbsp of&nbsp bytes&nbsp to&nbsp send&nbsp to&nbsp BC7..0&nbsp in&nbsp buffer&nbsp descriptor.</code></td></tr>
<tr><td><code><i>  1821</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Note:&nbsp Control&nbsp endpoints&nbsp may&nbsp never&nbsp have&nbsp a&nbsp max&nbsp packet&nbsp size&nbsp of&nbsp&rsaquo &nbsp 64&nbsp bytes.</code></td></tr>
<tr><td><code><i>  1822</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Therefore,&nbsp the&nbsp BC8&nbsp and&nbsp BC9&nbsp bits&nbsp should&nbsp always&nbsp be&nbsp maintained&nbsp clear.</code></td></tr>
<tr><td><code><i>  1823</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  CNT&nbsp =&nbsp byteToSend;</code></td></tr>
<tr><td><code><i>  1824</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1825</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Now&nbsp copy&nbsp the&nbsp data&nbsp from&nbsp the&nbsp source&nbsp location,&nbsp to&nbsp the&nbsp CtrlTrfData[]&nbsp buffer,</code></td></tr>
<tr><td><code><i>  1826</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //which&nbsp we&nbsp will&nbsp send&nbsp to&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>  1827</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp pDst&nbsp =&nbsp (USB_VOLATILE&nbsp uint8_t*)CtrlTrfData;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp destination&nbsp pointer</code></td></tr>
<tr><td><code><i>  1828</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(inPipes[0].info.bits.ctrl_trf_mem&nbsp ==&nbsp USB_EP0_ROM)&nbsp&nbsp&nbsp //&nbsp Determine&nbsp type&nbsp of&nbsp memory&nbsp source</code></td></tr>
<tr><td><code><i>  1829</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1830</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp while(byteToSend)</code></td></tr>
<tr><td><code><i>  1831</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1832</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *pDst++&nbsp =&nbsp *inPipes[0].pSrc.bRom++;</code></td></tr>
<tr><td><code><i>  1833</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp byteToSend--;</code></td></tr>
<tr><td><code><i>  1834</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }//end&nbsp while(byte_to_send.Val)</code></td></tr>
<tr><td><code><i>  1835</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1836</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else&nbsp&nbsp //&nbsp RAM</code></td></tr>
<tr><td><code><i>  1837</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1838</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp while(byteToSend)</code></td></tr>
<tr><td><code><i>  1839</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1840</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *pDst++&nbsp =&nbsp *inPipes[0].pSrc.bRam++;</code></td></tr>
<tr><td><code><i>  1841</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp byteToSend--;</code></td></tr>
<tr><td><code><i>  1842</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }//end&nbsp while(byte_to_send.Val)</code></td></tr>
<tr><td><code><i>  1843</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp if(usb_stat.ctrl_trf_mem&nbsp ==&nbsp _const)</code></td></tr>
<tr><td><code><i>  1844</i> </code></td><td><code>&nbsp }//end&nbsp USBCtrlTrfTxService</code></td></tr>
<tr><td><code><i>  1845</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1846</i> </code></td><td><code>&nbsp /******************************************************************************</code></td></tr>
<tr><td><code><i>  1847</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBCtrlTrfRxService(void)</code></td></tr>
<tr><td><code><i>  1848</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1849</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp pDst&nbsp and&nbsp wCount&nbsp are&nbsp setup&nbsp properly.</code></td></tr>
<tr><td><code><i>  1850</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pSrc&nbsp is&nbsp always&nbsp &CtrlTrfData</code></td></tr>
<tr><td><code><i>  1851</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp usb_stat.ctrl_trf_mem&nbsp is&nbsp always&nbsp USB_EP0_RAM.</code></td></tr>
<tr><td><code><i>  1852</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp wCount&nbsp should&nbsp be&nbsp set&nbsp to&nbsp 0&nbsp at&nbsp the&nbsp start&nbsp of&nbsp each&nbsp control</code></td></tr>
<tr><td><code><i>  1853</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp transfer.</code></td></tr>
<tr><td><code><i>  1854</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1855</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1856</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1857</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1858</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1859</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1860</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1861</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp is&nbsp used&nbsp for&nbsp host&nbsp to&nbsp device&nbsp control&nbsp transfers</code></td></tr>
<tr><td><code><i>  1862</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp (uses&nbsp OUT&nbsp transactions).&nbsp&nbsp This&nbsp function&nbsp receives&nbsp the&nbsp data&nbsp that&nbsp arrives</code></td></tr>
<tr><td><code><i>  1863</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp on&nbsp EP0&nbsp OUT,&nbsp and&nbsp copies&nbsp it&nbsp into&nbsp the&nbsp appropriate&nbsp outPipes[0].pDst.bRam</code></td></tr>
<tr><td><code><i>  1864</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp buffer.&nbsp&nbsp Once&nbsp the&nbsp host&nbsp has&nbsp sent&nbsp all&nbsp the&nbsp data&nbsp it&nbsp was&nbsp intending</code></td></tr>
<tr><td><code><i>  1865</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp to&nbsp send,&nbsp this&nbsp function&nbsp will&nbsp call&nbsp the&nbsp appropriate&nbsp outPipes[0].pFunc()</code></td></tr>
<tr><td><code><i>  1866</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp handler&nbsp (unless&nbsp it&nbsp is&nbsp NULL),&nbsp so&nbsp that&nbsp it&nbsp can&nbsp be&nbsp used&nbsp by&nbsp the</code></td></tr>
<tr><td><code><i>  1867</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp intended&nbsp target&nbsp firmware.</code></td></tr>
<tr><td><code><i>  1868</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1869</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1870</i> </code></td><td><code>&nbsp &nbsp *****************************************************************************/</code></td></tr>
<tr><td><code><i>  1871</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlTrfRxService(void)</code></td></tr>
<tr><td><code><i>  1872</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  1873</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp byteToRead;</code></td></tr>
<tr><td><code><i>  1874</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp i;</code></td></tr>
<tr><td><code><i>  1875</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1876</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Load&nbsp byteToRead&nbsp with&nbsp the&nbsp number&nbsp of&nbsp bytes&nbsp the&nbsp host&nbsp just&nbsp sent&nbsp us&nbsp in&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  1877</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //last&nbsp OUT&nbsp transaction.</code></td></tr>
<tr><td><code><i>  1878</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp byteToRead&nbsp =&nbsp pBDTEntryEP0OutCurrent-&rsaquo  CNT;&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1879</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1880</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Update&nbsp the&nbsp "outPipes[0].wCount.Val",&nbsp which&nbsp keeps&nbsp track&nbsp of&nbsp the&nbsp total&nbsp number</code></td></tr>
<tr><td><code><i>  1881</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //of&nbsp remaining&nbsp bytes&nbsp expected&nbsp to&nbsp be&nbsp received&nbsp from&nbsp the&nbsp host,&nbsp in&nbsp the&nbsp control</code></td></tr>
<tr><td><code><i>  1882</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //transfer.&nbsp&nbsp First&nbsp check&nbsp to&nbsp see&nbsp if&nbsp the&nbsp host&nbsp sent&nbsp us&nbsp more&nbsp bytes&nbsp than&nbsp the</code></td></tr>
<tr><td><code><i>  1883</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //application&nbsp firmware&nbsp was&nbsp expecting&nbsp to&nbsp receive.</code></td></tr>
<tr><td><code><i>  1884</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(byteToRead&nbsp&rsaquo &nbsp outPipes[0].wCount.Val)</code></td></tr>
<tr><td><code><i>  1885</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1886</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp byteToRead&nbsp =&nbsp outPipes[0].wCount.Val;</code></td></tr>
<tr><td><code><i>  1887</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1888</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Reduce&nbsp the&nbsp number&nbsp of&nbsp remaining&nbsp bytes&nbsp by&nbsp the&nbsp number&nbsp we&nbsp just&nbsp received.</code></td></tr>
<tr><td><code><i>  1889</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp outPipes[0].wCount.Val&nbsp -=&nbsp byteToRead;</code></td></tr>
<tr><td><code><i>  1890</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1891</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Copy&nbsp the&nbsp OUT&nbsp DATAx&nbsp packet&nbsp bytes&nbsp that&nbsp we&nbsp just&nbsp received&nbsp from&nbsp the&nbsp host,</code></td></tr>
<tr><td><code><i>  1892</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //into&nbsp the&nbsp user&nbsp application&nbsp buffer&nbsp space.</code></td></tr>
<tr><td><code><i>  1893</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp for(i=0;i&lsaquo  byteToRead;i++)</code></td></tr>
<tr><td><code><i>  1894</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1895</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *outPipes[0].pDst.bRam++&nbsp =&nbsp CtrlTrfData[i];</code></td></tr>
<tr><td><code><i>  1896</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp while(byteToRead.Val)</code></td></tr>
<tr><td><code><i>  1897</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1898</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //If&nbsp there&nbsp is&nbsp more&nbsp data&nbsp to&nbsp receive,&nbsp prepare&nbsp EP0&nbsp OUT&nbsp so&nbsp that&nbsp it&nbsp can&nbsp receive&nbsp </code></td></tr>
<tr><td><code><i>  1899</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //the&nbsp next&nbsp packet&nbsp in&nbsp the&nbsp sequence.</code></td></tr>
<tr><td><code><i>  1900</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(outPipes[0].wCount.Val&nbsp&rsaquo &nbsp 0)</code></td></tr>
<tr><td><code><i>  1901</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1902</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  CNT&nbsp =&nbsp USB_EP0_BUFF_SIZE;</code></td></tr>
<tr><td><code><i>  1903</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(&CtrlTrfData);</code></td></tr>
<tr><td><code><i>  1904</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(pBDTEntryEP0OutCurrent-&rsaquo  STAT.DTS&nbsp ==&nbsp 0)</code></td></tr>
<tr><td><code><i>  1905</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1906</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp =&nbsp _DAT1|(_DTSEN&nbsp &&nbsp _DTS_CHECKING_ENABLED);</code></td></tr>
<tr><td><code><i>  1907</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1908</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1909</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  1910</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1911</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp =&nbsp _DAT0|(_DTSEN&nbsp &&nbsp _DTS_CHECKING_ENABLED);</code></td></tr>
<tr><td><code><i>  1912</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1913</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1914</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1915</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  1916</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1917</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp //We&nbsp have&nbsp received&nbsp all&nbsp OUT&nbsp packets&nbsp that&nbsp we&nbsp were&nbsp expecting&nbsp to</code></td></tr>
<tr><td><code><i>  1918</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp //receive&nbsp for&nbsp the&nbsp control&nbsp transfer.&nbsp&nbsp Prepare&nbsp EP0&nbsp OUT&nbsp to&nbsp receive</code></td></tr>
<tr><td><code><i>  1919</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //the&nbsp next&nbsp SETUP&nbsp transaction&nbsp that&nbsp may&nbsp arrive.</code></td></tr>
<tr><td><code><i>  1920</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  CNT&nbsp =&nbsp USB_EP0_BUFF_SIZE;</code></td></tr>
<tr><td><code><i>  1921</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(&SetupPkt);</code></td></tr>
<tr><td><code><i>  1922</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Configure&nbsp EP0&nbsp OUT&nbsp to&nbsp receive&nbsp the&nbsp next&nbsp SETUP&nbsp transaction&nbsp for&nbsp any&nbsp future</code></td></tr>
<tr><td><code><i>  1923</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //control&nbsp transfers.&nbsp&nbsp However,&nbsp set&nbsp BSTALL&nbsp in&nbsp case&nbsp the&nbsp host&nbsp tries&nbsp to&nbsp send</code></td></tr>
<tr><td><code><i>  1924</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //more&nbsp data&nbsp than&nbsp it&nbsp claims&nbsp it&nbsp was&nbsp going&nbsp to&nbsp send.</code></td></tr>
<tr><td><code><i>  1925</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp =&nbsp _BSTALL;</code></td></tr>
<tr><td><code><i>  1926</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  1927</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1928</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //All&nbsp data&nbsp bytes&nbsp for&nbsp the&nbsp host&nbsp to&nbsp device&nbsp control&nbsp write&nbsp (OUT)&nbsp have&nbsp now&nbsp been</code></td></tr>
<tr><td><code><i>  1929</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //received&nbsp successfully.</code></td></tr>
<tr><td><code><i>  1930</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Go&nbsp ahead&nbsp and&nbsp call&nbsp the&nbsp user&nbsp specified&nbsp callback&nbsp function,&nbsp to&nbsp use/consume</code></td></tr>
<tr><td><code><i>  1931</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //the&nbsp control&nbsp transfer&nbsp data&nbsp (ex:&nbsp if&nbsp the&nbsp "void&nbsp (*function)"&nbsp parameter&nbsp </code></td></tr>
<tr><td><code><i>  1932</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //was&nbsp non-NULL&nbsp when&nbsp USBEP0Receive()&nbsp was&nbsp called).</code></td></tr>
<tr><td><code><i>  1933</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(outPipes[0].pFunc&nbsp !=&nbsp NULL)</code></td></tr>
<tr><td><code><i>  1934</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1935</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(__XC8)</code></td></tr>
<tr><td><code><i>  1936</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Special&nbsp pragmas&nbsp to&nbsp suppress&nbsp an&nbsp expected/harmless&nbsp warning</code></td></tr>
<tr><td><code><i>  1937</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //message&nbsp when&nbsp building&nbsp with&nbsp the&nbsp XC8&nbsp compiler</code></td></tr>
<tr><td><code><i>  1938</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #pragma&nbsp warning&nbsp push</code></td></tr>
<tr><td><code><i>  1939</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #pragma&nbsp warning&nbsp disable&nbsp 1088</code></td></tr>
<tr><td><code><i>  1940</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp outPipes[0].pFunc();&nbsp&nbsp&nbsp&nbsp //Call&nbsp the&nbsp user's&nbsp callback&nbsp function</code></td></tr>
<tr><td><code><i>  1941</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #pragma&nbsp warning&nbsp pop</code></td></tr>
<tr><td><code><i>  1942</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #else</code></td></tr>
<tr><td><code><i>  1943</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp outPipes[0].pFunc();&nbsp&nbsp&nbsp&nbsp //Call&nbsp the&nbsp user's&nbsp callback&nbsp function</code></td></tr>
<tr><td><code><i>  1944</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  1945</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  1946</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp outPipes[0].info.bits.busy&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1947</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1948</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Ready&nbsp to&nbsp arm&nbsp status&nbsp stage&nbsp IN&nbsp transaction&nbsp now,&nbsp if&nbsp the&nbsp application</code></td></tr>
<tr><td><code><i>  1949</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //firmware&nbsp has&nbsp completed&nbsp processing&nbsp the&nbsp request.&nbsp&nbsp If&nbsp it&nbsp is&nbsp still&nbsp busy</code></td></tr>
<tr><td><code><i>  1950</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //and&nbsp needs&nbsp more&nbsp time&nbsp to&nbsp finish&nbsp handling&nbsp the&nbsp request,&nbsp then&nbsp the&nbsp user</code></td></tr>
<tr><td><code><i>  1951</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //callback&nbsp (the&nbsp one&nbsp called&nbsp by&nbsp the&nbsp outPipes[0].pFunc();)&nbsp should&nbsp set&nbsp the</code></td></tr>
<tr><td><code><i>  1952</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //USBDeferStatusStagePacket&nbsp to&nbsp true&nbsp (by&nbsp calling&nbsp USBDeferStatusStage()).&nbsp&nbsp In</code></td></tr>
<tr><td><code><i>  1953</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //this&nbsp case,&nbsp it&nbsp is&nbsp the&nbsp application's&nbsp firmware&nbsp responsibility&nbsp to&nbsp call&nbsp </code></td></tr>
<tr><td><code><i>  1954</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //the&nbsp USBCtrlEPAllowStatusStage()&nbsp function,&nbsp once&nbsp it&nbsp is&nbsp fully&nbsp done&nbsp handling&nbsp the&nbsp request.</code></td></tr>
<tr><td><code><i>  1955</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Note:&nbsp The&nbsp application&nbsp firmware&nbsp must&nbsp process&nbsp the&nbsp request&nbsp and&nbsp call</code></td></tr>
<tr><td><code><i>  1956</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //USBCtrlEPAllowStatusStage()&nbsp in&nbsp a&nbsp semi-timely&nbsp fashion.&nbsp&nbsp "Semi-timely"</code></td></tr>
<tr><td><code><i>  1957</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //means&nbsp either&nbsp 50ms,&nbsp 500ms,&nbsp or&nbsp 5&nbsp seconds,&nbsp depending&nbsp on&nbsp the&nbsp type&nbsp of</code></td></tr>
<tr><td><code><i>  1958</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //control&nbsp transfer.&nbsp&nbsp See&nbsp the&nbsp USB&nbsp 2.0&nbsp specification&nbsp section&nbsp 9.2.6&nbsp for</code></td></tr>
<tr><td><code><i>  1959</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //more&nbsp details.</code></td></tr>
<tr><td><code><i>  1960</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBDeferStatusStagePacket&nbsp ==&nbsp false)</code></td></tr>
<tr><td><code><i>  1961</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  1962</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlEPAllowStatusStage();</code></td></tr>
<tr><td><code><i>  1963</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1964</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1965</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1966</i> </code></td><td><code>&nbsp }//end&nbsp USBCtrlTrfRxService</code></td></tr>
<tr><td><code><i>  1967</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1968</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1969</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  1970</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBStdSetCfgHandler(void)</code></td></tr>
<tr><td><code><i>  1971</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1972</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1973</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1974</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1975</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1976</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1977</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1978</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1979</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1980</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp first&nbsp disables&nbsp all&nbsp endpoints&nbsp by</code></td></tr>
<tr><td><code><i>  1981</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp clearing&nbsp UEP&nbsp registers.&nbsp It&nbsp then&nbsp configures</code></td></tr>
<tr><td><code><i>  1982</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (initializes)&nbsp endpoints&nbsp by&nbsp calling&nbsp the&nbsp callback</code></td></tr>
<tr><td><code><i>  1983</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp function&nbsp USBCBInitEP().</code></td></tr>
<tr><td><code><i>  1984</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  1985</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  1986</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>  1987</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBStdSetCfgHandler(void)</code></td></tr>
<tr><td><code><i>  1988</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  1989</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp i;</code></td></tr>
<tr><td><code><i>  1990</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1991</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp This&nbsp will&nbsp generate&nbsp a&nbsp zero&nbsp length&nbsp packet</code></td></tr>
<tr><td><code><i>  1992</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  1993</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1994</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Clear&nbsp all&nbsp of&nbsp the&nbsp endpoint&nbsp control&nbsp registers</code></td></tr>
<tr><td><code><i>  1995</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);</code></td></tr>
<tr><td><code><i>  1996</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  1997</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Clear&nbsp all&nbsp of&nbsp the&nbsp BDT&nbsp entries</code></td></tr>
<tr><td><code><i>  1998</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp memset((void*)&BDT[0],&nbsp 0x00,&nbsp sizeof(BDT));</code></td></tr>
<tr><td><code><i>  1999</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2000</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp Assert&nbsp reset&nbsp request&nbsp to&nbsp all&nbsp of&nbsp the&nbsp Ping&nbsp Pong&nbsp buffer&nbsp pointers</code></td></tr>
<tr><td><code><i>  2001</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBPingPongBufferReset&nbsp =&nbsp 1;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2002</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2003</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Re-Initialize&nbsp all&nbsp ping&nbsp pong&nbsp software&nbsp state&nbsp bits&nbsp to&nbsp 0&nbsp (which&nbsp corresponds&nbsp to</code></td></tr>
<tr><td><code><i>  2004</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //the&nbsp EVEN&nbsp buffer&nbsp being&nbsp the&nbsp next&nbsp one&nbsp that&nbsp will&nbsp be&nbsp used),&nbsp since&nbsp we&nbsp are&nbsp also&nbsp </code></td></tr>
<tr><td><code><i>  2005</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //doing&nbsp a&nbsp hardware&nbsp ping&nbsp pong&nbsp pointer&nbsp reset&nbsp above.</code></td></tr>
<tr><td><code><i>  2006</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp for(i&nbsp =&nbsp 0;&nbsp i&nbsp&lsaquo &nbsp (uint8_t)(USB_MAX_EP_NUMBER+1u);&nbsp i++)</code></td></tr>
<tr><td><code><i>  2007</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2008</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ep_data_in[i].Val&nbsp =&nbsp 0u;</code></td></tr>
<tr><td><code><i>  2009</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ep_data_out[i].Val&nbsp =&nbsp 0u;</code></td></tr>
<tr><td><code><i>  2010</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2011</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2012</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //clear&nbsp the&nbsp alternate&nbsp interface&nbsp settings</code></td></tr>
<tr><td><code><i>  2013</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);</code></td></tr>
<tr><td><code><i>  2014</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2015</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Stop&nbsp trying&nbsp to&nbsp reset&nbsp ping&nbsp pong&nbsp buffer&nbsp pointers</code></td></tr>
<tr><td><code><i>  2016</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBPingPongBufferReset&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2017</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2018</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]&nbsp =&nbsp (volatile&nbsp BDT_ENTRY*)&BDT[EP0_IN_EVEN];</code></td></tr>
<tr><td><code><i>  2019</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2020</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Set&nbsp the&nbsp next&nbsp out&nbsp to&nbsp the&nbsp current&nbsp out&nbsp packet</code></td></tr>
<tr><td><code><i>  2021</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutCurrent&nbsp =&nbsp (volatile&nbsp BDT_ENTRY*)&BDT[EP0_OUT_EVEN];</code></td></tr>
<tr><td><code><i>  2022</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext&nbsp =&nbsp pBDTEntryEP0OutCurrent;</code></td></tr>
<tr><td><code><i>  2023</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2024</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //set&nbsp the&nbsp current&nbsp configuration</code></td></tr>
<tr><td><code><i>  2025</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBActiveConfiguration&nbsp =&nbsp SetupPkt.bConfigurationValue;</code></td></tr>
<tr><td><code><i>  2026</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2027</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //if&nbsp the&nbsp configuration&nbsp value&nbsp ==&nbsp 0</code></td></tr>
<tr><td><code><i>  2028</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBActiveConfiguration&nbsp ==&nbsp 0)</code></td></tr>
<tr><td><code><i>  2029</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2030</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Go&nbsp back&nbsp to&nbsp the&nbsp addressed&nbsp state</code></td></tr>
<tr><td><code><i>  2031</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceState&nbsp =&nbsp ADDRESS_STATE;</code></td></tr>
<tr><td><code><i>  2032</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2033</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2034</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2035</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //initialize&nbsp the&nbsp required&nbsp endpoints</code></td></tr>
<tr><td><code><i>  2036</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);</code></td></tr>
<tr><td><code><i>  2037</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2038</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Otherwise&nbsp go&nbsp to&nbsp the&nbsp configured&nbsp state.&nbsp&nbsp Update&nbsp the&nbsp state&nbsp variable&nbsp last,</code></td></tr>
<tr><td><code><i>  2039</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //after&nbsp performing&nbsp all&nbsp of&nbsp the&nbsp set&nbsp configuration&nbsp related&nbsp initialization</code></td></tr>
<tr><td><code><i>  2040</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //tasks.</code></td></tr>
<tr><td><code><i>  2041</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceState&nbsp =&nbsp CONFIGURED_STATE;&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2042</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp if(SetupPkt.bConfigurationValue&nbsp ==&nbsp 0)</code></td></tr>
<tr><td><code><i>  2043</i> </code></td><td><code>&nbsp }//end&nbsp USBStdSetCfgHandler</code></td></tr>
<tr><td><code><i>  2044</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2045</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2046</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  2047</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBStdGetDscHandler(void)</code></td></tr>
<tr><td><code><i>  2048</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2049</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2050</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2051</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2052</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2053</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2054</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2055</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2056</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2057</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp handles&nbsp the&nbsp standard&nbsp GET_DESCRIPTOR</code></td></tr>
<tr><td><code><i>  2058</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp request.</code></td></tr>
<tr><td><code><i>  2059</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2060</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2061</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>  2062</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBStdGetDscHandler(void)</code></td></tr>
<tr><td><code><i>  2063</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  2064</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(SetupPkt.bmRequestType&nbsp ==&nbsp 0x80)</code></td></tr>
<tr><td><code><i>  2065</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2066</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.Val&nbsp =&nbsp USB_EP0_ROM&nbsp |&nbsp USB_EP0_BUSY&nbsp |&nbsp USB_EP0_INCLUDE_ZERO;</code></td></tr>
<tr><td><code><i>  2067</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2068</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp switch(SetupPkt.bDescriptorType)</code></td></tr>
<tr><td><code><i>  2069</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2070</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_DESCRIPTOR_DEVICE:</code></td></tr>
<tr><td><code><i>  2071</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp !defined(USB_USER_DEVICE_DESCRIPTOR)</code></td></tr>
<tr><td><code><i>  2072</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].pSrc.bRom&nbsp =&nbsp (const&nbsp uint8_t*)&device_dsc;</code></td></tr>
<tr><td><code><i>  2073</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #else</code></td></tr>
<tr><td><code><i>  2074</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].pSrc.bRom&nbsp =&nbsp (const&nbsp uint8_t*)USB_USER_DEVICE_DESCRIPTOR;</code></td></tr>
<tr><td><code><i>  2075</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  2076</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].wCount.Val&nbsp =&nbsp sizeof(device_dsc);</code></td></tr>
<tr><td><code><i>  2077</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2078</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_DESCRIPTOR_CONFIGURATION:</code></td></tr>
<tr><td><code><i>  2079</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //First&nbsp perform&nbsp error&nbsp case&nbsp check,&nbsp to&nbsp make&nbsp sure&nbsp the&nbsp host&nbsp is&nbsp requesting&nbsp a&nbsp </code></td></tr>
<tr><td><code><i>  2080</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //legal&nbsp descriptor&nbsp index.&nbsp&nbsp If&nbsp the&nbsp request&nbsp index&nbsp is&nbsp illegal,&nbsp don't&nbsp do&nbsp </code></td></tr>
<tr><td><code><i>  2081</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //anything&nbsp (so&nbsp that&nbsp the&nbsp default&nbsp STALL&nbsp response&nbsp will&nbsp be&nbsp sent).</code></td></tr>
<tr><td><code><i>  2082</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.bDscIndex&nbsp&lsaquo &nbsp USB_MAX_NUM_CONFIG_DSC)</code></td></tr>
<tr><td><code><i>  2083</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2084</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp !defined(USB_USER_CONFIG_DESCRIPTOR)</code></td></tr>
<tr><td><code><i>  2085</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].pSrc.bRom&nbsp =&nbsp *(USB_CD_Ptr+SetupPkt.bDscIndex);</code></td></tr>
<tr><td><code><i>  2086</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #else</code></td></tr>
<tr><td><code><i>  2087</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].pSrc.bRom&nbsp =&nbsp *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);</code></td></tr>
<tr><td><code><i>  2088</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  2089</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2090</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //This&nbsp must&nbsp be&nbsp loaded&nbsp using&nbsp byte&nbsp addressing.&nbsp&nbsp The&nbsp source&nbsp pointer</code></td></tr>
<tr><td><code><i>  2091</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp may&nbsp not&nbsp be&nbsp word&nbsp aligned&nbsp for&nbsp the&nbsp 16&nbsp or&nbsp 32&nbsp bit&nbsp machines&nbsp resulting</code></td></tr>
<tr><td><code><i>  2092</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp in&nbsp an&nbsp address&nbsp error&nbsp on&nbsp the&nbsp dereference.</code></td></tr>
<tr><td><code><i>  2093</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].wCount.byte.LB&nbsp =&nbsp *(inPipes[0].pSrc.bRom+2);</code></td></tr>
<tr><td><code><i>  2094</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].wCount.byte.HB&nbsp =&nbsp *(inPipes[0].pSrc.bRom+3);</code></td></tr>
<tr><td><code><i>  2095</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2096</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2097</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2098</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.Val&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2099</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2100</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2101</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_DESCRIPTOR_STRING:</code></td></tr>
<tr><td><code><i>  2102</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //USB_NUM_STRING_DESCRIPTORS&nbsp was&nbsp introduced&nbsp as&nbsp optional&nbsp in&nbsp release&nbsp v2.3.&nbsp&nbsp In&nbsp v2.4&nbsp and</code></td></tr>
<tr><td><code><i>  2103</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp later&nbsp it&nbsp is&nbsp now&nbsp manditory.&nbsp&nbsp This&nbsp should&nbsp be&nbsp defined&nbsp in&nbsp usb_config.h&nbsp and&nbsp should</code></td></tr>
<tr><td><code><i>  2104</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp indicate&nbsp the&nbsp number&nbsp of&nbsp string&nbsp descriptors.</code></td></tr>
<tr><td><code><i>  2105</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.bDscIndex&lsaquo  USB_NUM_STRING_DESCRIPTORS)</code></td></tr>
<tr><td><code><i>  2106</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2107</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Get&nbsp a&nbsp pointer&nbsp to&nbsp the&nbsp String&nbsp descriptor&nbsp requested</code></td></tr>
<tr><td><code><i>  2108</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].pSrc.bRom&nbsp =&nbsp *(USB_SD_Ptr+SetupPkt.bDscIndex);</code></td></tr>
<tr><td><code><i>  2109</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp data&nbsp count</code></td></tr>
<tr><td><code><i>  2110</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].wCount.Val&nbsp =&nbsp *inPipes[0].pSrc.bRom;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2111</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2112</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)</code></td></tr>
<tr><td><code><i>  2113</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else&nbsp if(SetupPkt.bDscIndex&nbsp ==&nbsp MICROSOFT_OS_DESCRIPTOR_INDEX)</code></td></tr>
<tr><td><code><i>  2114</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2115</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Get&nbsp a&nbsp pointer&nbsp to&nbsp the&nbsp special&nbsp MS&nbsp OS&nbsp string&nbsp descriptor&nbsp requested</code></td></tr>
<tr><td><code><i>  2116</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].pSrc.bRom&nbsp =&nbsp (const&nbsp uint8_t*)&MSOSDescriptor;</code></td></tr>
<tr><td><code><i>  2117</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp data&nbsp count</code></td></tr>
<tr><td><code><i>  2118</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].wCount.Val&nbsp =&nbsp *inPipes[0].pSrc.bRom;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2119</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2120</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  2121</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2122</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2123</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.Val&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2124</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2125</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2126</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp default:</code></td></tr>
<tr><td><code><i>  2127</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.Val&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2128</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2129</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }//end&nbsp switch</code></td></tr>
<tr><td><code><i>  2130</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp if</code></td></tr>
<tr><td><code><i>  2131</i> </code></td><td><code>&nbsp }//end&nbsp USBStdGetDscHandler</code></td></tr>
<tr><td><code><i>  2132</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2133</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  2134</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBStdGetStatusHandler(void)</code></td></tr>
<tr><td><code><i>  2135</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2136</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2137</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2138</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2139</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2140</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2141</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2142</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2143</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2144</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp handles&nbsp the&nbsp standard&nbsp GET_STATUS&nbsp request</code></td></tr>
<tr><td><code><i>  2145</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2146</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2147</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>  2148</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBStdGetStatusHandler(void)</code></td></tr>
<tr><td><code><i>  2149</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  2150</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp CtrlTrfData[0]&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Initialize&nbsp content</code></td></tr>
<tr><td><code><i>  2151</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp CtrlTrfData[1]&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2152</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2153</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp switch(SetupPkt.Recipient)</code></td></tr>
<tr><td><code><i>  2154</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2155</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_SETUP_RECIPIENT_DEVICE_BITFIELD:</code></td></tr>
<tr><td><code><i>  2156</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  2157</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>  2158</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp [0]:&nbsp bit0:&nbsp Self-Powered&nbsp Status&nbsp [0]&nbsp Bus-Powered&nbsp [1]&nbsp Self-Powered</code></td></tr>
<tr><td><code><i>  2159</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp bit1:&nbsp RemoteWakeup&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp [0]&nbsp Disabled&nbsp&nbsp&nbsp&nbsp [1]&nbsp Enabled</code></td></tr>
<tr><td><code><i>  2160</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>  2161</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(self_power&nbsp ==&nbsp 1)&nbsp //&nbsp self_power&nbsp is&nbsp defined&nbsp in&nbsp HardwareProfile.h</code></td></tr>
<tr><td><code><i>  2162</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2163</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CtrlTrfData[0]|=0x01;</code></td></tr>
<tr><td><code><i>  2164</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2165</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2166</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(RemoteWakeup&nbsp ==&nbsp true)</code></td></tr>
<tr><td><code><i>  2167</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2168</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CtrlTrfData[0]|=0x02;</code></td></tr>
<tr><td><code><i>  2169</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2170</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2171</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:</code></td></tr>
<tr><td><code><i>  2172</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp No&nbsp data&nbsp to&nbsp update</code></td></tr>
<tr><td><code><i>  2173</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2174</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:</code></td></tr>
<tr><td><code><i>  2175</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  2176</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>  2177</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp [0]:&nbsp bit0:&nbsp Halt&nbsp Status&nbsp [0]&nbsp Not&nbsp Halted&nbsp [1]&nbsp Halted</code></td></tr>
<tr><td><code><i>  2178</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>  2179</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2180</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BDT_ENTRY&nbsp *p;</code></td></tr>
<tr><td><code><i>  2181</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2182</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.EPDir&nbsp ==&nbsp 0)</code></td></tr>
<tr><td><code><i>  2183</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2184</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p&nbsp =&nbsp (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];</code></td></tr>
<tr><td><code><i>  2185</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2186</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2187</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2188</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p&nbsp =&nbsp (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];</code></td></tr>
<tr><td><code><i>  2189</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2190</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2191</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if((p-&rsaquo  STAT.UOWN&nbsp ==&nbsp 1)&nbsp &&&nbsp (p-&rsaquo  STAT.BSTALL&nbsp ==&nbsp 1))</code></td></tr>
<tr><td><code><i>  2192</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CtrlTrfData[0]=0x01;&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp bit0</code></td></tr>
<tr><td><code><i>  2193</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2194</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2195</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp switch</code></td></tr>
<tr><td><code><i>  2196</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2197</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(inPipes[0].info.bits.busy&nbsp ==&nbsp 1)</code></td></tr>
<tr><td><code><i>  2198</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2199</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].pSrc.bRam&nbsp =&nbsp (uint8_t*)&CtrlTrfData;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp Source</code></td></tr>
<tr><td><code><i>  2200</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.ctrl_trf_mem&nbsp =&nbsp USB_EP0_RAM;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp memory&nbsp type</code></td></tr>
<tr><td><code><i>  2201</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].wCount.v[0]&nbsp =&nbsp 2;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp data&nbsp count</code></td></tr>
<tr><td><code><i>  2202</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp if(...)</code></td></tr>
<tr><td><code><i>  2203</i> </code></td><td><code>&nbsp }//end&nbsp USBStdGetStatusHandler</code></td></tr>
<tr><td><code><i>  2204</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2205</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  2206</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBStallHandler(void)</code></td></tr>
<tr><td><code><i>  2207</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2208</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2209</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2210</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2211</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2212</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2213</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2214</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2215</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2216</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp handles&nbsp the&nbsp event&nbsp of&nbsp a&nbsp STALL&nbsp </code></td></tr>
<tr><td><code><i>  2217</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp occuring&nbsp on&nbsp the&nbsp bus</code></td></tr>
<tr><td><code><i>  2218</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2219</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2220</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>  2221</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBStallHandler(void)</code></td></tr>
<tr><td><code><i>  2222</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  2223</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>  2224</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Does&nbsp not&nbsp really&nbsp have&nbsp to&nbsp do&nbsp anything&nbsp here,</code></td></tr>
<tr><td><code><i>  2225</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp even&nbsp for&nbsp the&nbsp control&nbsp endpoint.</code></td></tr>
<tr><td><code><i>  2226</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp All&nbsp BDs&nbsp of&nbsp Endpoint&nbsp 0&nbsp are&nbsp owned&nbsp by&nbsp SIE&nbsp right&nbsp now,</code></td></tr>
<tr><td><code><i>  2227</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp but&nbsp once&nbsp a&nbsp Setup&nbsp Transaction&nbsp is&nbsp received,&nbsp the&nbsp ownership</code></td></tr>
<tr><td><code><i>  2228</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp for&nbsp EP0_OUT&nbsp will&nbsp be&nbsp returned&nbsp to&nbsp CPU.</code></td></tr>
<tr><td><code><i>  2229</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp When&nbsp the&nbsp Setup&nbsp Transaction&nbsp is&nbsp serviced,&nbsp the&nbsp ownership</code></td></tr>
<tr><td><code><i>  2230</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp for&nbsp EP0_IN&nbsp will&nbsp then&nbsp be&nbsp forced&nbsp back&nbsp to&nbsp CPU&nbsp by&nbsp firmware.</code></td></tr>
<tr><td><code><i>  2231</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>  2232</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2233</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(U1EP0bits.EPSTALL&nbsp ==&nbsp 1)</code></td></tr>
<tr><td><code><i>  2234</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2235</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp UOWN&nbsp -&nbsp if&nbsp 0,&nbsp owned&nbsp by&nbsp CPU,&nbsp if&nbsp 1,&nbsp owned&nbsp by&nbsp SIE</code></td></tr>
<tr><td><code><i>  2236</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if((pBDTEntryEP0OutCurrent-&rsaquo  STAT.Val&nbsp ==&nbsp _USIE)&nbsp &&&nbsp (pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp ==&nbsp (_USIE|_BSTALL)))</code></td></tr>
<tr><td><code><i>  2237</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2238</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp ep0Bo&nbsp to&nbsp stall&nbsp also</code></td></tr>
<tr><td><code><i>  2239</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutCurrent-&rsaquo  STAT.Val&nbsp =&nbsp _DAT0|(_DTSEN&nbsp &&nbsp _DTS_CHECKING_ENABLED)|_BSTALL;</code></td></tr>
<tr><td><code><i>  2240</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutCurrent-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  2241</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }//end&nbsp if</code></td></tr>
<tr><td><code><i>  2242</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1EP0bits.EPSTALL&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Clear&nbsp stall&nbsp status</code></td></tr>
<tr><td><code><i>  2243</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp if</code></td></tr>
<tr><td><code><i>  2244</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2245</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);</code></td></tr>
<tr><td><code><i>  2246</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>  2247</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2248</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  2249</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBSuspend(void)</code></td></tr>
<tr><td><code><i>  2250</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2251</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2252</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2253</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2254</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2255</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2256</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2257</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2258</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2259</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp handles&nbsp if&nbsp the&nbsp host&nbsp tries&nbsp to&nbsp </code></td></tr>
<tr><td><code><i>  2260</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp suspend&nbsp the&nbsp device</code></td></tr>
<tr><td><code><i>  2261</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2262</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2263</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>  2264</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBSuspend(void)</code></td></tr>
<tr><td><code><i>  2265</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  2266</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>  2267</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp NOTE:&nbsp Do&nbsp not&nbsp clear&nbsp UIRbits.ACTVIF&nbsp here!</code></td></tr>
<tr><td><code><i>  2268</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Reason:</code></td></tr>
<tr><td><code><i>  2269</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp ACTVIF&nbsp is&nbsp only&nbsp generated&nbsp once&nbsp an&nbsp IDLEIF&nbsp has&nbsp been&nbsp generated.</code></td></tr>
<tr><td><code><i>  2270</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp This&nbsp is&nbsp a&nbsp 1:1&nbsp ratio&nbsp interrupt&nbsp generation.</code></td></tr>
<tr><td><code><i>  2271</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp For&nbsp every&nbsp IDLEIF,&nbsp there&nbsp will&nbsp be&nbsp only&nbsp one&nbsp ACTVIF&nbsp regardless&nbsp of</code></td></tr>
<tr><td><code><i>  2272</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp the&nbsp number&nbsp of&nbsp subsequent&nbsp bus&nbsp transitions.</code></td></tr>
<tr><td><code><i>  2273</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>  2274</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp If&nbsp the&nbsp ACTIF&nbsp is&nbsp cleared&nbsp here,&nbsp a&nbsp problem&nbsp could&nbsp occur&nbsp when:</code></td></tr>
<tr><td><code><i>  2275</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp [&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IDLE&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ][bus&nbsp activity&nbsp -&rsaquo  </code></td></tr>
<tr><td><code><i>  2276</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&lsaquo  ---&nbsp 3&nbsp ms&nbsp -----&rsaquo &nbsp&nbsp&nbsp&nbsp&nbsp ^</code></td></tr>
<tr><td><code><i>  2277</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ^&nbsp&nbsp&nbsp&nbsp&nbsp ACTVIF=1</code></td></tr>
<tr><td><code><i>  2278</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IDLEIF=1</code></td></tr>
<tr><td><code><i>  2279</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp #&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #&nbsp&nbsp&nbsp (#=Program&nbsp polling&nbsp flags)</code></td></tr>
<tr><td><code><i>  2280</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ^</code></td></tr>
<tr><td><code><i>  2281</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp polling&nbsp loop&nbsp will&nbsp see&nbsp both</code></td></tr>
<tr><td><code><i>  2282</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp IDLEIF=1&nbsp and&nbsp ACTVIF=1.</code></td></tr>
<tr><td><code><i>  2283</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp However,&nbsp the&nbsp program&nbsp services&nbsp IDLEIF&nbsp first</code></td></tr>
<tr><td><code><i>  2284</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp because&nbsp ACTIVIE=0.</code></td></tr>
<tr><td><code><i>  2285</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp If&nbsp this&nbsp routine&nbsp clears&nbsp the&nbsp only&nbsp ACTIVIF,</code></td></tr>
<tr><td><code><i>  2286</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp then&nbsp it&nbsp can&nbsp never&nbsp get&nbsp out&nbsp of&nbsp the&nbsp suspend</code></td></tr>
<tr><td><code><i>  2287</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp mode.</code></td></tr>
<tr><td><code><i>  2288</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>  2289</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBActivityIE&nbsp =&nbsp 1;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Enable&nbsp bus&nbsp activity&nbsp interrupt</code></td></tr>
<tr><td><code><i>  2290</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);</code></td></tr>
<tr><td><code><i>  2291</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2292</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp defined(__18CXX)&nbsp ||&nbsp defined(_PIC14E)&nbsp ||&nbsp defined(__XC8)</code></td></tr>
<tr><td><code><i>  2293</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1CONbits.SUSPND&nbsp =&nbsp 1;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Put&nbsp USB&nbsp module&nbsp in&nbsp power&nbsp conserve</code></td></tr>
<tr><td><code><i>  2294</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp mode,&nbsp SIE&nbsp clock&nbsp inactive</code></td></tr>
<tr><td><code><i>  2295</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  2296</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBBusIsSuspended&nbsp =&nbsp true;</code></td></tr>
<tr><td><code><i>  2297</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBTicksSinceSuspendEnd&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2298</i> </code></td><td><code>&nbsp &nbsp </code></td></tr>
<tr><td><code><i>  2299</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>  2300</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp At&nbsp this&nbsp point&nbsp the&nbsp PIC&nbsp can&nbsp go&nbsp into&nbsp sleep,idle,&nbsp or</code></td></tr>
<tr><td><code><i>  2301</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp switch&nbsp to&nbsp a&nbsp slower&nbsp clock,&nbsp etc.&nbsp&nbsp This&nbsp should&nbsp be&nbsp done&nbsp in&nbsp the</code></td></tr>
<tr><td><code><i>  2302</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp USBCBSuspend()&nbsp if&nbsp necessary.</code></td></tr>
<tr><td><code><i>  2303</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>  2304</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);</code></td></tr>
<tr><td><code><i>  2305</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>  2306</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2307</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  2308</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBWakeFromSuspend(void)</code></td></tr>
<tr><td><code><i>  2309</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2310</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2311</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2312</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2313</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2314</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2315</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2316</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2317</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2318</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:</code></td></tr>
<tr><td><code><i>  2319</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2320</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2321</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>  2322</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBWakeFromSuspend(void)</code></td></tr>
<tr><td><code><i>  2323</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  2324</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBBusIsSuspended&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  2325</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2326</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>  2327</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp If&nbsp using&nbsp clock&nbsp switching,&nbsp the&nbsp place&nbsp to&nbsp restore&nbsp the&nbsp original</code></td></tr>
<tr><td><code><i>  2328</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp microcontroller&nbsp core&nbsp clock&nbsp frequency&nbsp is&nbsp in&nbsp the&nbsp USBCBWakeFromSuspend()&nbsp callback</code></td></tr>
<tr><td><code><i>  2329</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>  2330</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);</code></td></tr>
<tr><td><code><i>  2331</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2332</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp defined(__18CXX)&nbsp ||&nbsp defined(_PIC14E)&nbsp ||&nbsp defined(__XC8)</code></td></tr>
<tr><td><code><i>  2333</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //To&nbsp avoid&nbsp improperly&nbsp clocking&nbsp the&nbsp USB&nbsp module,&nbsp make&nbsp sure&nbsp the&nbsp oscillator</code></td></tr>
<tr><td><code><i>  2334</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //settings&nbsp are&nbsp consistant&nbsp with&nbsp USB&nbsp operation&nbsp before&nbsp clearing&nbsp the&nbsp SUSPND&nbsp bit.</code></td></tr>
<tr><td><code><i>  2335</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Make&nbsp sure&nbsp the&nbsp correct&nbsp oscillator&nbsp settings&nbsp are&nbsp selected&nbsp in&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  2336</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)"&nbsp handler.</code></td></tr>
<tr><td><code><i>  2337</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1CONbits.SUSPND&nbsp =&nbsp 0;&nbsp&nbsp&nbsp //&nbsp Bring&nbsp USB&nbsp module&nbsp out&nbsp of&nbsp power&nbsp conserve</code></td></tr>
<tr><td><code><i>  2338</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp mode.</code></td></tr>
<tr><td><code><i>  2339</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  2340</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2341</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2342</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBActivityIE&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2343</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2344</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  2345</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Bug&nbsp Fix:&nbsp Feb&nbsp 26,&nbsp 2007&nbsp v2.1</code></td></tr>
<tr><td><code><i>  2346</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp *********************************************************************</code></td></tr>
<tr><td><code><i>  2347</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp The&nbsp ACTVIF&nbsp bit&nbsp cannot&nbsp be&nbsp cleared&nbsp immediately&nbsp after&nbsp the&nbsp USB&nbsp module&nbsp wakes</code></td></tr>
<tr><td><code><i>  2348</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp up&nbsp from&nbsp Suspend&nbsp or&nbsp while&nbsp the&nbsp USB&nbsp module&nbsp is&nbsp suspended.&nbsp A&nbsp few&nbsp clock&nbsp cycles</code></td></tr>
<tr><td><code><i>  2349</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp are&nbsp required&nbsp to&nbsp synchronize&nbsp the&nbsp internal&nbsp hardware&nbsp state&nbsp machine&nbsp before</code></td></tr>
<tr><td><code><i>  2350</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp ACTIVIF&nbsp bit&nbsp can&nbsp be&nbsp cleared&nbsp by&nbsp firmware.&nbsp Clearing&nbsp the&nbsp ACTVIF&nbsp bit</code></td></tr>
<tr><td><code><i>  2351</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp before&nbsp the&nbsp internal&nbsp hardware&nbsp is&nbsp synchronized&nbsp may&nbsp not&nbsp have&nbsp an&nbsp effect&nbsp on</code></td></tr>
<tr><td><code><i>  2352</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp value&nbsp of&nbsp ACTVIF.&nbsp Additonally,&nbsp if&nbsp the&nbsp USB&nbsp module&nbsp uses&nbsp the&nbsp clock&nbsp from</code></td></tr>
<tr><td><code><i>  2353</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp 96&nbsp MHz&nbsp PLL&nbsp source,&nbsp then&nbsp after&nbsp clearing&nbsp the&nbsp SUSPND&nbsp bit,&nbsp the&nbsp USB</code></td></tr>
<tr><td><code><i>  2354</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp module&nbsp may&nbsp not&nbsp be&nbsp immediately&nbsp operational&nbsp while&nbsp waiting&nbsp for&nbsp the&nbsp 96&nbsp MHz</code></td></tr>
<tr><td><code><i>  2355</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp PLL&nbsp to&nbsp lock.</code></td></tr>
<tr><td><code><i>  2356</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp ********************************************************************/</code></td></tr>
<tr><td><code><i>  2357</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2358</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp UIRbits.ACTVIF&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Removed</code></td></tr>
<tr><td><code><i>  2359</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp defined(__18CXX)&nbsp ||&nbsp defined(__XC8)</code></td></tr>
<tr><td><code><i>  2360</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp while(USBActivityIF)</code></td></tr>
<tr><td><code><i>  2361</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  2362</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2363</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);</code></td></tr>
<tr><td><code><i>  2364</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp //&nbsp Added</code></td></tr>
<tr><td><code><i>  2365</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2366</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBTicksSinceSuspendEnd&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2367</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2368</i> </code></td><td><code>&nbsp }//end&nbsp USBWakeFromSuspend</code></td></tr>
<tr><td><code><i>  2369</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2370</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  2371</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBCtrlEPService(void)</code></td></tr>
<tr><td><code><i>  2372</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2373</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp USTAT&nbsp is&nbsp loaded&nbsp with&nbsp a&nbsp valid&nbsp endpoint&nbsp address.</code></td></tr>
<tr><td><code><i>  2374</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2375</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2376</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2377</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2378</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2379</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2380</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2381</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlEPService&nbsp checks&nbsp for&nbsp three&nbsp transaction</code></td></tr>
<tr><td><code><i>  2382</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp types&nbsp that&nbsp it&nbsp knows&nbsp how&nbsp to&nbsp service&nbsp and&nbsp services</code></td></tr>
<tr><td><code><i>  2383</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp them:</code></td></tr>
<tr><td><code><i>  2384</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 1.&nbsp EP0&nbsp SETUP</code></td></tr>
<tr><td><code><i>  2385</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 2.&nbsp EP0&nbsp OUT</code></td></tr>
<tr><td><code><i>  2386</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 3.&nbsp EP0&nbsp IN</code></td></tr>
<tr><td><code><i>  2387</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp It&nbsp ignores&nbsp all&nbsp other&nbsp types&nbsp (i.e.&nbsp EP1,&nbsp EP2,&nbsp etc.)</code></td></tr>
<tr><td><code><i>  2388</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2389</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2390</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>  2391</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlEPService(void)</code></td></tr>
<tr><td><code><i>  2392</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  2393</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //If&nbsp we&nbsp get&nbsp to&nbsp here,&nbsp that&nbsp means&nbsp a&nbsp successful&nbsp transaction&nbsp has&nbsp just&nbsp occurred&nbsp </code></td></tr>
<tr><td><code><i>  2394</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //on&nbsp EP0.&nbsp&nbsp This&nbsp means&nbsp "progress"&nbsp has&nbsp occurred&nbsp in&nbsp the&nbsp currently&nbsp pending&nbsp </code></td></tr>
<tr><td><code><i>  2395</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //control&nbsp transfer,&nbsp so&nbsp we&nbsp should&nbsp re-initialize&nbsp our&nbsp timeout&nbsp counter.</code></td></tr>
<tr><td><code><i>  2396</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)</code></td></tr>
<tr><td><code><i>  2397</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStatusStageTimeoutCounter&nbsp =&nbsp USB_STATUS_STAGE_TIMEOUT;</code></td></tr>
<tr><td><code><i>  2398</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  2399</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2400</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Check&nbsp if&nbsp the&nbsp last&nbsp transaction&nbsp was&nbsp on&nbsp EP0&nbsp OUT&nbsp endpoint&nbsp (of&nbsp any&nbsp kind,&nbsp to&nbsp either&nbsp the&nbsp even&nbsp or&nbsp odd&nbsp buffer&nbsp if&nbsp ping&nbsp pong&nbsp buffers&nbsp used)</code></td></tr>
<tr><td><code><i>  2401</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if((USTATcopy.Val&nbsp &&nbsp USTAT_EP0_PP_MASK)&nbsp ==&nbsp USTAT_EP0_OUT_EVEN)</code></td></tr>
<tr><td><code><i>  2402</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2403</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Point&nbsp to&nbsp the&nbsp EP0&nbsp OUT&nbsp buffer&nbsp of&nbsp the&nbsp buffer&nbsp that&nbsp arrived</code></td></tr>
<tr><td><code><i>  2404</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined&nbsp (_PIC14E)&nbsp ||&nbsp defined(__18CXX)&nbsp ||&nbsp defined(__XC8)</code></td></tr>
<tr><td><code><i>  2405</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutCurrent&nbsp =&nbsp (volatile&nbsp BDT_ENTRY*)&BDT[(USTATcopy.Val&nbsp &&nbsp USTAT_EP_MASK)&rsaquo &rsaquo  1];</code></td></tr>
<tr><td><code><i>  2406</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #elif&nbsp defined(__C30__)&nbsp ||&nbsp defined(__C32__)&nbsp ||&nbsp defined&nbsp __XC16__</code></td></tr>
<tr><td><code><i>  2407</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutCurrent&nbsp =&nbsp (volatile&nbsp BDT_ENTRY*)&BDT[(USTATcopy.Val&nbsp &&nbsp USTAT_EP_MASK)&rsaquo &rsaquo  2];</code></td></tr>
<tr><td><code><i>  2408</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #else</code></td></tr>
<tr><td><code><i>  2409</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #error&nbsp "unimplemented"</code></td></tr>
<tr><td><code><i>  2410</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  2411</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2412</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Set&nbsp the&nbsp next&nbsp out&nbsp to&nbsp the&nbsp current&nbsp out&nbsp packet</code></td></tr>
<tr><td><code><i>  2413</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext&nbsp =&nbsp pBDTEntryEP0OutCurrent;</code></td></tr>
<tr><td><code><i>  2414</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Toggle&nbsp it&nbsp to&nbsp the&nbsp next&nbsp ping&nbsp pong&nbsp buffer&nbsp (if&nbsp applicable)</code></td></tr>
<tr><td><code><i>  2415</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ((uint8_t_VAL*)&pBDTEntryEP0OutNext)-&rsaquo  Val&nbsp ^=&nbsp USB_NEXT_EP0_OUT_PING_PONG;</code></td></tr>
<tr><td><code><i>  2416</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2417</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //If&nbsp the&nbsp current&nbsp EP0&nbsp OUT&nbsp buffer&nbsp has&nbsp a&nbsp SETUP&nbsp packet</code></td></tr>
<tr><td><code><i>  2418</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(pBDTEntryEP0OutCurrent-&rsaquo  STAT.PID&nbsp ==&nbsp PID_SETUP)</code></td></tr>
<tr><td><code><i>  2419</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2420</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp unsigned&nbsp char&nbsp setup_cnt;</code></td></tr>
<tr><td><code><i>  2421</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2422</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //The&nbsp SETUP&nbsp transaction&nbsp data&nbsp may&nbsp have&nbsp gone&nbsp into&nbsp the&nbsp the&nbsp CtrlTrfData&nbsp </code></td></tr>
<tr><td><code><i>  2423</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //buffer,&nbsp or&nbsp elsewhere,&nbsp depending&nbsp upon&nbsp how&nbsp the&nbsp BDT&nbsp was&nbsp prepared</code></td></tr>
<tr><td><code><i>  2424</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //before&nbsp the&nbsp transaction.&nbsp&nbsp Therefore,&nbsp we&nbsp should&nbsp copy&nbsp the&nbsp data&nbsp to&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  2425</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //SetupPkt&nbsp buffer&nbsp so&nbsp it&nbsp can&nbsp be&nbsp processed&nbsp correctly&nbsp by&nbsp USBCtrlTrfSetupHandler().  &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2426</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp for(setup_cnt&nbsp =&nbsp 0;&nbsp setup_cnt&nbsp&lsaquo &nbsp 8u;&nbsp setup_cnt++)&nbsp //SETUP&nbsp data&nbsp packets&nbsp always&nbsp contain&nbsp exactly&nbsp 8&nbsp bytes.</code></td></tr>
<tr><td><code><i>  2427</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2428</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *(uint8_t*)((uint8_t*)&SetupPkt&nbsp +&nbsp setup_cnt)&nbsp =&nbsp *(uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent-&rsaquo  ADR);</code></td></tr>
<tr><td><code><i>  2429</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutCurrent-&rsaquo  ADR++;</code></td></tr>
<tr><td><code><i>  2430</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2431</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutCurrent-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(&SetupPkt);</code></td></tr>
<tr><td><code><i>  2432</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2433</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Handle&nbsp the&nbsp control&nbsp transfer&nbsp (parse&nbsp the&nbsp 8-byte&nbsp SETUP&nbsp command&nbsp and&nbsp figure&nbsp out&nbsp what&nbsp to&nbsp do)</code></td></tr>
<tr><td><code><i>  2434</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlTrfSetupHandler();</code></td></tr>
<tr><td><code><i>  2435</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2436</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2437</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2438</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Handle&nbsp the&nbsp DATA&nbsp transfer</code></td></tr>
<tr><td><code><i>  2439</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlTrfOutHandler();</code></td></tr>
<tr><td><code><i>  2440</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2441</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2442</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else&nbsp if((USTATcopy.Val&nbsp &&nbsp USTAT_EP0_PP_MASK)&nbsp ==&nbsp USTAT_EP0_IN)</code></td></tr>
<tr><td><code><i>  2443</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2444</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Otherwise&nbsp the&nbsp transmission&nbsp was&nbsp and&nbsp EP0&nbsp IN</code></td></tr>
<tr><td><code><i>  2445</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp so&nbsp take&nbsp care&nbsp of&nbsp the&nbsp IN&nbsp transfer</code></td></tr>
<tr><td><code><i>  2446</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlTrfInHandler();</code></td></tr>
<tr><td><code><i>  2447</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2448</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2449</i> </code></td><td><code>&nbsp }//end&nbsp USBCtrlEPService</code></td></tr>
<tr><td><code><i>  2450</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2451</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  2452</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBCtrlTrfSetupHandler(void)</code></td></tr>
<tr><td><code><i>  2453</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2454</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp SetupPkt&nbsp buffer&nbsp is&nbsp loaded&nbsp with&nbsp valid&nbsp USB&nbsp Setup&nbsp Data</code></td></tr>
<tr><td><code><i>  2455</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2456</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2457</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2458</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2459</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2460</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2461</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2462</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp is&nbsp a&nbsp task&nbsp dispatcher&nbsp and&nbsp has&nbsp 3&nbsp stages.</code></td></tr>
<tr><td><code><i>  2463</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 1.&nbsp It&nbsp initializes&nbsp the&nbsp control&nbsp transfer&nbsp state&nbsp machine.</code></td></tr>
<tr><td><code><i>  2464</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 2.&nbsp It&nbsp calls&nbsp on&nbsp each&nbsp of&nbsp the&nbsp module&nbsp that&nbsp may&nbsp know&nbsp how&nbsp to</code></td></tr>
<tr><td><code><i>  2465</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp service&nbsp the&nbsp Setup&nbsp Request&nbsp from&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>  2466</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Module&nbsp Example:&nbsp USBD,&nbsp HID,&nbsp CDC,&nbsp MSD,&nbsp ...</code></td></tr>
<tr><td><code><i>  2467</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp A&nbsp callback&nbsp function,&nbsp USBCBCheckOtherReq(),</code></td></tr>
<tr><td><code><i>  2468</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp is&nbsp required&nbsp to&nbsp call&nbsp other&nbsp module&nbsp handlers.</code></td></tr>
<tr><td><code><i>  2469</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 3.&nbsp Once&nbsp each&nbsp of&nbsp the&nbsp modules&nbsp has&nbsp had&nbsp a&nbsp chance&nbsp to&nbsp check&nbsp if</code></td></tr>
<tr><td><code><i>  2470</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp it&nbsp is&nbsp responsible&nbsp for&nbsp servicing&nbsp the&nbsp request,&nbsp stage&nbsp 3</code></td></tr>
<tr><td><code><i>  2471</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp then&nbsp checks&nbsp direction&nbsp of&nbsp the&nbsp transfer&nbsp to&nbsp determine&nbsp how</code></td></tr>
<tr><td><code><i>  2472</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp to&nbsp prepare&nbsp EP0&nbsp for&nbsp the&nbsp control&nbsp transfer.</code></td></tr>
<tr><td><code><i>  2473</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Refer&nbsp to&nbsp USBCtrlEPServiceComplete()&nbsp for&nbsp more&nbsp details.</code></td></tr>
<tr><td><code><i>  2474</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2475</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Microchip&nbsp USB&nbsp Firmware&nbsp has&nbsp three&nbsp different&nbsp states&nbsp for</code></td></tr>
<tr><td><code><i>  2476</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp control&nbsp transfer&nbsp state&nbsp machine:</code></td></tr>
<tr><td><code><i>  2477</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 1.&nbsp WAIT_SETUP</code></td></tr>
<tr><td><code><i>  2478</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 2.&nbsp CTRL_TRF_TX&nbsp (device&nbsp sends&nbsp data&nbsp to&nbsp host&nbsp through&nbsp IN&nbsp transactions)</code></td></tr>
<tr><td><code><i>  2479</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp 3.&nbsp CTRL_TRF_RX&nbsp (device&nbsp receives&nbsp data&nbsp from&nbsp host&nbsp through&nbsp OUT&nbsp transactions)</code></td></tr>
<tr><td><code><i>  2480</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Refer&nbsp to&nbsp firmware&nbsp manual&nbsp to&nbsp find&nbsp out&nbsp how&nbsp one&nbsp state</code></td></tr>
<tr><td><code><i>  2481</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp is&nbsp transitioned&nbsp to&nbsp another.</code></td></tr>
<tr><td><code><i>  2482</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2483</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp A&nbsp Control&nbsp Transfer&nbsp is&nbsp composed&nbsp of&nbsp many&nbsp USB&nbsp transactions.</code></td></tr>
<tr><td><code><i>  2484</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp When&nbsp transferring&nbsp data&nbsp over&nbsp multiple&nbsp transactions,</code></td></tr>
<tr><td><code><i>  2485</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp it&nbsp is&nbsp important&nbsp to&nbsp keep&nbsp track&nbsp of&nbsp data&nbsp source,&nbsp data</code></td></tr>
<tr><td><code><i>  2486</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp destination,&nbsp and&nbsp data&nbsp count.&nbsp These&nbsp three&nbsp parameters&nbsp are</code></td></tr>
<tr><td><code><i>  2487</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp stored&nbsp in&nbsp pSrc,pDst,&nbsp and&nbsp wCount.&nbsp A&nbsp flag&nbsp is&nbsp used&nbsp to</code></td></tr>
<tr><td><code><i>  2488</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp note&nbsp if&nbsp the&nbsp data&nbsp source&nbsp is&nbsp from&nbsp const&nbsp or&nbsp RAM.</code></td></tr>
<tr><td><code><i>  2489</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2490</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>  2491</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlTrfSetupHandler(void)</code></td></tr>
<tr><td><code><i>  2492</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  2493</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //--------------------------------------------------------------------------</code></td></tr>
<tr><td><code><i>  2494</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //1.&nbsp Re-initialize&nbsp state&nbsp tracking&nbsp variables&nbsp related&nbsp to&nbsp control&nbsp transfers.</code></td></tr>
<tr><td><code><i>  2495</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //--------------------------------------------------------------------------</code></td></tr>
<tr><td><code><i>  2496</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp shortPacketStatus&nbsp =&nbsp SHORT_PKT_NOT_USED;&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2497</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeferStatusStagePacket&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  2498</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeferINDataStagePackets&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  2499</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBDeferOUTDataStagePackets&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  2500</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp BothEP0OutUOWNsSet&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  2501</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp controlTransferState&nbsp =&nbsp WAIT_SETUP;</code></td></tr>
<tr><td><code><i>  2502</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2503</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Abandon&nbsp any&nbsp previous&nbsp control&nbsp transfers&nbsp that&nbsp might&nbsp have&nbsp been&nbsp using&nbsp EP0.</code></td></tr>
<tr><td><code><i>  2504</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Ordinarily,&nbsp nothing&nbsp actually&nbsp needs&nbsp abandoning,&nbsp since&nbsp the&nbsp previous&nbsp control</code></td></tr>
<tr><td><code><i>  2505</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //transfer&nbsp would&nbsp have&nbsp completed&nbsp successfully&nbsp prior&nbsp to&nbsp the&nbsp host&nbsp sending&nbsp the&nbsp next</code></td></tr>
<tr><td><code><i>  2506</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //SETUP&nbsp packet.&nbsp&nbsp However,&nbsp in&nbsp a&nbsp timeout&nbsp error&nbsp case,&nbsp or&nbsp after&nbsp an&nbsp EP0&nbsp STALL&nbsp event,</code></td></tr>
<tr><td><code><i>  2507</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //one&nbsp or&nbsp more&nbsp UOWN&nbsp bits&nbsp might&nbsp still&nbsp be&nbsp set.&nbsp&nbsp If&nbsp so,&nbsp we&nbsp should&nbsp clear&nbsp the&nbsp UOWN&nbsp bits,</code></td></tr>
<tr><td><code><i>  2508</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //so&nbsp the&nbsp EP0&nbsp IN/OUT&nbsp endpoints&nbsp are&nbsp in&nbsp a&nbsp known&nbsp inactive&nbsp state,&nbsp ready&nbsp for&nbsp re-arming</code></td></tr>
<tr><td><code><i>  2509</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //by&nbsp the&nbsp class&nbsp request&nbsp handler&nbsp that&nbsp will&nbsp be&nbsp called&nbsp next.</code></td></tr>
<tr><td><code><i>  2510</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp &=&nbsp ~(_USIE);&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2511</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp ((uint8_t_VAL*)&pBDTEntryIn[0])-&rsaquo  Val&nbsp ^=&nbsp USB_NEXT_EP0_IN_PING_PONG;</code></td></tr>
<tr><td><code><i>  2512</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp &=&nbsp ~(_USIE);&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2513</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp ((uint8_t_VAL*)&pBDTEntryIn[0])-&rsaquo  Val&nbsp ^=&nbsp USB_NEXT_EP0_IN_PING_PONG;</code></td></tr>
<tr><td><code><i>  2514</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp &=&nbsp ~(_USIE);&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2515</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2516</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp inPipes[0].info.Val&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2517</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp inPipes[0].wCount.Val&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2518</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp outPipes[0].info.Val&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2519</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp outPipes[0].wCount.Val&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2520</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2521</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2522</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //--------------------------------------------------------------------------</code></td></tr>
<tr><td><code><i>  2523</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //2.&nbsp Now&nbsp find&nbsp out&nbsp what&nbsp was&nbsp in&nbsp the&nbsp SETUP&nbsp packet,&nbsp and&nbsp begin&nbsp handling&nbsp the&nbsp request.</code></td></tr>
<tr><td><code><i>  2524</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //--------------------------------------------------------------------------</code></td></tr>
<tr><td><code><i>  2525</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBCheckStdRequest();&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Check&nbsp for&nbsp standard&nbsp USB&nbsp "Chapter&nbsp 9"&nbsp requests.</code></td></tr>
<tr><td><code><i>  2526</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0);&nbsp //Check&nbsp for&nbsp USB&nbsp device&nbsp class&nbsp specific&nbsp requests</code></td></tr>
<tr><td><code><i>  2527</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2528</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2529</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //--------------------------------------------------------------------------</code></td></tr>
<tr><td><code><i>  2530</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //3.&nbsp Re-arm&nbsp EP0&nbsp IN&nbsp and&nbsp EP0&nbsp OUT&nbsp endpoints,&nbsp based&nbsp on&nbsp the&nbsp control&nbsp transfer&nbsp in&nbsp </code></td></tr>
<tr><td><code><i>  2531</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp progress.&nbsp&nbsp If&nbsp one&nbsp of&nbsp the&nbsp above&nbsp handlers&nbsp (in&nbsp step&nbsp 2)&nbsp knew&nbsp how&nbsp to&nbsp process</code></td></tr>
<tr><td><code><i>  2532</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp the&nbsp request,&nbsp it&nbsp will&nbsp have&nbsp set&nbsp one&nbsp of&nbsp the&nbsp inPipes[0].info.bits.busy&nbsp or</code></td></tr>
<tr><td><code><i>  2533</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp outPipes[0].info.bits.busy&nbsp flags&nbsp =&nbsp 1.&nbsp&nbsp This&nbsp lets&nbsp the</code></td></tr>
<tr><td><code><i>  2534</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp USBCtrlEPServiceComplete()&nbsp function&nbsp know&nbsp how&nbsp and&nbsp which&nbsp endpoints&nbsp to&nbsp </code></td></tr>
<tr><td><code><i>  2535</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp arm.&nbsp&nbsp If&nbsp both&nbsp info.bits.busy&nbsp flags&nbsp are&nbsp =&nbsp 0,&nbsp then&nbsp no&nbsp one&nbsp knew&nbsp how&nbsp to</code></td></tr>
<tr><td><code><i>  2536</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp process&nbsp the&nbsp request.&nbsp&nbsp In&nbsp this&nbsp case,&nbsp the&nbsp default&nbsp behavior&nbsp will&nbsp be&nbsp to</code></td></tr>
<tr><td><code><i>  2537</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp&nbsp perform&nbsp protocol&nbsp STALL&nbsp on&nbsp EP0.</code></td></tr>
<tr><td><code><i>  2538</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //--------------------------------------------------------------------------&nbsp </code></td></tr>
<tr><td><code><i>  2539</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBCtrlEPServiceComplete();</code></td></tr>
<tr><td><code><i>  2540</i> </code></td><td><code>&nbsp }//end&nbsp USBCtrlTrfSetupHandler</code></td></tr>
<tr><td><code><i>  2541</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2542</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2543</i> </code></td><td><code>&nbsp /******************************************************************************</code></td></tr>
<tr><td><code><i>  2544</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBCtrlTrfOutHandler(void)</code></td></tr>
<tr><td><code><i>  2545</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2546</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2547</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2548</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2549</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2550</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2551</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2552</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2553</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2554</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp handles&nbsp an&nbsp OUT&nbsp transaction&nbsp according&nbsp to</code></td></tr>
<tr><td><code><i>  2555</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp which&nbsp control&nbsp transfer&nbsp state&nbsp is&nbsp currently&nbsp active.</code></td></tr>
<tr><td><code><i>  2556</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2557</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Note&nbsp that&nbsp if&nbsp the&nbsp the&nbsp control&nbsp transfer&nbsp was&nbsp from</code></td></tr>
<tr><td><code><i>  2558</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp host&nbsp to&nbsp device,&nbsp the&nbsp session&nbsp owner&nbsp should&nbsp be&nbsp notified</code></td></tr>
<tr><td><code><i>  2559</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp at&nbsp the&nbsp end&nbsp of&nbsp each&nbsp OUT&nbsp transaction&nbsp to&nbsp service&nbsp the</code></td></tr>
<tr><td><code><i>  2560</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp received&nbsp data.</code></td></tr>
<tr><td><code><i>  2561</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2562</i> </code></td><td><code>&nbsp &nbsp *****************************************************************************/</code></td></tr>
<tr><td><code><i>  2563</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlTrfOutHandler(void)</code></td></tr>
<tr><td><code><i>  2564</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  2565</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(controlTransferState&nbsp ==&nbsp CTRL_TRF_RX)</code></td></tr>
<tr><td><code><i>  2566</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2567</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlTrfRxService();&nbsp //Copies&nbsp the&nbsp newly&nbsp received&nbsp data&nbsp into&nbsp the&nbsp appropriate&nbsp buffer&nbsp and&nbsp configures&nbsp EP0&nbsp OUT&nbsp for&nbsp next&nbsp transaction.</code></td></tr>
<tr><td><code><i>  2568</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2569</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else&nbsp //In&nbsp this&nbsp case&nbsp the&nbsp last&nbsp OUT&nbsp transaction&nbsp must&nbsp have&nbsp been&nbsp a&nbsp status&nbsp stage&nbsp of&nbsp a&nbsp CTRL_TRF_TX&nbsp (&lsaquo  setup&rsaquo &lsaquo  in&rsaquo &lsaquo  in&rsaquo  ...&lsaquo  OUT&rsaquo &nbsp&nbsp&lsaquo  --&nbsp this&nbsp last&nbsp OUT&nbsp just&nbsp occurred&nbsp as&nbsp the&nbsp status&nbsp stage)</code></td></tr>
<tr><td><code><i>  2570</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2571</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //If&nbsp the&nbsp status&nbsp stage&nbsp is&nbsp complete,&nbsp this&nbsp means&nbsp we&nbsp are&nbsp done&nbsp with&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>  2572</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //control&nbsp transfer.&nbsp&nbsp Go&nbsp back&nbsp to&nbsp the&nbsp idle&nbsp "WAIT_SETUP"&nbsp state.</code></td></tr>
<tr><td><code><i>  2573</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp controlTransferState&nbsp =&nbsp WAIT_SETUP;</code></td></tr>
<tr><td><code><i>  2574</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2575</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Prepare&nbsp EP0&nbsp OUT&nbsp for&nbsp the&nbsp next&nbsp SETUP&nbsp transaction,&nbsp however,&nbsp it&nbsp may&nbsp have</code></td></tr>
<tr><td><code><i>  2576</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //already&nbsp been&nbsp prepared&nbsp if&nbsp ping-pong&nbsp buffering&nbsp was&nbsp enabled&nbsp on&nbsp EP0&nbsp OUT,</code></td></tr>
<tr><td><code><i>  2577</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //and&nbsp the&nbsp last&nbsp control&nbsp transfer&nbsp was&nbsp of&nbsp direction:&nbsp device&nbsp to&nbsp host,&nbsp see</code></td></tr>
<tr><td><code><i>  2578</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //USBCtrlEPServiceComplete().&nbsp&nbsp If&nbsp it&nbsp was&nbsp already&nbsp prepared,&nbsp do&nbsp not&nbsp want</code></td></tr>
<tr><td><code><i>  2579</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //to&nbsp do&nbsp anything&nbsp to&nbsp the&nbsp BDT.</code></td></tr>
<tr><td><code><i>  2580</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(BothEP0OutUOWNsSet&nbsp ==&nbsp false)</code></td></tr>
<tr><td><code><i>  2581</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2582</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  CNT&nbsp =&nbsp USB_EP0_BUFF_SIZE;</code></td></tr>
<tr><td><code><i>  2583</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(&SetupPkt);</code></td></tr>
<tr><td><code><i>  2584</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp =&nbsp _DAT0|(_DTSEN&nbsp &&nbsp _DTS_CHECKING_ENABLED)|_BSTALL;</code></td></tr>
<tr><td><code><i>  2585</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryEP0OutNext-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  2586</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2587</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2588</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2589</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp BothEP0OutUOWNsSet&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  2590</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2591</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2592</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>  2593</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2594</i> </code></td><td><code>&nbsp /******************************************************************************</code></td></tr>
<tr><td><code><i>  2595</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBCtrlTrfInHandler(void)</code></td></tr>
<tr><td><code><i>  2596</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2597</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2598</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2599</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2600</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2601</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2602</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2603</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2604</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2605</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp handles&nbsp an&nbsp IN&nbsp transaction&nbsp according&nbsp to</code></td></tr>
<tr><td><code><i>  2606</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp which&nbsp control&nbsp transfer&nbsp state&nbsp is&nbsp currently&nbsp active.</code></td></tr>
<tr><td><code><i>  2607</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2608</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp A&nbsp Set&nbsp Address&nbsp Request&nbsp must&nbsp not&nbsp change&nbsp the&nbsp acutal&nbsp address</code></td></tr>
<tr><td><code><i>  2609</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp of&nbsp the&nbsp device&nbsp until&nbsp the&nbsp completion&nbsp of&nbsp the&nbsp control</code></td></tr>
<tr><td><code><i>  2610</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp transfer.&nbsp The&nbsp end&nbsp of&nbsp the&nbsp control&nbsp transfer&nbsp for&nbsp Set&nbsp Address</code></td></tr>
<tr><td><code><i>  2611</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Request&nbsp is&nbsp an&nbsp IN&nbsp transaction.&nbsp Therefore&nbsp it&nbsp is&nbsp necessary</code></td></tr>
<tr><td><code><i>  2612</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp to&nbsp service&nbsp this&nbsp unique&nbsp situation&nbsp when&nbsp the&nbsp condition&nbsp is</code></td></tr>
<tr><td><code><i>  2613</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp right.&nbsp Macro&nbsp mUSBCheckAdrPendingState&nbsp is&nbsp defined&nbsp in</code></td></tr>
<tr><td><code><i>  2614</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp usb9.h&nbsp and&nbsp its&nbsp function&nbsp is&nbsp to&nbsp specifically&nbsp service&nbsp this</code></td></tr>
<tr><td><code><i>  2615</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp event.</code></td></tr>
<tr><td><code><i>  2616</i> </code></td><td><code>&nbsp &nbsp *****************************************************************************/</code></td></tr>
<tr><td><code><i>  2617</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCtrlTrfInHandler(void)</code></td></tr>
<tr><td><code><i>  2618</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  2619</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp lastDTS;</code></td></tr>
<tr><td><code><i>  2620</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2621</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp lastDTS&nbsp =&nbsp pBDTEntryIn[0]-&rsaquo  STAT.DTS;</code></td></tr>
<tr><td><code><i>  2622</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2623</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //switch&nbsp to&nbsp the&nbsp next&nbsp ping&nbsp pong&nbsp buffer</code></td></tr>
<tr><td><code><i>  2624</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp ((uint8_t_VAL*)&pBDTEntryIn[0])-&rsaquo  Val&nbsp ^=&nbsp USB_NEXT_EP0_IN_PING_PONG;</code></td></tr>
<tr><td><code><i>  2625</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2626</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Must&nbsp check&nbsp if&nbsp in&nbsp ADR_PENDING_STATE.&nbsp&nbsp If&nbsp so,&nbsp we&nbsp need&nbsp to&nbsp update&nbsp the&nbsp address</code></td></tr>
<tr><td><code><i>  2627</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //now,&nbsp since&nbsp the&nbsp IN&nbsp status&nbsp stage&nbsp of&nbsp the&nbsp (set&nbsp address)&nbsp control&nbsp transfer&nbsp has&nbsp </code></td></tr>
<tr><td><code><i>  2628</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //evidently&nbsp completed&nbsp successfully.</code></td></tr>
<tr><td><code><i>  2629</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBDeviceState&nbsp ==&nbsp ADR_PENDING_STATE)</code></td></tr>
<tr><td><code><i>  2630</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2631</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp U1ADDR&nbsp =&nbsp (SetupPkt.bDevADR&nbsp &&nbsp 0x7F);</code></td></tr>
<tr><td><code><i>  2632</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(U1ADDR&nbsp !=&nbsp 0u)</code></td></tr>
<tr><td><code><i>  2633</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2634</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceState=ADDRESS_STATE;</code></td></tr>
<tr><td><code><i>  2635</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2636</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2637</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2638</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceState=DEFAULT_STATE;</code></td></tr>
<tr><td><code><i>  2639</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2640</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp if</code></td></tr>
<tr><td><code><i>  2641</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2642</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2643</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(controlTransferState&nbsp ==&nbsp CTRL_TRF_TX)</code></td></tr>
<tr><td><code><i>  2644</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2645</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  ADR&nbsp =&nbsp ConvertToPhysicalAddress(CtrlTrfData);</code></td></tr>
<tr><td><code><i>  2646</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBCtrlTrfTxService();</code></td></tr>
<tr><td><code><i>  2647</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2648</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Check&nbsp if&nbsp we&nbsp have&nbsp already&nbsp sent&nbsp a&nbsp short&nbsp packet.&nbsp&nbsp If&nbsp so,&nbsp configure</code></td></tr>
<tr><td><code><i>  2649</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //the&nbsp endpoint&nbsp to&nbsp STALL&nbsp in&nbsp response&nbsp to&nbsp any&nbsp further&nbsp IN&nbsp tokens&nbsp (in&nbsp the</code></td></tr>
<tr><td><code><i>  2650</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //case&nbsp that&nbsp the&nbsp host&nbsp erroneously&nbsp tries&nbsp to&nbsp receive&nbsp more&nbsp data&nbsp than&nbsp it</code></td></tr>
<tr><td><code><i>  2651</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //should).</code></td></tr>
<tr><td><code><i>  2652</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(shortPacketStatus&nbsp ==&nbsp SHORT_PKT_SENT)</code></td></tr>
<tr><td><code><i>  2653</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2654</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp If&nbsp a&nbsp short&nbsp packet&nbsp has&nbsp been&nbsp sent,&nbsp don't&nbsp want&nbsp to&nbsp send&nbsp any&nbsp more,</code></td></tr>
<tr><td><code><i>  2655</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp stall&nbsp next&nbsp time&nbsp if&nbsp host&nbsp is&nbsp still&nbsp trying&nbsp to&nbsp read.</code></td></tr>
<tr><td><code><i>  2656</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp =&nbsp _BSTALL;</code></td></tr>
<tr><td><code><i>  2657</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  2658</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2659</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2660</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2661</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(lastDTS&nbsp ==&nbsp 0)</code></td></tr>
<tr><td><code><i>  2662</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2663</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp =&nbsp _DAT1|(_DTSEN&nbsp &&nbsp _DTS_CHECKING_ENABLED);</code></td></tr>
<tr><td><code><i>  2664</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  2665</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2666</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2667</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2668</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp =&nbsp _DAT0|(_DTSEN&nbsp &&nbsp _DTS_CHECKING_ENABLED);</code></td></tr>
<tr><td><code><i>  2669</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[0]-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  2670</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2671</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }//end&nbsp if(...)else</code></td></tr>
<tr><td><code><i>  2672</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2673</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else&nbsp //&nbsp must&nbsp have&nbsp been&nbsp a&nbsp CTRL_TRF_RX&nbsp status&nbsp stage&nbsp IN&nbsp packet&nbsp (&lsaquo  setup&rsaquo &lsaquo  out&rsaquo &lsaquo  out&rsaquo  ...&lsaquo  IN&rsaquo &nbsp&nbsp&lsaquo  --&nbsp this&nbsp last&nbsp IN&nbsp just&nbsp occurred&nbsp as&nbsp the&nbsp status&nbsp stage)</code></td></tr>
<tr><td><code><i>  2674</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2675</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //if&nbsp someone&nbsp is&nbsp still&nbsp expecting&nbsp data&nbsp from&nbsp the&nbsp control&nbsp transfer</code></td></tr>
<tr><td><code><i>  2676</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp then&nbsp make&nbsp sure&nbsp to&nbsp terminate&nbsp that&nbsp request&nbsp and&nbsp let&nbsp them&nbsp know&nbsp that</code></td></tr>
<tr><td><code><i>  2677</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp they&nbsp are&nbsp done</code></td></tr>
<tr><td><code><i>  2678</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(outPipes[0].info.bits.busy&nbsp ==&nbsp 1)</code></td></tr>
<tr><td><code><i>  2679</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2680</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(outPipes[0].pFunc&nbsp !=&nbsp NULL)</code></td></tr>
<tr><td><code><i>  2681</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2682</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp outPipes[0].pFunc();</code></td></tr>
<tr><td><code><i>  2683</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2684</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp outPipes[0].info.bits.busy&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2685</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2686</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2687</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp controlTransferState&nbsp =&nbsp WAIT_SETUP;</code></td></tr>
<tr><td><code><i>  2688</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Don't&nbsp need&nbsp to&nbsp arm&nbsp EP0&nbsp OUT&nbsp here.&nbsp&nbsp It&nbsp was&nbsp already&nbsp armed&nbsp by&nbsp the&nbsp last&nbsp&lsaquo  out&rsaquo &nbsp that</code></td></tr>
<tr><td><code><i>  2689</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //got&nbsp processed&nbsp by&nbsp the&nbsp USBCtrlTrfRxService()&nbsp handler.</code></td></tr>
<tr><td><code><i>  2690</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2691</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2692</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>  2693</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2694</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2695</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  2696</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBCheckStdRequest(void)</code></td></tr>
<tr><td><code><i>  2697</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2698</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2699</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2700</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2701</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2702</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2703</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2704</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2705</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2706</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp checks&nbsp the&nbsp setup&nbsp data&nbsp packet&nbsp to&nbsp see</code></td></tr>
<tr><td><code><i>  2707</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if&nbsp it&nbsp knows&nbsp how&nbsp to&nbsp handle&nbsp it</code></td></tr>
<tr><td><code><i>  2708</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2709</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2710</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>  2711</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBCheckStdRequest(void)</code></td></tr>
<tr><td><code><i>  2712</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  2713</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(SetupPkt.RequestType&nbsp !=&nbsp USB_SETUP_TYPE_STANDARD_BITFIELD)&nbsp return;</code></td></tr>
<tr><td><code><i>  2714</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2715</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp switch(SetupPkt.bRequest)</code></td></tr>
<tr><td><code><i>  2716</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2717</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_REQUEST_SET_ADDRESS:</code></td></tr>
<tr><td><code><i>  2718</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp This&nbsp will&nbsp generate&nbsp a&nbsp zero&nbsp length&nbsp packet</code></td></tr>
<tr><td><code><i>  2719</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceState&nbsp =&nbsp ADR_PENDING_STATE;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Update&nbsp state&nbsp only</code></td></tr>
<tr><td><code><i>  2720</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*&nbsp See&nbsp USBCtrlTrfInHandler()&nbsp for&nbsp the&nbsp next&nbsp step&nbsp */</code></td></tr>
<tr><td><code><i>  2721</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2722</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_REQUEST_GET_DESCRIPTOR:</code></td></tr>
<tr><td><code><i>  2723</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStdGetDscHandler();</code></td></tr>
<tr><td><code><i>  2724</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2725</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_REQUEST_SET_CONFIGURATION:</code></td></tr>
<tr><td><code><i>  2726</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStdSetCfgHandler();</code></td></tr>
<tr><td><code><i>  2727</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2728</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_REQUEST_GET_CONFIGURATION:</code></td></tr>
<tr><td><code><i>  2729</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].pSrc.bRam&nbsp =&nbsp (uint8_t*)&USBActiveConfiguration;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp Source</code></td></tr>
<tr><td><code><i>  2730</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.ctrl_trf_mem&nbsp =&nbsp USB_EP0_RAM;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp memory&nbsp type</code></td></tr>
<tr><td><code><i>  2731</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].wCount.v[0]&nbsp =&nbsp 1;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp data&nbsp count</code></td></tr>
<tr><td><code><i>  2732</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  2733</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2734</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_REQUEST_GET_STATUS:</code></td></tr>
<tr><td><code><i>  2735</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStdGetStatusHandler();</code></td></tr>
<tr><td><code><i>  2736</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2737</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_REQUEST_CLEAR_FEATURE:</code></td></tr>
<tr><td><code><i>  2738</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_REQUEST_SET_FEATURE:</code></td></tr>
<tr><td><code><i>  2739</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBStdFeatureReqHandler();</code></td></tr>
<tr><td><code><i>  2740</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2741</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_REQUEST_GET_INTERFACE:</code></td></tr>
<tr><td><code><i>  2742</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].pSrc.bRam&nbsp =&nbsp (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];&nbsp&nbsp //&nbsp Set&nbsp source</code></td></tr>
<tr><td><code><i>  2743</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.ctrl_trf_mem&nbsp =&nbsp USB_EP0_RAM;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp memory&nbsp type</code></td></tr>
<tr><td><code><i>  2744</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].wCount.v[0]&nbsp =&nbsp 1;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Set&nbsp data&nbsp count</code></td></tr>
<tr><td><code><i>  2745</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  2746</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2747</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_REQUEST_SET_INTERFACE:</code></td></tr>
<tr><td><code><i>  2748</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  2749</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBAlternateInterface[SetupPkt.bIntfID]&nbsp =&nbsp SetupPkt.bAltID;</code></td></tr>
<tr><td><code><i>  2750</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2751</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_REQUEST_SET_DESCRIPTOR:</code></td></tr>
<tr><td><code><i>  2752</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);</code></td></tr>
<tr><td><code><i>  2753</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2754</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp USB_REQUEST_SYNCH_FRAME:</code></td></tr>
<tr><td><code><i>  2755</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp default:</code></td></tr>
<tr><td><code><i>  2756</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>  2757</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp switch</code></td></tr>
<tr><td><code><i>  2758</i> </code></td><td><code>&nbsp }//end&nbsp USBCheckStdRequest</code></td></tr>
<tr><td><code><i>  2759</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2760</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>  2761</i> </code></td><td><code>&nbsp &nbsp *&nbsp Function:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBStdFeatureReqHandler(void)</code></td></tr>
<tr><td><code><i>  2762</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2763</i> </code></td><td><code>&nbsp &nbsp *&nbsp PreCondition:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2764</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2765</i> </code></td><td><code>&nbsp &nbsp *&nbsp Input:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2766</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2767</i> </code></td><td><code>&nbsp &nbsp *&nbsp Output:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Can&nbsp alter&nbsp BDT&nbsp entries.&nbsp&nbsp Can&nbsp also&nbsp modify&nbsp USB&nbsp stack</code></td></tr>
<tr><td><code><i>  2768</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Maintained&nbsp variables.</code></td></tr>
<tr><td><code><i>  2769</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2770</i> </code></td><td><code>&nbsp &nbsp *&nbsp Side&nbsp Effects:&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  2771</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2772</i> </code></td><td><code>&nbsp &nbsp *&nbsp Overview:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp handles&nbsp the&nbsp standard&nbsp SET&nbsp &&nbsp CLEAR</code></td></tr>
<tr><td><code><i>  2773</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp FEATURES&nbsp requests</code></td></tr>
<tr><td><code><i>  2774</i> </code></td><td><code>&nbsp &nbsp *</code></td></tr>
<tr><td><code><i>  2775</i> </code></td><td><code>&nbsp &nbsp *&nbsp Note:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp is&nbsp a&nbsp private&nbsp function,&nbsp intended&nbsp for&nbsp internal&nbsp </code></td></tr>
<tr><td><code><i>  2776</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp use&nbsp by&nbsp the&nbsp USB&nbsp stack,&nbsp when&nbsp processing&nbsp SET/CLEAR</code></td></tr>
<tr><td><code><i>  2777</i> </code></td><td><code>&nbsp &nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp feature&nbsp requests.&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2778</i> </code></td><td><code>&nbsp &nbsp *******************************************************************/</code></td></tr>
<tr><td><code><i>  2779</i> </code></td><td><code>&nbsp static&nbsp void&nbsp USBStdFeatureReqHandler(void)</code></td></tr>
<tr><td><code><i>  2780</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  2781</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp BDT_ENTRY&nbsp *p;</code></td></tr>
<tr><td><code><i>  2782</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp EP_STATUS&nbsp current_ep_data;</code></td></tr>
<tr><td><code><i>  2783</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp defined(__C32__)</code></td></tr>
<tr><td><code><i>  2784</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp uint32_t*&nbsp pUEP;</code></td></tr>
<tr><td><code><i>  2785</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #else</code></td></tr>
<tr><td><code><i>  2786</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp unsigned&nbsp char*&nbsp pUEP;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2787</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  2788</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2789</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2790</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #ifdef&nbsp&nbsp&nbsp&nbsp&nbsp USB_SUPPORT_OTG</code></td></tr>
<tr><td><code><i>  2791</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Check&nbsp for&nbsp USB&nbsp On-The-Go&nbsp (OTG)&nbsp specific&nbsp requests</code></td></tr>
<tr><td><code><i>  2792</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if&nbsp ((SetupPkt.bFeature&nbsp ==&nbsp OTG_FEATURE_B_HNP_ENABLE)&&</code></td></tr>
<tr><td><code><i>  2793</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (SetupPkt.Recipient&nbsp ==&nbsp USB_SETUP_RECIPIENT_DEVICE_BITFIELD))</code></td></tr>
<tr><td><code><i>  2794</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2795</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  2796</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.bRequest&nbsp ==&nbsp USB_REQUEST_SET_FEATURE)</code></td></tr>
<tr><td><code><i>  2797</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGEnableHnp();</code></td></tr>
<tr><td><code><i>  2798</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2799</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGDisableHnp();</code></td></tr>
<tr><td><code><i>  2800</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2801</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2802</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if&nbsp ((SetupPkt.bFeature&nbsp ==&nbsp OTG_FEATURE_A_HNP_SUPPORT)&&</code></td></tr>
<tr><td><code><i>  2803</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (SetupPkt.Recipient&nbsp ==&nbsp USB_SETUP_RECIPIENT_DEVICE_BITFIELD))</code></td></tr>
<tr><td><code><i>  2804</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2805</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  2806</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.bRequest&nbsp ==&nbsp USB_REQUEST_SET_FEATURE)</code></td></tr>
<tr><td><code><i>  2807</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGEnableSupportHnp();</code></td></tr>
<tr><td><code><i>  2808</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2809</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGDisableSupportHnp();</code></td></tr>
<tr><td><code><i>  2810</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2811</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2812</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if&nbsp ((SetupPkt.bFeature&nbsp ==&nbsp OTG_FEATURE_A_ALT_HNP_SUPPORT)&&</code></td></tr>
<tr><td><code><i>  2813</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (SetupPkt.Recipient&nbsp ==&nbsp USB_SETUP_RECIPIENT_DEVICE_BITFIELD))</code></td></tr>
<tr><td><code><i>  2814</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2815</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  2816</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.bRequest&nbsp ==&nbsp USB_REQUEST_SET_FEATURE)</code></td></tr>
<tr><td><code><i>  2817</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGEnableAltHnp();</code></td></tr>
<tr><td><code><i>  2818</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2819</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBOTGDisableAltHnp();</code></td></tr>
<tr><td><code><i>  2820</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2821</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif&nbsp&nbsp&nbsp //#ifdef&nbsp USB_SUPPORT_OTG&nbsp </code></td></tr>
<tr><td><code><i>  2822</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2823</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Check&nbsp if&nbsp the&nbsp host&nbsp sent&nbsp a&nbsp valid&nbsp SET&nbsp or&nbsp CLEAR&nbsp feature&nbsp (remote&nbsp wakeup)&nbsp request.</code></td></tr>
<tr><td><code><i>  2824</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if((SetupPkt.bFeature&nbsp ==&nbsp USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&</code></td></tr>
<tr><td><code><i>  2825</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (SetupPkt.Recipient&nbsp ==&nbsp USB_SETUP_RECIPIENT_DEVICE_BITFIELD))</code></td></tr>
<tr><td><code><i>  2826</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2827</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  2828</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.bRequest&nbsp ==&nbsp USB_REQUEST_SET_FEATURE)</code></td></tr>
<tr><td><code><i>  2829</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RemoteWakeup&nbsp =&nbsp true;</code></td></tr>
<tr><td><code><i>  2830</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2831</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp RemoteWakeup&nbsp =&nbsp false;</code></td></tr>
<tr><td><code><i>  2832</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp if</code></td></tr>
<tr><td><code><i>  2833</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2834</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Check&nbsp if&nbsp the&nbsp host&nbsp sent&nbsp a&nbsp valid&nbsp SET&nbsp or&nbsp CLEAR&nbsp endpoint&nbsp halt&nbsp request.</code></td></tr>
<tr><td><code><i>  2835</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if((SetupPkt.bFeature&nbsp ==&nbsp USB_FEATURE_ENDPOINT_HALT)&&</code></td></tr>
<tr><td><code><i>  2836</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (SetupPkt.Recipient&nbsp ==&nbsp USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&</code></td></tr>
<tr><td><code><i>  2837</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (SetupPkt.EPNum&nbsp !=&nbsp 0)&nbsp &&&nbsp (SetupPkt.EPNum&nbsp&lsaquo  =&nbsp USB_MAX_EP_NUMBER)&&</code></td></tr>
<tr><td><code><i>  2838</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (USBDeviceState&nbsp ==&nbsp CONFIGURED_STATE))</code></td></tr>
<tr><td><code><i>  2839</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2840</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //The&nbsp request&nbsp was&nbsp valid.&nbsp&nbsp Take&nbsp control&nbsp of&nbsp the&nbsp control&nbsp transfer&nbsp and</code></td></tr>
<tr><td><code><i>  2841</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //perform&nbsp the&nbsp host&nbsp requested&nbsp action.</code></td></tr>
<tr><td><code><i>  2842</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  2843</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2844</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Fetch&nbsp a&nbsp pointer&nbsp to&nbsp the&nbsp BDT&nbsp that&nbsp the&nbsp host&nbsp wants&nbsp to&nbsp SET/CLEAR&nbsp halt&nbsp on.</code></td></tr>
<tr><td><code><i>  2845</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.EPDir&nbsp ==&nbsp OUT_FROM_HOST)</code></td></tr>
<tr><td><code><i>  2846</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2847</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p&nbsp =&nbsp (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];</code></td></tr>
<tr><td><code><i>  2848</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp current_ep_data.Val&nbsp =&nbsp ep_data_out[SetupPkt.EPNum].Val;</code></td></tr>
<tr><td><code><i>  2849</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2850</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2851</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2852</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p&nbsp =&nbsp (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];</code></td></tr>
<tr><td><code><i>  2853</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp current_ep_data.Val&nbsp =&nbsp ep_data_in[SetupPkt.EPNum].Val;</code></td></tr>
<tr><td><code><i>  2854</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2855</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2856</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //If&nbsp ping&nbsp pong&nbsp buffering&nbsp is&nbsp enabled&nbsp on&nbsp the&nbsp requested&nbsp endpoint,&nbsp need&nbsp </code></td></tr>
<tr><td><code><i>  2857</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //to&nbsp point&nbsp to&nbsp the&nbsp one&nbsp that&nbsp is&nbsp the&nbsp active&nbsp BDT&nbsp entry&nbsp which&nbsp the&nbsp SIE&nbsp will&nbsp </code></td></tr>
<tr><td><code><i>  2858</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //use&nbsp for&nbsp the&nbsp next&nbsp attempted&nbsp transaction&nbsp on&nbsp that&nbsp EP&nbsp number.</code></td></tr>
<tr><td><code><i>  2859</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__ALL_BUT_EP0)&nbsp ||&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__FULL_PING_PONG)&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2860</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(current_ep_data.bits.ping_pong_state&nbsp ==&nbsp 0)&nbsp //Check&nbsp if&nbsp even</code></td></tr>
<tr><td><code><i>  2861</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2862</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBHALPingPongSetToEven(&p);</code></td></tr>
<tr><td><code><i>  2863</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2864</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else&nbsp //else&nbsp must&nbsp have&nbsp been&nbsp odd</code></td></tr>
<tr><td><code><i>  2865</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2866</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBHALPingPongSetToOdd(&p);</code></td></tr>
<tr><td><code><i>  2867</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2868</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  2869</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2870</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Update&nbsp the&nbsp BDT&nbsp pointers&nbsp with&nbsp the&nbsp new,&nbsp next&nbsp entry&nbsp based&nbsp on&nbsp the&nbsp feature</code></td></tr>
<tr><td><code><i>  2871</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp request</code></td></tr>
<tr><td><code><i>  2872</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.EPDir&nbsp ==&nbsp OUT_FROM_HOST)</code></td></tr>
<tr><td><code><i>  2873</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2874</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryOut[SetupPkt.EPNum]&nbsp =&nbsp (volatile&nbsp BDT_ENTRY&nbsp *)p;</code></td></tr>
<tr><td><code><i>  2875</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2876</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2877</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2878</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pBDTEntryIn[SetupPkt.EPNum]&nbsp =&nbsp (volatile&nbsp BDT_ENTRY&nbsp *)p;</code></td></tr>
<tr><td><code><i>  2879</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2880</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2881</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Check&nbsp if&nbsp it&nbsp was&nbsp a&nbsp SET_FEATURE&nbsp endpoint&nbsp halt&nbsp request</code></td></tr>
<tr><td><code><i>  2882</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.bRequest&nbsp ==&nbsp USB_REQUEST_SET_FEATURE)</code></td></tr>
<tr><td><code><i>  2883</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2884</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(p-&rsaquo  STAT.UOWN&nbsp ==&nbsp 1)</code></td></tr>
<tr><td><code><i>  2885</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2886</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Mark&nbsp that&nbsp we&nbsp are&nbsp terminating&nbsp this&nbsp transfer&nbsp and&nbsp that&nbsp the&nbsp user</code></td></tr>
<tr><td><code><i>  2887</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp needs&nbsp to&nbsp be&nbsp notified&nbsp later</code></td></tr>
<tr><td><code><i>  2888</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.EPDir&nbsp ==&nbsp OUT_FROM_HOST)</code></td></tr>
<tr><td><code><i>  2889</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2890</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ep_data_out[SetupPkt.EPNum].bits.transfer_terminated&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  2891</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2892</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2893</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2894</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ep_data_in[SetupPkt.EPNum].bits.transfer_terminated&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>  2895</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2896</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2897</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2898</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Then&nbsp STALL&nbsp the&nbsp endpoint</code></td></tr>
<tr><td><code><i>  2899</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp |=&nbsp _BSTALL;</code></td></tr>
<tr><td><code><i>  2900</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp |=&nbsp _USIE;</code></td></tr>
<tr><td><code><i>  2901</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }//if(SetupPkt.bRequest&nbsp ==&nbsp USB_REQUEST_SET_FEATURE)</code></td></tr>
<tr><td><code><i>  2902</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2903</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2904</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Else&nbsp the&nbsp request&nbsp must&nbsp have&nbsp been&nbsp a&nbsp CLEAR_FEATURE&nbsp endpoint&nbsp halt.</code></td></tr>
<tr><td><code><i>  2905</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__ALL_BUT_EP0)&nbsp ||&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__FULL_PING_PONG)&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2906</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //toggle&nbsp over&nbsp the&nbsp to&nbsp the&nbsp non-active&nbsp BDT</code></td></tr>
<tr><td><code><i>  2907</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBAdvancePingPongBuffer(&p);&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2908</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2909</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(p-&rsaquo  STAT.UOWN&nbsp ==&nbsp 1)</code></td></tr>
<tr><td><code><i>  2910</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2911</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Clear&nbsp UOWN&nbsp and&nbsp set&nbsp DTS&nbsp state&nbsp so&nbsp it&nbsp will&nbsp be&nbsp correct&nbsp the&nbsp next&nbsp time</code></td></tr>
<tr><td><code><i>  2912</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //the&nbsp application&nbsp firmware&nbsp uses&nbsp USBTransferOnePacket()&nbsp on&nbsp the&nbsp EP.</code></td></tr>
<tr><td><code><i>  2913</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp &=&nbsp (~_USIE);&nbsp&nbsp&nbsp&nbsp //Clear&nbsp UOWN&nbsp bit</code></td></tr>
<tr><td><code><i>  2914</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp |=&nbsp _DAT1;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Set&nbsp DTS&nbsp to&nbsp DATA1</code></td></tr>
<tr><td><code><i>  2915</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));</code></td></tr>
<tr><td><code><i>  2916</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2917</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2918</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2919</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //UOWN&nbsp already&nbsp clear,&nbsp but&nbsp still&nbsp need&nbsp to&nbsp set&nbsp DTS&nbsp to&nbsp DATA1&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2920</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp |=&nbsp _DAT1;</code></td></tr>
<tr><td><code><i>  2921</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2922</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  2923</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //toggle&nbsp back&nbsp to&nbsp the&nbsp active&nbsp BDT&nbsp (the&nbsp one&nbsp the&nbsp SIE&nbsp is&nbsp currently&nbsp looking&nbsp at</code></td></tr>
<tr><td><code><i>  2924</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //and&nbsp will&nbsp use&nbsp for&nbsp the&nbsp next&nbsp successful&nbsp transaction&nbsp to&nbsp take&nbsp place&nbsp on&nbsp the&nbsp EP</code></td></tr>
<tr><td><code><i>  2925</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBAdvancePingPongBuffer(&p);&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2926</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2927</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Check&nbsp if&nbsp we&nbsp are&nbsp currently&nbsp terminating,&nbsp or&nbsp have&nbsp previously&nbsp terminated</code></td></tr>
<tr><td><code><i>  2928</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //a&nbsp transaction&nbsp on&nbsp the&nbsp given&nbsp endpoint.&nbsp&nbsp If&nbsp so,&nbsp need&nbsp to&nbsp clear&nbsp UOWN,</code></td></tr>
<tr><td><code><i>  2929</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //set&nbsp DTS&nbsp to&nbsp the&nbsp proper&nbsp state,&nbsp and&nbsp call&nbsp the&nbsp application&nbsp callback</code></td></tr>
<tr><td><code><i>  2930</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //function.</code></td></tr>
<tr><td><code><i>  2931</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if((current_ep_data.bits.transfer_terminated&nbsp !=&nbsp 0)&nbsp ||&nbsp (p-&rsaquo  STAT.UOWN&nbsp ==&nbsp 1))</code></td></tr>
<tr><td><code><i>  2932</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2933</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.EPDir&nbsp ==&nbsp OUT_FROM_HOST)</code></td></tr>
<tr><td><code><i>  2934</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2935</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ep_data_out[SetupPkt.EPNum].bits.transfer_terminated&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2936</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2937</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2938</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2939</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ep_data_in[SetupPkt.EPNum].bits.transfer_terminated&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2940</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2941</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //clear&nbsp UOWN,&nbsp clear&nbsp DTS&nbsp to&nbsp DATA0,&nbsp and&nbsp finally&nbsp remove&nbsp the&nbsp STALL&nbsp condition&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2942</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp &=&nbsp ~(_USIE&nbsp |&nbsp _DAT1&nbsp |&nbsp _BSTALL);&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2943</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Call&nbsp the&nbsp application&nbsp event&nbsp handler&nbsp callback&nbsp function,&nbsp so&nbsp it&nbsp can&nbsp </code></td></tr>
<tr><td><code><i>  2944</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //decide&nbsp if&nbsp the&nbsp endpoint&nbsp should&nbsp get&nbsp re-armed&nbsp again&nbsp or&nbsp not.</code></td></tr>
<tr><td><code><i>  2945</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));</code></td></tr>
<tr><td><code><i>  2946</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2947</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2948</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2949</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //clear&nbsp UOWN,&nbsp clear&nbsp DTS&nbsp to&nbsp DATA0,&nbsp and&nbsp finally&nbsp remove&nbsp the&nbsp STALL&nbsp condition&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2950</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp &=&nbsp ~(_USIE&nbsp |&nbsp _DAT1&nbsp |&nbsp _BSTALL);&nbsp </code></td></tr>
<tr><td><code><i>  2951</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }&nbsp </code></td></tr>
<tr><td><code><i>  2952</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #else&nbsp //else&nbsp we&nbsp must&nbsp not&nbsp be&nbsp using&nbsp ping-pong&nbsp buffering&nbsp on&nbsp the&nbsp requested&nbsp endpoint</code></td></tr>
<tr><td><code><i>  2953</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Check&nbsp if&nbsp we&nbsp need&nbsp to&nbsp call&nbsp the&nbsp user&nbsp transfer&nbsp terminated&nbsp event&nbsp callback&nbsp function.</code></td></tr>
<tr><td><code><i>  2954</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //We&nbsp should&nbsp call&nbsp the&nbsp callback,&nbsp if&nbsp the&nbsp endpoint&nbsp was&nbsp previously&nbsp terminated,</code></td></tr>
<tr><td><code><i>  2955</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //or&nbsp the&nbsp endpoint&nbsp is&nbsp currently&nbsp armed,&nbsp and&nbsp the&nbsp host&nbsp is&nbsp performing&nbsp clear</code></td></tr>
<tr><td><code><i>  2956</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //endpoint&nbsp halt,&nbsp even&nbsp though&nbsp the&nbsp endpoint&nbsp wasn't&nbsp stalled.</code></td></tr>
<tr><td><code><i>  2957</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if((current_ep_data.bits.transfer_terminated&nbsp !=&nbsp 0)&nbsp ||&nbsp (p-&rsaquo  STAT.UOWN&nbsp ==&nbsp 1))</code></td></tr>
<tr><td><code><i>  2958</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2959</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //We&nbsp are&nbsp going&nbsp to&nbsp call&nbsp the&nbsp user&nbsp transfer&nbsp terminated&nbsp callback.</code></td></tr>
<tr><td><code><i>  2960</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Clear&nbsp the&nbsp flag&nbsp so&nbsp we&nbsp know&nbsp we&nbsp took&nbsp care&nbsp of&nbsp it&nbsp and&nbsp don't&nbsp need</code></td></tr>
<tr><td><code><i>  2961</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //to&nbsp call&nbsp it&nbsp again&nbsp later.</code></td></tr>
<tr><td><code><i>  2962</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(SetupPkt.EPDir&nbsp ==&nbsp OUT_FROM_HOST)</code></td></tr>
<tr><td><code><i>  2963</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2964</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ep_data_out[SetupPkt.EPNum].bits.transfer_terminated&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2965</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2966</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2967</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2968</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp ep_data_in[SetupPkt.EPNum].bits.transfer_terminated&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>  2969</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2970</i> </code></td><td><code>&nbsp &nbsp </code></td></tr>
<tr><td><code><i>  2971</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Clear&nbsp UOWN&nbsp and&nbsp remove&nbsp the&nbsp STALL&nbsp condition.&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2972</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp In&nbsp this&nbsp case&nbsp we&nbsp also&nbsp need&nbsp to&nbsp set&nbsp the&nbsp DTS&nbsp bit&nbsp to&nbsp 1&nbsp so&nbsp that</code></td></tr>
<tr><td><code><i>  2973</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp it&nbsp toggles&nbsp to&nbsp DATA0&nbsp the&nbsp next&nbsp time&nbsp the&nbsp application&nbsp firmware</code></td></tr>
<tr><td><code><i>  2974</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp calls&nbsp USBTransferOnePacket()&nbsp (or&nbsp equivalent&nbsp macro).&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2975</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp &=&nbsp ~(_USIE&nbsp |&nbsp _BSTALL);&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2976</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp |=&nbsp _DAT1;</code></td></tr>
<tr><td><code><i>  2977</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Let&nbsp the&nbsp application&nbsp firmware&nbsp know&nbsp a&nbsp transaction&nbsp just</code></td></tr>
<tr><td><code><i>  2978</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //got&nbsp terminated&nbsp by&nbsp the&nbsp host,&nbsp and&nbsp that&nbsp it&nbsp is&nbsp now&nbsp free&nbsp to</code></td></tr>
<tr><td><code><i>  2979</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //re-arm&nbsp the&nbsp endpoint&nbsp or&nbsp do&nbsp other&nbsp tasks&nbsp if&nbsp desired.&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2980</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));</code></td></tr>
<tr><td><code><i>  2981</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  2982</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>  2983</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  2984</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Clear&nbsp UOWN&nbsp and&nbsp remove&nbsp the&nbsp STALL&nbsp condition.&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2985</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp In&nbsp this&nbsp case&nbsp we&nbsp also&nbsp need&nbsp to&nbsp set&nbsp the&nbsp DTS&nbsp bit&nbsp to&nbsp 1&nbsp so&nbsp that</code></td></tr>
<tr><td><code><i>  2986</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp it&nbsp toggles&nbsp to&nbsp DATA0&nbsp the&nbsp next&nbsp time&nbsp the&nbsp application&nbsp firmware</code></td></tr>
<tr><td><code><i>  2987</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp calls&nbsp USBTransferOnePacket()&nbsp (or&nbsp equivalent&nbsp macro).&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2988</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp &=&nbsp ~(_USIE&nbsp |&nbsp _BSTALL);&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2989</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp p-&rsaquo  STAT.Val&nbsp |=&nbsp _DAT1;</code></td></tr>
<tr><td><code><i>  2990</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }&nbsp </code></td></tr>
<tr><td><code><i>  2991</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif&nbsp //end&nbsp of&nbsp #if&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__ALL_BUT_EP0)&nbsp ||&nbsp (USB_PING_PONG_MODE&nbsp ==&nbsp USB_PING_PONG__FULL_PING_PONG)&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2992</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  2993</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Get&nbsp a&nbsp pointer&nbsp to&nbsp the&nbsp appropriate&nbsp UEPn&nbsp register</code></td></tr>
<tr><td><code><i>  2994</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(__C32__)</code></td></tr>
<tr><td><code><i>  2995</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pUEP&nbsp =&nbsp (uint32_t*)(&U1EP0);</code></td></tr>
<tr><td><code><i>  2996</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pUEP&nbsp +=&nbsp (SetupPkt.EPNum*4);</code></td></tr>
<tr><td><code><i>  2997</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #else</code></td></tr>
<tr><td><code><i>  2998</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pUEP&nbsp =&nbsp (unsigned&nbsp char*)(&U1EP0+SetupPkt.EPNum);</code></td></tr>
<tr><td><code><i>  2999</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  3000</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3001</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Clear&nbsp the&nbsp STALL&nbsp bit&nbsp in&nbsp the&nbsp UEP&nbsp register</code></td></tr>
<tr><td><code><i>  3002</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *pUEP&nbsp &=&nbsp ~UEP_STALL;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  3003</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }//end&nbsp if(SetupPkt.bRequest&nbsp ==&nbsp USB_REQUEST_SET_FEATURE)</code></td></tr>
<tr><td><code><i>  3004</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp if&nbsp (lots&nbsp of&nbsp checks&nbsp for&nbsp set/clear&nbsp endpoint&nbsp halt)</code></td></tr>
<tr><td><code><i>  3005</i> </code></td><td><code>&nbsp }//end&nbsp USBStdFeatureReqHandler</code></td></tr>
<tr><td><code><i>  3006</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3007</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3008</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3009</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3010</i> </code></td><td><code>&nbsp /**************************************************************************</code></td></tr>
<tr><td><code><i>  3011</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>  3012</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBIncrement1msInternalTimers(void)</code></td></tr>
<tr><td><code><i>  3013</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3014</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>  3015</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp increments&nbsp internal&nbsp 1ms&nbsp time&nbsp base&nbsp counters,&nbsp which&nbsp are</code></td></tr>
<tr><td><code><i>  3016</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp useful&nbsp for&nbsp application&nbsp code&nbsp (that&nbsp can&nbsp use&nbsp a&nbsp 1ms&nbsp time&nbsp base/counter),&nbsp and</code></td></tr>
<tr><td><code><i>  3017</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp for&nbsp certain&nbsp USB&nbsp event&nbsp timing&nbsp specific&nbsp purposes.</code></td></tr>
<tr><td><code><i>  3018</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3019</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp In&nbsp USB&nbsp full&nbsp speed&nbsp applications,&nbsp the&nbsp application&nbsp code&nbsp does&nbsp not&nbsp need&nbsp to&nbsp (and&nbsp should</code></td></tr>
<tr><td><code><i>  3020</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp not)&nbsp explicitly&nbsp call&nbsp this&nbsp function,&nbsp as&nbsp the&nbsp USBDeviceTasks()&nbsp function&nbsp will</code></td></tr>
<tr><td><code><i>  3021</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp automatically&nbsp call&nbsp this&nbsp function&nbsp whenever&nbsp a&nbsp 1ms&nbsp time&nbsp interval&nbsp has&nbsp elapsed</code></td></tr>
<tr><td><code><i>  3022</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (assuming&nbsp the&nbsp code&nbsp is&nbsp calling&nbsp USBDeviceTasks()&nbsp frequenctly&nbsp enough&nbsp in&nbsp USB_POLLING</code></td></tr>
<tr><td><code><i>  3023</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp mode,&nbsp or&nbsp that&nbsp USB&nbsp interrupts&nbsp aren't&nbsp being&nbsp masked&nbsp for&nbsp more&nbsp than&nbsp 1ms&nbsp at&nbsp a&nbsp time</code></td></tr>
<tr><td><code><i>  3024</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp in&nbsp USB_INTERRUPT&nbsp mode).</code></td></tr>
<tr><td><code><i>  3025</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3026</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp In&nbsp USB&nbsp low&nbsp speed&nbsp applications,&nbsp the&nbsp application&nbsp firmware&nbsp is&nbsp responsible&nbsp for</code></td></tr>
<tr><td><code><i>  3027</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp periodically&nbsp calling&nbsp this&nbsp function&nbsp at&nbsp a&nbsp ~1ms&nbsp rate.&nbsp&nbsp This&nbsp can&nbsp be&nbsp done&nbsp using</code></td></tr>
<tr><td><code><i>  3028</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp a&nbsp general&nbsp purpose&nbsp microcontroller&nbsp timer&nbsp set&nbsp to&nbsp interrupt&nbsp every&nbsp 1ms&nbsp for&nbsp example.</code></td></tr>
<tr><td><code><i>  3029</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp If&nbsp the&nbsp low&nbsp speed&nbsp application&nbsp code&nbsp does&nbsp not&nbsp call&nbsp this&nbsp function,&nbsp the&nbsp internal&nbsp timers</code></td></tr>
<tr><td><code><i>  3030</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp will&nbsp not&nbsp increment,&nbsp and&nbsp the&nbsp USBGet1msTickCount()&nbsp API&nbsp function&nbsp will&nbsp not&nbsp be&nbsp available.</code></td></tr>
<tr><td><code><i>  3031</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Additionally,&nbsp certain&nbsp USB&nbsp stack&nbsp operations&nbsp (like&nbsp control&nbsp transfer&nbsp timeouts)</code></td></tr>
<tr><td><code><i>  3032</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp may&nbsp be&nbsp unavailable.</code></td></tr>
<tr><td><code><i>  3033</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3034</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Precondition:</code></td></tr>
<tr><td><code><i>  3035</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp should&nbsp be&nbsp called&nbsp only&nbsp after&nbsp USBDeviceInit()&nbsp has&nbsp been</code></td></tr>
<tr><td><code><i>  3036</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp called&nbsp (at&nbsp least&nbsp once&nbsp at&nbsp the&nbsp start&nbsp of&nbsp the&nbsp application).&nbsp&nbsp Ordinarily,</code></td></tr>
<tr><td><code><i>  3037</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp application&nbsp code&nbsp should&nbsp never&nbsp call&nbsp this&nbsp function,&nbsp unless&nbsp it&nbsp is&nbsp a&nbsp low&nbsp speed</code></td></tr>
<tr><td><code><i>  3038</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB&nbsp device.</code></td></tr>
<tr><td><code><i>  3039</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3040</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Parameters:</code></td></tr>
<tr><td><code><i>  3041</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  3042</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3043</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Return&nbsp Values:</code></td></tr>
<tr><td><code><i>  3044</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  3045</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3046</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>  3047</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp does&nbsp not&nbsp need&nbsp to&nbsp be&nbsp called&nbsp during&nbsp USB&nbsp suspend&nbsp conditions,&nbsp when</code></td></tr>
<tr><td><code><i>  3048</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp USB&nbsp module/stack&nbsp is&nbsp disabled,&nbsp or&nbsp when&nbsp the&nbsp USB&nbsp cable&nbsp is&nbsp detached&nbsp from&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>  3049</i> </code></td><td><code>&nbsp &nbsp&nbsp ***************************************************************************/</code></td></tr>
<tr><td><code><i>  3050</i> </code></td><td><code>&nbsp void&nbsp USBIncrement1msInternalTimers(void)</code></td></tr>
<tr><td><code><i>  3051</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  3052</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if(USB_SPEED_OPTION&nbsp ==&nbsp USB_LOW_SPEED)</code></td></tr>
<tr><td><code><i>  3053</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #warning&nbsp "For&nbsp low&nbsp speed&nbsp USB&nbsp applications,&nbsp read&nbsp the&nbsp function&nbsp comments&nbsp for&nbsp the&nbsp USBIncrement1msInternalTimers()&nbsp function,&nbsp and&nbsp implement&nbsp code&nbsp to&nbsp call&nbsp this&nbsp function&nbsp periodically."</code></td></tr>
<tr><td><code><i>  3054</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  3055</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3056</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Increment&nbsp timekeeping&nbsp 1ms&nbsp tick&nbsp counters.&nbsp&nbsp Useful&nbsp for&nbsp other&nbsp APIs/code</code></td></tr>
<tr><td><code><i>  3057</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //that&nbsp needs&nbsp a&nbsp 1ms&nbsp timebase&nbsp that&nbsp is&nbsp active&nbsp during&nbsp USB&nbsp non-suspended&nbsp operation.</code></td></tr>
<tr><td><code><i>  3058</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB1msTickCount++;</code></td></tr>
<tr><td><code><i>  3059</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBIsBusSuspended()&nbsp ==&nbsp false)</code></td></tr>
<tr><td><code><i>  3060</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  3061</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBTicksSinceSuspendEnd++;</code></td></tr>
<tr><td><code><i>  3062</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Check&nbsp for&nbsp 8-bit&nbsp wraparound.&nbsp&nbsp If&nbsp so,&nbsp force&nbsp it&nbsp to&nbsp saturate&nbsp at&nbsp 255.</code></td></tr>
<tr><td><code><i>  3063</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBTicksSinceSuspendEnd&nbsp ==&nbsp 0)</code></td></tr>
<tr><td><code><i>  3064</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  3065</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBTicksSinceSuspendEnd&nbsp =&nbsp 255;</code></td></tr>
<tr><td><code><i>  3066</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  3067</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>  3068</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>  3069</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3070</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3071</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3072</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3073</i> </code></td><td><code>&nbsp /**************************************************************************</code></td></tr>
<tr><td><code><i>  3074</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>  3075</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp uint32_t&nbsp USBGet1msTickCount(void)</code></td></tr>
<tr><td><code><i>  3076</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3077</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>  3078</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp retrieves&nbsp a&nbsp 32-bit&nbsp unsigned&nbsp integer&nbsp that&nbsp normally&nbsp increments&nbsp by</code></td></tr>
<tr><td><code><i>  3079</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp one&nbsp every&nbsp one&nbsp millisecond.&nbsp&nbsp The&nbsp count&nbsp value&nbsp starts&nbsp from&nbsp zero&nbsp when&nbsp the</code></td></tr>
<tr><td><code><i>  3080</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceInit()&nbsp function&nbsp is&nbsp first&nbsp called.&nbsp&nbsp See&nbsp the&nbsp remarks&nbsp section&nbsp for</code></td></tr>
<tr><td><code><i>  3081</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp details&nbsp on&nbsp special&nbsp circumstances&nbsp where&nbsp the&nbsp tick&nbsp count&nbsp will&nbsp not&nbsp increment.</code></td></tr>
<tr><td><code><i>  3082</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3083</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Precondition:</code></td></tr>
<tr><td><code><i>  3084</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp should&nbsp be&nbsp called&nbsp only&nbsp after&nbsp USBDeviceInit()&nbsp has&nbsp been</code></td></tr>
<tr><td><code><i>  3085</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp called&nbsp (at&nbsp least&nbsp once&nbsp at&nbsp the&nbsp start&nbsp of&nbsp the&nbsp application).</code></td></tr>
<tr><td><code><i>  3086</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3087</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Parameters:</code></td></tr>
<tr><td><code><i>  3088</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>  3089</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3090</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Return&nbsp Values:</code></td></tr>
<tr><td><code><i>  3091</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp uint32_t&nbsp representing&nbsp the&nbsp approximate&nbsp millisecond&nbsp count,&nbsp since&nbsp the&nbsp time&nbsp the</code></td></tr>
<tr><td><code><i>  3092</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceInit()&nbsp function&nbsp was&nbsp first&nbsp called.</code></td></tr>
<tr><td><code><i>  3093</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3094</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>  3095</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp On&nbsp 8-bit&nbsp USB&nbsp full&nbsp speed&nbsp devices,&nbsp the&nbsp internal&nbsp counter&nbsp is&nbsp incremented&nbsp on</code></td></tr>
<tr><td><code><i>  3096</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp every&nbsp SOF&nbsp packet&nbsp deteceted.&nbsp&nbsp Therefore,&nbsp it&nbsp will&nbsp not&nbsp increment&nbsp during&nbsp suspend</code></td></tr>
<tr><td><code><i>  3097</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp or&nbsp when&nbsp the&nbsp USB&nbsp cable&nbsp is&nbsp detached.&nbsp&nbsp However,&nbsp on&nbsp 16-bit&nbsp devices,&nbsp the&nbsp T1MSECIF</code></td></tr>
<tr><td><code><i>  3098</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp hardware&nbsp interrupt&nbsp source&nbsp is&nbsp used&nbsp to&nbsp increment&nbsp the&nbsp internal&nbsp counter.&nbsp&nbsp Therefore,</code></td></tr>
<tr><td><code><i>  3099</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp on&nbsp 16-bit&nbsp devices,&nbsp the&nbsp count&nbsp continue&nbsp to&nbsp increment&nbsp during&nbsp USB&nbsp suspend&nbsp or</code></td></tr>
<tr><td><code><i>  3100</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp detach&nbsp events,&nbsp so&nbsp long&nbsp as&nbsp the&nbsp application&nbsp code&nbsp has&nbsp not&nbsp put&nbsp the&nbsp microcontroller</code></td></tr>
<tr><td><code><i>  3101</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp to&nbsp sleep&nbsp during&nbsp these&nbsp events,&nbsp and&nbsp the&nbsp application&nbsp firmware&nbsp is&nbsp regularly</code></td></tr>
<tr><td><code><i>  3102</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp calling&nbsp the&nbsp USBDeviceTasks()&nbsp function&nbsp (or&nbsp allowing&nbsp it&nbsp to&nbsp execute,&nbsp if&nbsp using</code></td></tr>
<tr><td><code><i>  3103</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB_INTERRUPT&nbsp mode&nbsp operation).</code></td></tr>
<tr><td><code><i>  3104</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3105</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp In&nbsp USB&nbsp low&nbsp speed&nbsp applications,&nbsp the&nbsp host&nbsp does&nbsp not&nbsp broadcast&nbsp SOF&nbsp packets&nbsp to</code></td></tr>
<tr><td><code><i>  3106</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp device,&nbsp so&nbsp the&nbsp application&nbsp firmware&nbsp becomes&nbsp responsible&nbsp for&nbsp calling</code></td></tr>
<tr><td><code><i>  3107</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBIncrement1msInternalTimers()&nbsp periodically&nbsp (ex:&nbsp from&nbsp a&nbsp general&nbsp purpose</code></td></tr>
<tr><td><code><i>  3108</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp timer&nbsp interrupt&nbsp handler),&nbsp or&nbsp else&nbsp the&nbsp returned&nbsp value&nbsp from&nbsp this&nbsp function&nbsp will</code></td></tr>
<tr><td><code><i>  3109</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp not&nbsp increment.</code></td></tr>
<tr><td><code><i>  3110</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  3111</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Prior&nbsp to&nbsp calling&nbsp USBDeviceInit()&nbsp for&nbsp the&nbsp first&nbsp time&nbsp the&nbsp returned&nbsp value&nbsp will</code></td></tr>
<tr><td><code><i>  3112</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp be&nbsp unpredictable.</code></td></tr>
<tr><td><code><i>  3113</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3114</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp is&nbsp USB_INTERRUPT&nbsp mode&nbsp safe&nbsp and&nbsp may&nbsp be&nbsp called&nbsp from&nbsp main&nbsp loop</code></td></tr>
<tr><td><code><i>  3115</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp code&nbsp without&nbsp risk&nbsp of&nbsp retrieving&nbsp a&nbsp partially&nbsp updated&nbsp 32-bit&nbsp number.</code></td></tr>
<tr><td><code><i>  3116</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3117</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp However,&nbsp this&nbsp value&nbsp only&nbsp increments&nbsp when&nbsp the&nbsp USBDeviceTasks()&nbsp function&nbsp is&nbsp allowed</code></td></tr>
<tr><td><code><i>  3118</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp to&nbsp execute.&nbsp&nbsp If&nbsp USB_INTERRUPT&nbsp mode&nbsp is&nbsp used,&nbsp it&nbsp is&nbsp allowable&nbsp to&nbsp block&nbsp on&nbsp this</code></td></tr>
<tr><td><code><i>  3119</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp function.&nbsp&nbsp If&nbsp however&nbsp USB_POLLING&nbsp mode&nbsp is&nbsp used,&nbsp one&nbsp must&nbsp not&nbsp block&nbsp on&nbsp this</code></td></tr>
<tr><td><code><i>  3120</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp function&nbsp without&nbsp also&nbsp calling&nbsp USBDeviceTasks()&nbsp continuously&nbsp for&nbsp the&nbsp blocking</code></td></tr>
<tr><td><code><i>  3121</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp duration&nbsp (since&nbsp the&nbsp USB&nbsp stack&nbsp must&nbsp still&nbsp be&nbsp allowed&nbsp to&nbsp execute,&nbsp and&nbsp the&nbsp USB</code></td></tr>
<tr><td><code><i>  3122</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp stack&nbsp is&nbsp also&nbsp responsible&nbsp for&nbsp updating&nbsp the&nbsp tick&nbsp counter&nbsp internally).</code></td></tr>
<tr><td><code><i>  3123</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3124</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp If&nbsp the&nbsp application&nbsp is&nbsp operating&nbsp in&nbsp USB_POLLING&nbsp mode,&nbsp this&nbsp function&nbsp should</code></td></tr>
<tr><td><code><i>  3125</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp only&nbsp be&nbsp called&nbsp from&nbsp the&nbsp main&nbsp loop&nbsp context,&nbsp and&nbsp not&nbsp from&nbsp an&nbsp interrupt&nbsp handler,</code></td></tr>
<tr><td><code><i>  3126</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp as&nbsp the&nbsp returned&nbsp value&nbsp could&nbsp be&nbsp incorrect,&nbsp if&nbsp the&nbsp main&nbsp loop&nbsp context&nbsp code&nbsp was&nbsp in</code></td></tr>
<tr><td><code><i>  3127</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp the&nbsp process&nbsp of&nbsp updating&nbsp the&nbsp internal&nbsp count&nbsp at&nbsp the&nbsp moment&nbsp of&nbsp the&nbsp interrupt&nbsp event.</code></td></tr>
<tr><td><code><i>  3128</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp ***************************************************************************/</code></td></tr>
<tr><td><code><i>  3129</i> </code></td><td><code>&nbsp uint32_t&nbsp USBGet1msTickCount(void)</code></td></tr>
<tr><td><code><i>  3130</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>  3131</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp defined&nbsp (USB_INTERRUPT)</code></td></tr>
<tr><td><code><i>  3132</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp uint32_t&nbsp localContextValue;</code></td></tr>
<tr><td><code><i>  3133</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3134</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Repeatedly&nbsp read&nbsp the&nbsp interrupt&nbsp context&nbsp variable,&nbsp until&nbsp we&nbsp get&nbsp a&nbsp stable/unchanging</code></td></tr>
<tr><td><code><i>  3135</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //value.&nbsp&nbsp This&nbsp ensures&nbsp that&nbsp the&nbsp complete&nbsp 32-bit&nbsp value&nbsp got&nbsp read&nbsp without</code></td></tr>
<tr><td><code><i>  3136</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //getting&nbsp interrupted&nbsp in&nbsp between&nbsp bytes.</code></td></tr>
<tr><td><code><i>  3137</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp do</code></td></tr>
<tr><td><code><i>  3138</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>  3139</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp localContextValue&nbsp =&nbsp USB1msTickCount;</code></td></tr>
<tr><td><code><i>  3140</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }while(localContextValue&nbsp !=&nbsp USB1msTickCount);</code></td></tr>
<tr><td><code><i>  3141</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3142</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return&nbsp localContextValue;&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  3143</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>  3144</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #else</code></td></tr>
<tr><td><code><i>  3145</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return&nbsp USB1msTickCount;</code></td></tr>
<tr><td><code><i>  3146</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>  3147</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>  3148</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3149</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3150</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3151</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3152</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3153</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>  3154</i> </code></td><td><code>&nbsp /**&nbsp EOF&nbsp USBDevice.c&nbsp *****************************************************/</code></code></BODY>
</HTML>
