<HTML>
<HEAD>
<TITLE>Listing of ../framework/usb/src/usb_device_cdc.c</TITLE>
<LINK rel=stylesheet href="udf_styles.css" type="text/css">
</HEAD>
<BODY>
<table class="">
<tr><td><code><i>     1</i> </code></td><td><code>&nbsp /********************************************************************************</code></td></tr>
<tr><td><code><i>     2</i> </code></td><td><code>&nbsp &nbsp&nbsp File&nbsp Information:</code></td></tr>
<tr><td><code><i>     3</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp FileName:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp usb_function_cdc.c</code></td></tr>
<tr><td><code><i>     4</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Dependencies:&nbsp&nbsp&nbsp See&nbsp INCLUDES&nbsp section</code></td></tr>
<tr><td><code><i>     5</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Processor:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp PIC18&nbsp or&nbsp PIC24&nbsp USB&nbsp Microcontrollers</code></td></tr>
<tr><td><code><i>     6</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Hardware:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp The&nbsp code&nbsp is&nbsp natively&nbsp intended&nbsp to&nbsp be&nbsp used&nbsp on&nbsp the&nbsp following</code></td></tr>
<tr><td><code><i>     7</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp hardware&nbsp platforms:&nbsp PICDEM(TM)&nbsp FS&nbsp USB&nbsp Demo&nbsp Board,</code></td></tr>
<tr><td><code><i>     8</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp PIC18F87J50&nbsp FS&nbsp USB&nbsp Plug-In&nbsp Module,&nbsp or</code></td></tr>
<tr><td><code><i>     9</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Explorer&nbsp 16&nbsp +&nbsp PIC24&nbsp USB&nbsp PIM.&nbsp&nbsp The&nbsp firmware&nbsp may&nbsp be</code></td></tr>
<tr><td><code><i>    10</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp modified&nbsp for&nbsp use&nbsp on&nbsp other&nbsp USB&nbsp platforms&nbsp by&nbsp editing&nbsp the</code></td></tr>
<tr><td><code><i>    11</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp HardwareProfile.h&nbsp file.</code></td></tr>
<tr><td><code><i>    12</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Complier:&nbsp&nbsp&nbsp Microchip&nbsp C18&nbsp (for&nbsp PIC18)&nbsp or&nbsp C30&nbsp (for&nbsp PIC24)</code></td></tr>
<tr><td><code><i>    13</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Company:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Microchip&nbsp Technology,&nbsp Inc.</code></td></tr>
<tr><td><code><i>    14</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    15</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Software&nbsp License&nbsp Agreement:</code></td></tr>
<tr><td><code><i>    16</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    17</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp The&nbsp software&nbsp supplied&nbsp herewith&nbsp by&nbsp Microchip&nbsp Technology&nbsp Incorporated</code></td></tr>
<tr><td><code><i>    18</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp (the&nbsp "Company")&nbsp for&nbsp its&nbsp PIC(R)&nbsp Microcontroller&nbsp is&nbsp intended&nbsp and</code></td></tr>
<tr><td><code><i>    19</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp supplied&nbsp to&nbsp you,&nbsp the&nbsp Company's&nbsp customer,&nbsp for&nbsp use&nbsp solely&nbsp and</code></td></tr>
<tr><td><code><i>    20</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp exclusively&nbsp on&nbsp Microchip&nbsp PIC&nbsp Microcontroller&nbsp products.&nbsp The</code></td></tr>
<tr><td><code><i>    21</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp software&nbsp is&nbsp owned&nbsp by&nbsp the&nbsp Company&nbsp and/or&nbsp its&nbsp supplier,&nbsp and&nbsp is</code></td></tr>
<tr><td><code><i>    22</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp protected&nbsp under&nbsp applicable&nbsp copyright&nbsp laws.&nbsp All&nbsp rights&nbsp are&nbsp reserved.</code></td></tr>
<tr><td><code><i>    23</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Any&nbsp use&nbsp in&nbsp violation&nbsp of&nbsp the&nbsp foregoing&nbsp restrictions&nbsp may&nbsp subject&nbsp the</code></td></tr>
<tr><td><code><i>    24</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp user&nbsp to&nbsp criminal&nbsp sanctions&nbsp under&nbsp applicable&nbsp laws,&nbsp as&nbsp well&nbsp as&nbsp to</code></td></tr>
<tr><td><code><i>    25</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp civil&nbsp liability&nbsp for&nbsp the&nbsp breach&nbsp of&nbsp the&nbsp terms&nbsp and&nbsp conditions&nbsp of&nbsp this</code></td></tr>
<tr><td><code><i>    26</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp license.</code></td></tr>
<tr><td><code><i>    27</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    28</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp THIS&nbsp SOFTWARE&nbsp IS&nbsp PROVIDED&nbsp IN&nbsp AN&nbsp "AS&nbsp IS"&nbsp CONDITION.&nbsp NO&nbsp WARRANTIES,</code></td></tr>
<tr><td><code><i>    29</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp WHETHER&nbsp EXPRESS,&nbsp IMPLIED&nbsp OR&nbsp STATUTORY,&nbsp INCLUDING,&nbsp BUT&nbsp NOT&nbsp LIMITED</code></td></tr>
<tr><td><code><i>    30</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp TO,&nbsp IMPLIED&nbsp WARRANTIES&nbsp OF&nbsp MERCHANTABILITY&nbsp AND&nbsp FITNESS&nbsp FOR&nbsp A</code></td></tr>
<tr><td><code><i>    31</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp PARTICULAR&nbsp PURPOSE&nbsp APPLY&nbsp TO&nbsp THIS&nbsp SOFTWARE.&nbsp THE&nbsp COMPANY&nbsp SHALL&nbsp NOT,</code></td></tr>
<tr><td><code><i>    32</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp IN&nbsp ANY&nbsp CIRCUMSTANCES,&nbsp BE&nbsp LIABLE&nbsp FOR&nbsp SPECIAL,&nbsp INCIDENTAL&nbsp OR</code></td></tr>
<tr><td><code><i>    33</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp CONSEQUENTIAL&nbsp DAMAGES,&nbsp FOR&nbsp ANY&nbsp REASON&nbsp WHATSOEVER.</code></td></tr>
<tr><td><code><i>    34</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    35</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>    36</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp file&nbsp contains&nbsp all&nbsp of&nbsp functions,&nbsp macros,&nbsp definitions,&nbsp variables,</code></td></tr>
<tr><td><code><i>    37</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp datatypes,&nbsp etc.&nbsp that&nbsp are&nbsp required&nbsp for&nbsp usage&nbsp with&nbsp the&nbsp CDC&nbsp function</code></td></tr>
<tr><td><code><i>    38</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp driver.&nbsp This&nbsp file&nbsp should&nbsp be&nbsp included&nbsp in&nbsp projects&nbsp that&nbsp use&nbsp the&nbsp CDC</code></td></tr>
<tr><td><code><i>    39</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp \function&nbsp driver.</code></td></tr>
<tr><td><code><i>    40</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    41</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    42</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    43</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp file&nbsp is&nbsp located&nbsp in&nbsp the&nbsp "\&lsaquo  Install&nbsp Directory\&rsaquo  \\Microchip\\USB\\CDC</code></td></tr>
<tr><td><code><i>    44</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Device&nbsp Driver"&nbsp directory.</code></td></tr>
<tr><td><code><i>    45</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>    46</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB&nbsp CDC&nbsp Function&nbsp Driver&nbsp File</code></td></tr>
<tr><td><code><i>    47</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    48</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp file&nbsp contains&nbsp all&nbsp of&nbsp functions,&nbsp macros,&nbsp definitions,&nbsp variables,</code></td></tr>
<tr><td><code><i>    49</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp datatypes,&nbsp etc.&nbsp that&nbsp are&nbsp required&nbsp for&nbsp usage&nbsp with&nbsp the&nbsp CDC&nbsp function</code></td></tr>
<tr><td><code><i>    50</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp driver.&nbsp This&nbsp file&nbsp should&nbsp be&nbsp included&nbsp in&nbsp projects&nbsp that&nbsp use&nbsp the&nbsp CDC</code></td></tr>
<tr><td><code><i>    51</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp \function&nbsp driver.</code></td></tr>
<tr><td><code><i>    52</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    53</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp file&nbsp is&nbsp located&nbsp in&nbsp the&nbsp "\&lsaquo  Install&nbsp Directory\&rsaquo  \\Microchip\\USB\\CDC</code></td></tr>
<tr><td><code><i>    54</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Device&nbsp Driver"&nbsp directory.</code></td></tr>
<tr><td><code><i>    55</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    56</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp When&nbsp including&nbsp this&nbsp file&nbsp in&nbsp a&nbsp new&nbsp project,&nbsp this&nbsp file&nbsp can&nbsp either&nbsp be</code></td></tr>
<tr><td><code><i>    57</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp referenced&nbsp from&nbsp the&nbsp directory&nbsp in&nbsp which&nbsp it&nbsp was&nbsp installed&nbsp or&nbsp copied</code></td></tr>
<tr><td><code><i>    58</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp directly&nbsp into&nbsp the&nbsp user&nbsp application&nbsp folder.&nbsp If&nbsp the&nbsp first&nbsp method&nbsp is</code></td></tr>
<tr><td><code><i>    59</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp chosen&nbsp to&nbsp keep&nbsp the&nbsp file&nbsp located&nbsp in&nbsp the&nbsp folder&nbsp in&nbsp which&nbsp it&nbsp is&nbsp installed</code></td></tr>
<tr><td><code><i>    60</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp then&nbsp include&nbsp paths&nbsp need&nbsp to&nbsp be&nbsp added&nbsp so&nbsp that&nbsp the&nbsp library&nbsp and&nbsp the</code></td></tr>
<tr><td><code><i>    61</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp application&nbsp both&nbsp know&nbsp where&nbsp to&nbsp reference&nbsp each&nbsp others&nbsp files.&nbsp If&nbsp the</code></td></tr>
<tr><td><code><i>    62</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp application&nbsp folder&nbsp is&nbsp located&nbsp in&nbsp the&nbsp same&nbsp folder&nbsp as&nbsp the&nbsp Microchip</code></td></tr>
<tr><td><code><i>    63</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp folder&nbsp (like&nbsp the&nbsp current&nbsp demo&nbsp folders),&nbsp then&nbsp the&nbsp following&nbsp include</code></td></tr>
<tr><td><code><i>    64</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp paths&nbsp need&nbsp to&nbsp be&nbsp added&nbsp to&nbsp the&nbsp application's&nbsp project:</code></td></tr>
<tr><td><code><i>    65</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    66</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp ..\\Include</code></td></tr>
<tr><td><code><i>    67</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    68</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp .</code></td></tr>
<tr><td><code><i>    69</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    70</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp If&nbsp a&nbsp different&nbsp directory&nbsp structure&nbsp is&nbsp used,&nbsp modify&nbsp the&nbsp paths&nbsp as</code></td></tr>
<tr><td><code><i>    71</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp required.&nbsp An&nbsp example&nbsp using&nbsp absolute&nbsp paths&nbsp instead&nbsp of&nbsp relative&nbsp paths</code></td></tr>
<tr><td><code><i>    72</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp would&nbsp be&nbsp the&nbsp following:</code></td></tr>
<tr><td><code><i>    73</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    74</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp C:\\Microchip&nbsp Solutions\\Microchip\\Include</code></td></tr>
<tr><td><code><i>    75</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    76</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp C:\\Microchip&nbsp Solutions\\My&nbsp Demo&nbsp Application&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>    77</i> </code></td><td><code>&nbsp &nbsp&nbsp ********************************************************************************/</code></td></tr>
<tr><td><code><i>    78</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    79</i> </code></td><td><code>&nbsp /********************************************************************</code></td></tr>
<tr><td><code><i>    80</i> </code></td><td><code>&nbsp &nbsp Change&nbsp History:</code></td></tr>
<tr><td><code><i>    81</i> </code></td><td><code>&nbsp &nbsp&nbsp Rev&nbsp&nbsp&nbsp&nbsp Description</code></td></tr>
<tr><td><code><i>    82</i> </code></td><td><code>&nbsp &nbsp&nbsp ----&nbsp&nbsp&nbsp -----------</code></td></tr>
<tr><td><code><i>    83</i> </code></td><td><code>&nbsp &nbsp&nbsp 2.3&nbsp&nbsp&nbsp&nbsp Decricated&nbsp the&nbsp mUSBUSARTIsTxTrfReady()&nbsp macro.&nbsp&nbsp It&nbsp is&nbsp </code></td></tr>
<tr><td><code><i>    84</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp replaced&nbsp by&nbsp the&nbsp USBUSARTIsTxTrfReady()&nbsp function.</code></td></tr>
<tr><td><code><i>    85</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    86</i> </code></td><td><code>&nbsp &nbsp&nbsp 2.6&nbsp&nbsp&nbsp&nbsp Minor&nbsp definition&nbsp changes</code></td></tr>
<tr><td><code><i>    87</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    88</i> </code></td><td><code>&nbsp &nbsp&nbsp 2.6a&nbsp&nbsp&nbsp No&nbsp Changes</code></td></tr>
<tr><td><code><i>    89</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    90</i> </code></td><td><code>&nbsp &nbsp&nbsp 2.7&nbsp&nbsp&nbsp&nbsp Fixed&nbsp error&nbsp in&nbsp the&nbsp part&nbsp support&nbsp list&nbsp of&nbsp the&nbsp variables&nbsp section</code></td></tr>
<tr><td><code><i>    91</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp where&nbsp the&nbsp address&nbsp of&nbsp the&nbsp CDC&nbsp variables&nbsp are&nbsp defined.&nbsp&nbsp The&nbsp </code></td></tr>
<tr><td><code><i>    92</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp PIC18F2553&nbsp was&nbsp incorrectly&nbsp named&nbsp PIC18F2453&nbsp and&nbsp the&nbsp PIC18F4558</code></td></tr>
<tr><td><code><i>    93</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp was&nbsp incorrectly&nbsp named&nbsp PIC18F4458.</code></td></tr>
<tr><td><code><i>    94</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    95</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp http://www.microchip.com/forums/fb.aspx?m=487397</code></td></tr>
<tr><td><code><i>    96</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>    97</i> </code></td><td><code>&nbsp &nbsp&nbsp 2.8&nbsp&nbsp&nbsp&nbsp Minor&nbsp change&nbsp to&nbsp CDCInitEP()&nbsp to&nbsp enhance&nbsp ruggedness&nbsp in</code></td></tr>
<tr><td><code><i>    98</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp multithreaded&nbsp usage&nbsp scenarios.</code></td></tr>
<tr><td><code><i>    99</i> </code></td><td><code>&nbsp &nbsp&nbsp </code></td></tr>
<tr><td><code><i>   100</i> </code></td><td><code>&nbsp &nbsp&nbsp 2.9b&nbsp&nbsp&nbsp Updated&nbsp to&nbsp implement&nbsp optional&nbsp support&nbsp for&nbsp DTS&nbsp reporting.</code></td></tr>
<tr><td><code><i>   101</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   102</i> </code></td><td><code>&nbsp ********************************************************************/</code></td></tr>
<tr><td><code><i>   103</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   104</i> </code></td><td><code>&nbsp /**&nbsp I&nbsp N&nbsp C&nbsp L&nbsp U&nbsp D&nbsp E&nbsp S&nbsp **********************************************************/</code></td></tr>
<tr><td><code><i>   105</i> </code></td><td><code>&nbsp #include&nbsp "system.h"</code></td></tr>
<tr><td><code><i>   106</i> </code></td><td><code>&nbsp #include&nbsp "usb.h"</code></td></tr>
<tr><td><code><i>   107</i> </code></td><td><code>&nbsp #include&nbsp "usb_device_cdc.h"</code></td></tr>
<tr><td><code><i>   108</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   109</i> </code></td><td><code>&nbsp #ifdef&nbsp USB_USE_CDC</code></td></tr>
<tr><td><code><i>   110</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   111</i> </code></td><td><code>&nbsp #ifndef&nbsp FIXED_ADDRESS_MEMORY</code></td></tr>
<tr><td><code><i>   112</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #define&nbsp IN_DATA_BUFFER_ADDRESS_TAG</code></td></tr>
<tr><td><code><i>   113</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #define&nbsp OUT_DATA_BUFFER_ADDRESS_TAG</code></td></tr>
<tr><td><code><i>   114</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #define&nbsp CONTROL_BUFFER_ADDRESS_TAG</code></td></tr>
<tr><td><code><i>   115</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>   116</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   117</i> </code></td><td><code>&nbsp #if&nbsp !defined(IN_DATA_BUFFER_ADDRESS_TAG)&nbsp ||&nbsp !defined(OUT_DATA_BUFFER_ADDRESS_TAG)&nbsp ||&nbsp !defined(CONTROL_BUFFER_ADDRESS_TAG)</code></td></tr>
<tr><td><code><i>   118</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #error&nbsp "One&nbsp of&nbsp the&nbsp fixed&nbsp memory&nbsp address&nbsp definitions&nbsp is&nbsp not&nbsp defined.&nbsp&nbsp Please&nbsp define&nbsp the&nbsp required&nbsp address&nbsp tags&nbsp for&nbsp the&nbsp required&nbsp buffers."</code></td></tr>
<tr><td><code><i>   119</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>   120</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   121</i> </code></td><td><code>&nbsp /**&nbsp V&nbsp A&nbsp R&nbsp I&nbsp A&nbsp B&nbsp L&nbsp E&nbsp S&nbsp ********************************************************/</code></td></tr>
<tr><td><code><i>   122</i> </code></td><td><code>&nbsp volatile&nbsp unsigned&nbsp char&nbsp cdc_data_tx[CDC_DATA_IN_EP_SIZE]&nbsp IN_DATA_BUFFER_ADDRESS_TAG;</code></td></tr>
<tr><td><code><i>   123</i> </code></td><td><code>&nbsp volatile&nbsp unsigned&nbsp char&nbsp cdc_data_rx[CDC_DATA_OUT_EP_SIZE]&nbsp OUT_DATA_BUFFER_ADDRESS_TAG;</code></td></tr>
<tr><td><code><i>   124</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   125</i> </code></td><td><code>&nbsp typedef&nbsp union</code></td></tr>
<tr><td><code><i>   126</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   127</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp LINE_CODING&nbsp lineCoding;</code></td></tr>
<tr><td><code><i>   128</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp CDC_NOTICE&nbsp cdcNotice;</code></td></tr>
<tr><td><code><i>   129</i> </code></td><td><code>&nbsp }&nbsp CONTROL_BUFFER;</code></td></tr>
<tr><td><code><i>   130</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   131</i> </code></td><td><code>&nbsp //static&nbsp CONTROL_BUFFER&nbsp controlBuffer&nbsp CONTROL_BUFFER_ADDRESS_TAG;</code></td></tr>
<tr><td><code><i>   132</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   133</i> </code></td><td><code>&nbsp LINE_CODING&nbsp line_coding;&nbsp&nbsp&nbsp&nbsp //&nbsp Buffer&nbsp to&nbsp store&nbsp line&nbsp coding&nbsp information</code></td></tr>
<tr><td><code><i>   134</i> </code></td><td><code>&nbsp CDC_NOTICE&nbsp cdc_notice;</code></td></tr>
<tr><td><code><i>   135</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   136</i> </code></td><td><code>&nbsp #if&nbsp defined(USB_CDC_SUPPORT_DSR_REPORTING)</code></td></tr>
<tr><td><code><i>   137</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp SERIAL_STATE_NOTIFICATION&nbsp SerialStatePacket;</code></td></tr>
<tr><td><code><i>   138</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>   139</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   140</i> </code></td><td><code>&nbsp uint8_t&nbsp cdc_rx_len;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp total&nbsp rx&nbsp length</code></td></tr>
<tr><td><code><i>   141</i> </code></td><td><code>&nbsp uint8_t&nbsp cdc_trf_state;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp States&nbsp are&nbsp defined&nbsp cdc.h</code></td></tr>
<tr><td><code><i>   142</i> </code></td><td><code>&nbsp POINTER&nbsp pCDCSrc;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Dedicated&nbsp source&nbsp pointer</code></td></tr>
<tr><td><code><i>   143</i> </code></td><td><code>&nbsp POINTER&nbsp pCDCDst;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Dedicated&nbsp destination&nbsp pointer</code></td></tr>
<tr><td><code><i>   144</i> </code></td><td><code>&nbsp uint8_t&nbsp cdc_tx_len;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp total&nbsp tx&nbsp length</code></td></tr>
<tr><td><code><i>   145</i> </code></td><td><code>&nbsp uint8_t&nbsp cdc_mem_type;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp _ROM,&nbsp _RAM</code></td></tr>
<tr><td><code><i>   146</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   147</i> </code></td><td><code>&nbsp USB_HANDLE&nbsp CDCDataOutHandle;</code></td></tr>
<tr><td><code><i>   148</i> </code></td><td><code>&nbsp USB_HANDLE&nbsp CDCDataInHandle;</code></td></tr>
<tr><td><code><i>   149</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   150</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   151</i> </code></td><td><code>&nbsp CONTROL_SIGNAL_BITMAP&nbsp control_signal_bitmap;</code></td></tr>
<tr><td><code><i>   152</i> </code></td><td><code>&nbsp uint32_t&nbsp BaudRateGen;&nbsp&nbsp &nbsp&nbsp &nbsp&nbsp //&nbsp BRG&nbsp value&nbsp calculated&nbsp from&nbsp baudrate</code></td></tr>
<tr><td><code><i>   153</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   154</i> </code></td><td><code>&nbsp #if&nbsp defined(USB_CDC_SUPPORT_DSR_REPORTING)</code></td></tr>
<tr><td><code><i>   155</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp BM_SERIAL_STATE&nbsp SerialStateBitmap;</code></td></tr>
<tr><td><code><i>   156</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp BM_SERIAL_STATE&nbsp OldSerialStateBitmap;</code></td></tr>
<tr><td><code><i>   157</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB_HANDLE&nbsp CDCNotificationInHandle;</code></td></tr>
<tr><td><code><i>   158</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>   159</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   160</i> </code></td><td><code>&nbsp /**************************************************************************</code></td></tr>
<tr><td><code><i>   161</i> </code></td><td><code>&nbsp &nbsp&nbsp SEND_ENCAPSULATED_COMMAND&nbsp and&nbsp GET_ENCAPSULATED_RESPONSE&nbsp are&nbsp required</code></td></tr>
<tr><td><code><i>   162</i> </code></td><td><code>&nbsp &nbsp&nbsp requests&nbsp according&nbsp to&nbsp the&nbsp CDC&nbsp specification.</code></td></tr>
<tr><td><code><i>   163</i> </code></td><td><code>&nbsp &nbsp&nbsp However,&nbsp it&nbsp is&nbsp not&nbsp really&nbsp being&nbsp used&nbsp here,&nbsp therefore&nbsp a&nbsp dummy&nbsp buffer&nbsp is</code></td></tr>
<tr><td><code><i>   164</i> </code></td><td><code>&nbsp &nbsp&nbsp used&nbsp for&nbsp conformance.</code></td></tr>
<tr><td><code><i>   165</i> </code></td><td><code>&nbsp &nbsp **************************************************************************/</code></td></tr>
<tr><td><code><i>   166</i> </code></td><td><code>&nbsp #define&nbsp dummy_length&nbsp&nbsp&nbsp&nbsp 0x08</code></td></tr>
<tr><td><code><i>   167</i> </code></td><td><code>&nbsp uint8_t&nbsp dummy_encapsulated_cmd_response[dummy_length];</code></td></tr>
<tr><td><code><i>   168</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   169</i> </code></td><td><code>&nbsp #if&nbsp defined(USB_CDC_SET_LINE_CODING_HANDLER)</code></td></tr>
<tr><td><code><i>   170</i> </code></td><td><code>&nbsp CTRL_TRF_RETURN&nbsp USB_CDC_SET_LINE_CODING_HANDLER(CTRL_TRF_PARAMS);</code></td></tr>
<tr><td><code><i>   171</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>   172</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   173</i> </code></td><td><code>&nbsp /**&nbsp P&nbsp R&nbsp I&nbsp V&nbsp A&nbsp T&nbsp E&nbsp&nbsp P&nbsp R&nbsp O&nbsp T&nbsp O&nbsp T&nbsp Y&nbsp P&nbsp E&nbsp S&nbsp ***************************************/</code></td></tr>
<tr><td><code><i>   174</i> </code></td><td><code>&nbsp void&nbsp USBCDCSetLineCoding(void);</code></td></tr>
<tr><td><code><i>   175</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   176</i> </code></td><td><code>&nbsp /**&nbsp D&nbsp E&nbsp C&nbsp L&nbsp A&nbsp R&nbsp A&nbsp T&nbsp I&nbsp O&nbsp N&nbsp S&nbsp **************************************************/</code></td></tr>
<tr><td><code><i>   177</i> </code></td><td><code>&nbsp //#pragma&nbsp code</code></td></tr>
<tr><td><code><i>   178</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   179</i> </code></td><td><code>&nbsp /**&nbsp C&nbsp L&nbsp A&nbsp S&nbsp S&nbsp&nbsp S&nbsp P&nbsp E&nbsp C&nbsp I&nbsp F&nbsp I&nbsp C&nbsp&nbsp R&nbsp E&nbsp Q&nbsp ****************************************/</code></td></tr>
<tr><td><code><i>   180</i> </code></td><td><code>&nbsp /******************************************************************************</code></td></tr>
<tr><td><code><i>   181</i> </code></td><td><code>&nbsp &nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   182</i> </code></td><td><code>&nbsp &nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBCheckCDCRequest(void)</code></td></tr>
<tr><td><code><i>   183</i> </code></td><td><code>&nbsp &nbsp </code></td></tr>
<tr><td><code><i>   184</i> </code></td><td><code>&nbsp &nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   185</i> </code></td><td><code>&nbsp &nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp routine&nbsp checks&nbsp the&nbsp most&nbsp recently&nbsp received&nbsp SETUP&nbsp data&nbsp packet&nbsp to&nbsp </code></td></tr>
<tr><td><code><i>   186</i> </code></td><td><code>&nbsp &nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp see&nbsp if&nbsp the&nbsp request&nbsp is&nbsp specific&nbsp to&nbsp the&nbsp CDC&nbsp class.&nbsp&nbsp If&nbsp the&nbsp request&nbsp was</code></td></tr>
<tr><td><code><i>   187</i> </code></td><td><code>&nbsp &nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp a&nbsp CDC&nbsp specific&nbsp request,&nbsp this&nbsp function&nbsp will&nbsp take&nbsp care&nbsp of&nbsp handling&nbsp the</code></td></tr>
<tr><td><code><i>   188</i> </code></td><td><code>&nbsp &nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp request&nbsp and&nbsp responding&nbsp appropriately.</code></td></tr>
<tr><td><code><i>   189</i> </code></td><td><code>&nbsp &nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   190</i> </code></td><td><code>&nbsp &nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp PreCondition:</code></td></tr>
<tr><td><code><i>   191</i> </code></td><td><code>&nbsp &nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp should&nbsp only&nbsp be&nbsp called&nbsp after&nbsp a&nbsp control&nbsp transfer&nbsp SETUP</code></td></tr>
<tr><td><code><i>   192</i> </code></td><td><code>&nbsp &nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp packet&nbsp has&nbsp arrived&nbsp from&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>   193</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   194</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Parameters:</code></td></tr>
<tr><td><code><i>   195</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>   196</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   197</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Return&nbsp Values:</code></td></tr>
<tr><td><code><i>   198</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>   199</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   200</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>   201</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp does&nbsp not&nbsp change&nbsp status&nbsp or&nbsp do&nbsp anything&nbsp if&nbsp the&nbsp SETUP&nbsp packet</code></td></tr>
<tr><td><code><i>   202</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp did&nbsp not&nbsp contain&nbsp a&nbsp CDC&nbsp class&nbsp specific&nbsp request.&nbsp&nbsp &nbsp&nbsp &nbsp </code></td></tr>
<tr><td><code><i>   203</i> </code></td><td><code>&nbsp &nbsp&nbsp *****************************************************************************/</code></td></tr>
<tr><td><code><i>   204</i> </code></td><td><code>&nbsp void&nbsp USBCheckCDCRequest(void)</code></td></tr>
<tr><td><code><i>   205</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   206</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   207</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp If&nbsp request&nbsp recipient&nbsp is&nbsp not&nbsp an&nbsp interface&nbsp then&nbsp return</code></td></tr>
<tr><td><code><i>   208</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   209</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(SetupPkt.Recipient&nbsp !=&nbsp USB_SETUP_RECIPIENT_INTERFACE_BITFIELD)&nbsp return;</code></td></tr>
<tr><td><code><i>   210</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   211</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   212</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp If&nbsp request&nbsp type&nbsp is&nbsp not&nbsp class-specific&nbsp then&nbsp return</code></td></tr>
<tr><td><code><i>   213</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   214</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(SetupPkt.RequestType&nbsp !=&nbsp USB_SETUP_TYPE_CLASS_BITFIELD)&nbsp return;</code></td></tr>
<tr><td><code><i>   215</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   216</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   217</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Interface&nbsp ID&nbsp must&nbsp match&nbsp interface&nbsp numbers&nbsp associated&nbsp with</code></td></tr>
<tr><td><code><i>   218</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp CDC&nbsp class,&nbsp else&nbsp return</code></td></tr>
<tr><td><code><i>   219</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   220</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if((SetupPkt.bIntfID&nbsp !=&nbsp CDC_COMM_INTF_ID)&&</code></td></tr>
<tr><td><code><i>   221</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (SetupPkt.bIntfID&nbsp !=&nbsp CDC_DATA_INTF_ID))&nbsp return;</code></td></tr>
<tr><td><code><i>   222</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   223</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp switch(SetupPkt.bRequest)</code></td></tr>
<tr><td><code><i>   224</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   225</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //******&nbsp These&nbsp commands&nbsp are&nbsp required&nbsp ******//</code></td></tr>
<tr><td><code><i>   226</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp SEND_ENCAPSULATED_COMMAND:</code></td></tr>
<tr><td><code><i>   227</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //send&nbsp the&nbsp packet</code></td></tr>
<tr><td><code><i>   228</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].pSrc.bRam&nbsp =&nbsp (uint8_t*)&dummy_encapsulated_cmd_response;</code></td></tr>
<tr><td><code><i>   229</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].wCount.Val&nbsp =&nbsp dummy_length;</code></td></tr>
<tr><td><code><i>   230</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.ctrl_trf_mem&nbsp =&nbsp USB_EP0_RAM;</code></td></tr>
<tr><td><code><i>   231</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>   232</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>   233</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp GET_ENCAPSULATED_RESPONSE:</code></td></tr>
<tr><td><code><i>   234</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Populate&nbsp dummy_encapsulated_cmd_response&nbsp first.</code></td></tr>
<tr><td><code><i>   235</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].pSrc.bRam&nbsp =&nbsp (uint8_t*)&dummy_encapsulated_cmd_response;</code></td></tr>
<tr><td><code><i>   236</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>   237</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>   238</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //******&nbsp End&nbsp of&nbsp required&nbsp commands&nbsp ******//</code></td></tr>
<tr><td><code><i>   239</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   240</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D1)</code></td></tr>
<tr><td><code><i>   241</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp SET_LINE_CODING:</code></td></tr>
<tr><td><code><i>   242</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp outPipes[0].wCount.Val&nbsp =&nbsp SetupPkt.wLength;</code></td></tr>
<tr><td><code><i>   243</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp outPipes[0].pDst.bRam&nbsp =&nbsp (uint8_t*)LINE_CODING_TARGET;</code></td></tr>
<tr><td><code><i>   244</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp outPipes[0].pFunc&nbsp =&nbsp LINE_CODING_PFUNC;</code></td></tr>
<tr><td><code><i>   245</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp outPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>   246</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>   247</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   248</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp GET_LINE_CODING:</code></td></tr>
<tr><td><code><i>   249</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBEP0SendRAMPtr(</code></td></tr>
<tr><td><code><i>   250</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (uint8_t*)&line_coding,</code></td></tr>
<tr><td><code><i>   251</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp LINE_CODING_LENGTH,</code></td></tr>
<tr><td><code><i>   252</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USB_EP0_INCLUDE_ZERO);</code></td></tr>
<tr><td><code><i>   253</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>   254</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   255</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp SET_CONTROL_LINE_STATE:</code></td></tr>
<tr><td><code><i>   256</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp control_signal_bitmap._byte&nbsp =&nbsp (uint8_t)SetupPkt.wValue;</code></td></tr>
<tr><td><code><i>   257</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //------------------------------------------------------------------&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   258</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //One&nbsp way&nbsp to&nbsp control&nbsp the&nbsp RTS&nbsp pin&nbsp is&nbsp to&nbsp allow&nbsp the&nbsp USB&nbsp host&nbsp to&nbsp decide&nbsp the&nbsp value</code></td></tr>
<tr><td><code><i>   259</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //that&nbsp should&nbsp be&nbsp output&nbsp on&nbsp the&nbsp RTS&nbsp pin.&nbsp&nbsp Although&nbsp RTS&nbsp and&nbsp CTS&nbsp pin&nbsp functions</code></td></tr>
<tr><td><code><i>   260</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //are&nbsp technically&nbsp intended&nbsp for&nbsp UART&nbsp hardware&nbsp based&nbsp flow&nbsp control,&nbsp some&nbsp legacy</code></td></tr>
<tr><td><code><i>   261</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //UART&nbsp devices&nbsp use&nbsp the&nbsp RTS&nbsp pin&nbsp like&nbsp a&nbsp "general&nbsp purpose"&nbsp output&nbsp pin&nbsp </code></td></tr>
<tr><td><code><i>   262</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //from&nbsp the&nbsp PC&nbsp host.&nbsp&nbsp In&nbsp this&nbsp usage&nbsp model,&nbsp the&nbsp RTS&nbsp pin&nbsp is&nbsp not&nbsp related</code></td></tr>
<tr><td><code><i>   263</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //to&nbsp flow&nbsp control&nbsp for&nbsp RX/TX.</code></td></tr>
<tr><td><code><i>   264</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //In&nbsp this&nbsp scenario,&nbsp the&nbsp USB&nbsp host&nbsp would&nbsp want&nbsp to&nbsp be&nbsp able&nbsp to&nbsp control&nbsp the&nbsp RTS</code></td></tr>
<tr><td><code><i>   265</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //pin,&nbsp and&nbsp the&nbsp below&nbsp line&nbsp of&nbsp code&nbsp should&nbsp be&nbsp uncommented.</code></td></tr>
<tr><td><code><i>   266</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //However,&nbsp if&nbsp the&nbsp intention&nbsp is&nbsp to&nbsp implement&nbsp true&nbsp RTS/CTS&nbsp flow&nbsp control</code></td></tr>
<tr><td><code><i>   267</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //for&nbsp the&nbsp RX/TX&nbsp pair,&nbsp then&nbsp this&nbsp application&nbsp firmware&nbsp should&nbsp override</code></td></tr>
<tr><td><code><i>   268</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //the&nbsp USB&nbsp host's&nbsp setting&nbsp for&nbsp RTS,&nbsp and&nbsp instead&nbsp generate&nbsp a&nbsp real&nbsp RTS&nbsp signal,</code></td></tr>
<tr><td><code><i>   269</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //based&nbsp on&nbsp the&nbsp amount&nbsp of&nbsp remaining&nbsp buffer&nbsp space&nbsp available&nbsp for&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>   270</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //actual&nbsp hardware&nbsp UART&nbsp of&nbsp this&nbsp microcontroller.&nbsp&nbsp In&nbsp this&nbsp case,&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>   271</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //below&nbsp code&nbsp should&nbsp be&nbsp left&nbsp commented&nbsp out,&nbsp but&nbsp instead&nbsp RTS&nbsp should&nbsp be&nbsp </code></td></tr>
<tr><td><code><i>   272</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //controlled&nbsp in&nbsp the&nbsp application&nbsp firmware&nbsp reponsible&nbsp for&nbsp operating&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>   273</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //hardware&nbsp UART&nbsp of&nbsp this&nbsp microcontroller.</code></td></tr>
<tr><td><code><i>   274</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //---------&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   275</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //CONFIGURE_RTS(control_signal_bitmap.CARRIER_CONTROL);&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   276</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //------------------------------------------------------------------&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   277</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   278</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(USB_CDC_SUPPORT_DTR_SIGNALING)</code></td></tr>
<tr><td><code><i>   279</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(control_signal_bitmap.DTE_PRESENT&nbsp ==&nbsp 1)</code></td></tr>
<tr><td><code><i>   280</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   281</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UART_DTR&nbsp =&nbsp USB_CDC_DTR_ACTIVE_LEVEL;</code></td></tr>
<tr><td><code><i>   282</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   283</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>   284</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   285</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UART_DTR&nbsp =&nbsp (USB_CDC_DTR_ACTIVE_LEVEL&nbsp ^&nbsp 1);</code></td></tr>
<tr><td><code><i>   286</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   287</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   288</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>   289</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>   290</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   291</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   292</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(USB_CDC_SUPPORT_ABSTRACT_CONTROL_MANAGEMENT_CAPABILITIES_D2)</code></td></tr>
<tr><td><code><i>   293</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp SEND_BREAK:&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Optional</code></td></tr>
<tr><td><code><i>   294</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp inPipes[0].info.bits.busy&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>   295</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if&nbsp (SetupPkt.wValue&nbsp ==&nbsp 0xFFFF)&nbsp&nbsp //0xFFFF&nbsp means&nbsp send&nbsp break&nbsp indefinitely&nbsp until&nbsp a&nbsp new&nbsp SEND_BREAK&nbsp command&nbsp is&nbsp received</code></td></tr>
<tr><td><code><i>   296</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   297</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UART_Tx&nbsp =&nbsp 0;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Prepare&nbsp to&nbsp drive&nbsp TX&nbsp low&nbsp (for&nbsp break&nbsp signalling)</code></td></tr>
<tr><td><code><i>   298</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UART_TRISTx&nbsp =&nbsp 0;&nbsp&nbsp&nbsp //&nbsp Make&nbsp sure&nbsp TX&nbsp pin&nbsp configured&nbsp as&nbsp an&nbsp output</code></td></tr>
<tr><td><code><i>   299</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UART_ENABLE&nbsp =&nbsp 0;&nbsp&nbsp&nbsp //&nbsp Turn&nbsp off&nbsp USART&nbsp (to&nbsp relinquish&nbsp TX&nbsp pin&nbsp control)</code></td></tr>
<tr><td><code><i>   300</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   301</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else&nbsp if&nbsp (SetupPkt.wValue&nbsp ==&nbsp 0x0000)&nbsp //0x0000&nbsp means&nbsp stop&nbsp sending&nbsp indefinite&nbsp break&nbsp </code></td></tr>
<tr><td><code><i>   302</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   303</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp &nbsp&nbsp&nbsp &nbsp&nbsp&nbsp UART_ENABLE&nbsp =&nbsp 1;&nbsp&nbsp&nbsp //&nbsp turn&nbsp on&nbsp USART</code></td></tr>
<tr><td><code><i>   304</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UART_TRISTx&nbsp =&nbsp 1;&nbsp&nbsp&nbsp //&nbsp Make&nbsp TX&nbsp pin&nbsp an&nbsp input</code></td></tr>
<tr><td><code><i>   305</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   306</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>   307</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   308</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Send&nbsp break&nbsp signalling&nbsp on&nbsp the&nbsp pin&nbsp for&nbsp (SetupPkt.wValue)&nbsp milliseconds</code></td></tr>
<tr><td><code><i>   309</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UART_SEND_BREAK();</code></td></tr>
<tr><td><code><i>   310</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   311</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>   312</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   313</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp default:</code></td></tr>
<tr><td><code><i>   314</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>   315</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp switch(SetupPkt.bRequest)</code></td></tr>
<tr><td><code><i>   316</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   317</i> </code></td><td><code>&nbsp }//end&nbsp USBCheckCDCRequest</code></td></tr>
<tr><td><code><i>   318</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   319</i> </code></td><td><code>&nbsp /**&nbsp U&nbsp S&nbsp E&nbsp R&nbsp&nbsp A&nbsp P&nbsp I&nbsp ***********************************************************/</code></td></tr>
<tr><td><code><i>   320</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   321</i> </code></td><td><code>&nbsp /**************************************************************************</code></td></tr>
<tr><td><code><i>   322</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   323</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp CDCInitEP(void)</code></td></tr>
<tr><td><code><i>   324</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   325</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>   326</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp initializes&nbsp the&nbsp CDC&nbsp function&nbsp driver.&nbsp This&nbsp function&nbsp should</code></td></tr>
<tr><td><code><i>   327</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp be&nbsp called&nbsp after&nbsp the&nbsp SET_CONFIGURATION&nbsp command&nbsp (ex:&nbsp within&nbsp the&nbsp context&nbsp of</code></td></tr>
<tr><td><code><i>   328</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp USBCBInitEP()&nbsp function).</code></td></tr>
<tr><td><code><i>   329</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   330</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp initializes&nbsp the&nbsp CDC&nbsp function&nbsp driver.&nbsp This&nbsp function&nbsp sets</code></td></tr>
<tr><td><code><i>   331</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp default&nbsp line&nbsp coding&nbsp (baud&nbsp rate,&nbsp bit&nbsp parity,&nbsp number&nbsp of&nbsp data&nbsp bits,</code></td></tr>
<tr><td><code><i>   332</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp and&nbsp format).&nbsp This&nbsp function&nbsp also&nbsp enables&nbsp the&nbsp endpoints&nbsp and&nbsp prepares&nbsp for</code></td></tr>
<tr><td><code><i>   333</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp first&nbsp transfer&nbsp from&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>   334</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   335</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp should&nbsp be&nbsp called&nbsp after&nbsp the&nbsp SET_CONFIGURATION&nbsp command.</code></td></tr>
<tr><td><code><i>   336</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp is&nbsp most&nbsp simply&nbsp done&nbsp by&nbsp calling&nbsp this&nbsp function&nbsp from&nbsp the</code></td></tr>
<tr><td><code><i>   337</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBCBInitEP()&nbsp function.</code></td></tr>
<tr><td><code><i>   338</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   339</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Typical&nbsp Usage:</code></td></tr>
<tr><td><code><i>   340</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  code&rsaquo  </code></td></tr>
<tr><td><code><i>   341</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp USBCBInitEP(void)</code></td></tr>
<tr><td><code><i>   342</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   343</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CDCInitEP();</code></td></tr>
<tr><td><code><i>   344</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   345</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  /code&rsaquo  </code></td></tr>
<tr><td><code><i>   346</i> </code></td><td><code>&nbsp &nbsp&nbsp Conditions:</code></td></tr>
<tr><td><code><i>   347</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp None</code></td></tr>
<tr><td><code><i>   348</i> </code></td><td><code>&nbsp &nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>   349</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp None&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   350</i> </code></td><td><code>&nbsp &nbsp&nbsp **************************************************************************/</code></td></tr>
<tr><td><code><i>   351</i> </code></td><td><code>&nbsp void&nbsp CDCInitEP(void)</code></td></tr>
<tr><td><code><i>   352</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   353</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Abstract&nbsp line&nbsp coding&nbsp information</code></td></tr>
<tr><td><code><i>   354</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp line_coding.dwDTERate&nbsp&nbsp&nbsp =&nbsp 19200;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp baud&nbsp rate</code></td></tr>
<tr><td><code><i>   355</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp line_coding.bCharFormat&nbsp =&nbsp 0x00;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp 1&nbsp stop&nbsp bit</code></td></tr>
<tr><td><code><i>   356</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp line_coding.bParityType&nbsp =&nbsp 0x00;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp None</code></td></tr>
<tr><td><code><i>   357</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp line_coding.bDataBits&nbsp =&nbsp 0x08;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp 5,6,7,8,&nbsp or&nbsp 16</code></td></tr>
<tr><td><code><i>   358</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   359</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp cdc_rx_len&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   360</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   361</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   362</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Do&nbsp not&nbsp have&nbsp to&nbsp init&nbsp Cnt&nbsp of&nbsp IN&nbsp pipes&nbsp here.</code></td></tr>
<tr><td><code><i>   363</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Reason:&nbsp&nbsp Number&nbsp of&nbsp BYTEs&nbsp to&nbsp send&nbsp to&nbsp the&nbsp host</code></td></tr>
<tr><td><code><i>   364</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp varies&nbsp from&nbsp one&nbsp transaction&nbsp to</code></td></tr>
<tr><td><code><i>   365</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp another.&nbsp Cnt&nbsp should&nbsp equal&nbsp the&nbsp exact</code></td></tr>
<tr><td><code><i>   366</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp number&nbsp of&nbsp BYTEs&nbsp to&nbsp transmit&nbsp for</code></td></tr>
<tr><td><code><i>   367</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp a&nbsp given&nbsp IN&nbsp transaction.</code></td></tr>
<tr><td><code><i>   368</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp This&nbsp number&nbsp of&nbsp BYTEs&nbsp will&nbsp only</code></td></tr>
<tr><td><code><i>   369</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp be&nbsp known&nbsp right&nbsp before&nbsp the&nbsp data&nbsp is</code></td></tr>
<tr><td><code><i>   370</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp sent.</code></td></tr>
<tr><td><code><i>   371</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   372</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBEnableEndpoint(CDC_COMM_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);</code></td></tr>
<tr><td><code><i>   373</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBEnableEndpoint(CDC_DATA_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);</code></td></tr>
<tr><td><code><i>   374</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   375</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp CDCDataOutHandle&nbsp =&nbsp USBRxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_rx,sizeof(cdc_data_rx));</code></td></tr>
<tr><td><code><i>   376</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp CDCDataInHandle&nbsp =&nbsp NULL;</code></td></tr>
<tr><td><code><i>   377</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   378</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #if&nbsp defined(USB_CDC_SUPPORT_DSR_REPORTING)</code></td></tr>
<tr><td><code><i>   379</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp CDCNotificationInHandle&nbsp =&nbsp NULL;</code></td></tr>
<tr><td><code><i>   380</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp mInitDTSPin();&nbsp&nbsp //Configure&nbsp DTS&nbsp as&nbsp a&nbsp digital&nbsp input</code></td></tr>
<tr><td><code><i>   381</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp SerialStateBitmap.byte&nbsp =&nbsp 0x00;</code></td></tr>
<tr><td><code><i>   382</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp OldSerialStateBitmap.byte&nbsp =&nbsp !SerialStateBitmap.byte;&nbsp&nbsp&nbsp&nbsp //To&nbsp force&nbsp firmware&nbsp to&nbsp send&nbsp an&nbsp initial&nbsp serial&nbsp state&nbsp packet&nbsp to&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>   383</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Prepare&nbsp a&nbsp SerialState&nbsp notification&nbsp element&nbsp packet&nbsp (contains&nbsp info&nbsp like&nbsp DSR&nbsp state)</code></td></tr>
<tr><td><code><i>   384</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SerialStatePacket.bmRequestType&nbsp =&nbsp 0xA1;&nbsp //Always&nbsp 0xA1&nbsp for&nbsp this&nbsp type&nbsp of&nbsp packet.</code></td></tr>
<tr><td><code><i>   385</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SerialStatePacket.bNotification&nbsp =&nbsp SERIAL_STATE;</code></td></tr>
<tr><td><code><i>   386</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SerialStatePacket.wValue&nbsp =&nbsp 0x0000;&nbsp&nbsp //Always&nbsp 0x0000&nbsp for&nbsp this&nbsp type&nbsp of&nbsp packet</code></td></tr>
<tr><td><code><i>   387</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SerialStatePacket.wIndex&nbsp =&nbsp CDC_COMM_INTF_ID;&nbsp&nbsp //Interface&nbsp number&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   388</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SerialStatePacket.SerialState.byte&nbsp =&nbsp 0x00;</code></td></tr>
<tr><td><code><i>   389</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SerialStatePacket.Reserved&nbsp =&nbsp 0x00;</code></td></tr>
<tr><td><code><i>   390</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SerialStatePacket.wLength&nbsp =&nbsp 0x02;&nbsp&nbsp&nbsp //Always&nbsp 2&nbsp bytes&nbsp for&nbsp this&nbsp type&nbsp of&nbsp packet&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   391</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CDCNotificationHandler();</code></td></tr>
<tr><td><code><i>   392</i> </code></td><td><code>&nbsp &nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   393</i> </code></td><td><code>&nbsp &nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   394</i> </code></td><td><code>&nbsp &nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(USB_CDC_SUPPORT_DTR_SIGNALING)</code></td></tr>
<tr><td><code><i>   395</i> </code></td><td><code>&nbsp &nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp mInitDTRPin();</code></td></tr>
<tr><td><code><i>   396</i> </code></td><td><code>&nbsp &nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   397</i> </code></td><td><code>&nbsp &nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   398</i> </code></td><td><code>&nbsp &nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp #if&nbsp defined(USB_CDC_SUPPORT_HARDWARE_FLOW_CONTROL)</code></td></tr>
<tr><td><code><i>   399</i> </code></td><td><code>&nbsp &nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp mInitRTSPin();</code></td></tr>
<tr><td><code><i>   400</i> </code></td><td><code>&nbsp &nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp mInitCTSPin();</code></td></tr>
<tr><td><code><i>   401</i> </code></td><td><code>&nbsp &nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp #endif</code></td></tr>
<tr><td><code><i>   402</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   403</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp cdc_trf_state&nbsp =&nbsp CDC_TX_READY;</code></td></tr>
<tr><td><code><i>   404</i> </code></td><td><code>&nbsp }//end&nbsp CDCInitEP</code></td></tr>
<tr><td><code><i>   405</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   406</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   407</i> </code></td><td><code>&nbsp /**************************************************************************</code></td></tr>
<tr><td><code><i>   408</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:&nbsp void&nbsp CDCNotificationHandler(void)</code></td></tr>
<tr><td><code><i>   409</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:&nbsp Checks&nbsp for&nbsp changes&nbsp in&nbsp DSR&nbsp status&nbsp and&nbsp reports&nbsp them&nbsp to&nbsp the&nbsp USB&nbsp host.</code></td></tr>
<tr><td><code><i>   410</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:&nbsp Checks&nbsp for&nbsp changes&nbsp in&nbsp DSR&nbsp pin&nbsp state&nbsp and&nbsp reports&nbsp any&nbsp changes</code></td></tr>
<tr><td><code><i>   411</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp to&nbsp the&nbsp USB&nbsp host.&nbsp </code></td></tr>
<tr><td><code><i>   412</i> </code></td><td><code>&nbsp &nbsp&nbsp Conditions:&nbsp CDCInitEP()&nbsp must&nbsp have&nbsp been&nbsp called&nbsp previously,&nbsp prior&nbsp to&nbsp calling</code></td></tr>
<tr><td><code><i>   413</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CDCNotificationHandler()&nbsp for&nbsp the&nbsp first&nbsp time.</code></td></tr>
<tr><td><code><i>   414</i> </code></td><td><code>&nbsp &nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>   415</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp is&nbsp only&nbsp implemented&nbsp and&nbsp needed&nbsp when&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>   416</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB_CDC_SUPPORT_DSR_REPORTING&nbsp option&nbsp has&nbsp been&nbsp enabled.&nbsp&nbsp If&nbsp the&nbsp function&nbsp is</code></td></tr>
<tr><td><code><i>   417</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp enabled,&nbsp it&nbsp should&nbsp be&nbsp called&nbsp periodically&nbsp to&nbsp sample&nbsp the&nbsp DSR&nbsp pin&nbsp and&nbsp feed</code></td></tr>
<tr><td><code><i>   418</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp information&nbsp to&nbsp the&nbsp USB&nbsp host.&nbsp&nbsp This&nbsp can&nbsp be&nbsp done&nbsp by&nbsp calling&nbsp </code></td></tr>
<tr><td><code><i>   419</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp CDCNotificationHandler()&nbsp by&nbsp itself,&nbsp or,&nbsp by&nbsp calling&nbsp CDCTxService()&nbsp which</code></td></tr>
<tr><td><code><i>   420</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp also&nbsp calls&nbsp CDCNotificationHandler()&nbsp internally,&nbsp when&nbsp appropriate.</code></td></tr>
<tr><td><code><i>   421</i> </code></td><td><code>&nbsp &nbsp&nbsp **************************************************************************/</code></td></tr>
<tr><td><code><i>   422</i> </code></td><td><code>&nbsp #if&nbsp defined(USB_CDC_SUPPORT_DSR_REPORTING)</code></td></tr>
<tr><td><code><i>   423</i> </code></td><td><code>&nbsp void&nbsp CDCNotificationHandler(void)</code></td></tr>
<tr><td><code><i>   424</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   425</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //Check&nbsp the&nbsp DTS&nbsp I/O&nbsp pin&nbsp and&nbsp if&nbsp a&nbsp state&nbsp change&nbsp is&nbsp detected,&nbsp notify&nbsp the&nbsp </code></td></tr>
<tr><td><code><i>   426</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //USB&nbsp host&nbsp by&nbsp sending&nbsp a&nbsp serial&nbsp state&nbsp notification&nbsp element&nbsp packet.</code></td></tr>
<tr><td><code><i>   427</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(UART_DTS&nbsp ==&nbsp USB_CDC_DSR_ACTIVE_LEVEL)&nbsp //UART_DTS&nbsp must&nbsp be&nbsp defined&nbsp to&nbsp be&nbsp an&nbsp I/O&nbsp pin&nbsp in&nbsp the&nbsp hardware&nbsp profile&nbsp to&nbsp use&nbsp the&nbsp DTS&nbsp feature&nbsp (ex:&nbsp "PORTXbits.RXY")</code></td></tr>
<tr><td><code><i>   428</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   429</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SerialStateBitmap.bits.DSR&nbsp =&nbsp 1;</code></td></tr>
<tr><td><code><i>   430</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   431</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>   432</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   433</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SerialStateBitmap.bits.DSR&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   434</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   435</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   436</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //If&nbsp the&nbsp state&nbsp has&nbsp changed,&nbsp and&nbsp the&nbsp endpoint&nbsp is&nbsp available,&nbsp send&nbsp a&nbsp packet&nbsp to</code></td></tr>
<tr><td><code><i>   437</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp //notify&nbsp the&nbsp hUSB&nbsp host&nbsp of&nbsp the&nbsp change.</code></td></tr>
<tr><td><code><i>   438</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if((SerialStateBitmap.byte&nbsp !=&nbsp OldSerialStateBitmap.byte)&nbsp &&&nbsp (!USBHandleBusy(CDCNotificationInHandle)))</code></td></tr>
<tr><td><code><i>   439</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   440</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Copy&nbsp the&nbsp updated&nbsp value&nbsp into&nbsp the&nbsp USB&nbsp packet&nbsp buffer&nbsp to&nbsp send.</code></td></tr>
<tr><td><code><i>   441</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp SerialStatePacket.SerialState.byte&nbsp =&nbsp SerialStateBitmap.byte;</code></td></tr>
<tr><td><code><i>   442</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //We&nbsp don't&nbsp need&nbsp to&nbsp write&nbsp to&nbsp the&nbsp other&nbsp bytes&nbsp in&nbsp the&nbsp SerialStatePacket&nbsp USB</code></td></tr>
<tr><td><code><i>   443</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //buffer,&nbsp since&nbsp they&nbsp don't&nbsp change&nbsp and&nbsp will&nbsp always&nbsp be&nbsp the&nbsp same&nbsp as&nbsp our</code></td></tr>
<tr><td><code><i>   444</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //initialized&nbsp value.</code></td></tr>
<tr><td><code><i>   445</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   446</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Send&nbsp the&nbsp packet&nbsp over&nbsp USB&nbsp to&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>   447</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CDCNotificationInHandle&nbsp =&nbsp USBTransferOnePacket(CDC_COMM_EP,&nbsp IN_TO_HOST,&nbsp (uint8_t*)&SerialStatePacket,&nbsp sizeof(SERIAL_STATE_NOTIFICATION));</code></td></tr>
<tr><td><code><i>   448</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   449</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Save&nbsp the&nbsp old&nbsp value,&nbsp so&nbsp we&nbsp can&nbsp detect&nbsp changes&nbsp later.</code></td></tr>
<tr><td><code><i>   450</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp OldSerialStateBitmap.byte&nbsp =&nbsp SerialStateBitmap.byte;</code></td></tr>
<tr><td><code><i>   451</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   452</i> </code></td><td><code>&nbsp }//void&nbsp CDCNotificationHandler(void)&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   453</i> </code></td><td><code>&nbsp #else</code></td></tr>
<tr><td><code><i>   454</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp #define&nbsp CDCNotificationHandler()&nbsp {}</code></td></tr>
<tr><td><code><i>   455</i> </code></td><td><code>&nbsp #endif</code></td></tr>
<tr><td><code><i>   456</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   457</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   458</i> </code></td><td><code>&nbsp /**********************************************************************************</code></td></tr>
<tr><td><code><i>   459</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   460</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp bool&nbsp USBCDCEventHandler(USB_EVENT&nbsp event,&nbsp void&nbsp *pdata,&nbsp uint16_t&nbsp size)</code></td></tr>
<tr><td><code><i>   461</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   462</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>   463</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Handles&nbsp events&nbsp from&nbsp the&nbsp USB&nbsp stack,&nbsp which&nbsp may&nbsp have&nbsp an&nbsp effect&nbsp on&nbsp the&nbsp CDC&nbsp </code></td></tr>
<tr><td><code><i>   464</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp endpoint(s).</code></td></tr>
<tr><td><code><i>   465</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   466</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   467</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Handles&nbsp events&nbsp from&nbsp the&nbsp USB&nbsp stack.&nbsp&nbsp This&nbsp function&nbsp should&nbsp be&nbsp called&nbsp when&nbsp </code></td></tr>
<tr><td><code><i>   468</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp there&nbsp is&nbsp a&nbsp USB&nbsp event&nbsp that&nbsp needs&nbsp to&nbsp be&nbsp processed&nbsp by&nbsp the&nbsp CDC&nbsp driver.</code></td></tr>
<tr><td><code><i>   469</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   470</i> </code></td><td><code>&nbsp &nbsp&nbsp Conditions:</code></td></tr>
<tr><td><code><i>   471</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Value&nbsp of&nbsp input&nbsp argument&nbsp 'len'&nbsp should&nbsp be&nbsp smaller&nbsp than&nbsp the&nbsp maximum</code></td></tr>
<tr><td><code><i>   472</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp endpoint&nbsp size&nbsp responsible&nbsp for&nbsp receiving&nbsp bulk&nbsp data&nbsp from&nbsp USB&nbsp host&nbsp for&nbsp CDC</code></td></tr>
<tr><td><code><i>   473</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp class.&nbsp Input&nbsp argument&nbsp 'buffer'&nbsp should&nbsp point&nbsp to&nbsp a&nbsp buffer&nbsp area&nbsp that&nbsp is</code></td></tr>
<tr><td><code><i>   474</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp bigger&nbsp or&nbsp equal&nbsp to&nbsp the&nbsp size&nbsp specified&nbsp by&nbsp 'len'.</code></td></tr>
<tr><td><code><i>   475</i> </code></td><td><code>&nbsp &nbsp&nbsp Input:</code></td></tr>
<tr><td><code><i>   476</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp event&nbsp -&nbsp the&nbsp type&nbsp of&nbsp event&nbsp that&nbsp occured</code></td></tr>
<tr><td><code><i>   477</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp pdata&nbsp -&nbsp pointer&nbsp to&nbsp the&nbsp data&nbsp that&nbsp caused&nbsp the&nbsp event</code></td></tr>
<tr><td><code><i>   478</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp size&nbsp -&nbsp the&nbsp size&nbsp of&nbsp the&nbsp data&nbsp that&nbsp is&nbsp pointed&nbsp to&nbsp by&nbsp pdata</code></td></tr>
<tr><td><code><i>   479</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   480</i> </code></td><td><code>&nbsp &nbsp&nbsp **********************************************************************************/</code></td></tr>
<tr><td><code><i>   481</i> </code></td><td><code>&nbsp bool&nbsp USBCDCEventHandler(USB_EVENT&nbsp event,&nbsp void&nbsp *pdata,&nbsp uint16_t&nbsp size)</code></td></tr>
<tr><td><code><i>   482</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   483</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp switch(&nbsp (uint16_t)event&nbsp )</code></td></tr>
<tr><td><code><i>   484</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   485</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp case&nbsp EVENT_TRANSFER_TERMINATED:</code></td></tr>
<tr><td><code><i>   486</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(pdata&nbsp ==&nbsp CDCDataOutHandle)</code></td></tr>
<tr><td><code><i>   487</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   488</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CDCDataOutHandle&nbsp =&nbsp USBRxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_rx,sizeof(cdc_data_rx));</code></td></tr>
<tr><td><code><i>   489</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   490</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(pdata&nbsp ==&nbsp CDCDataInHandle)</code></td></tr>
<tr><td><code><i>   491</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   492</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //flush&nbsp all&nbsp of&nbsp the&nbsp data&nbsp in&nbsp the&nbsp CDC&nbsp buffer</code></td></tr>
<tr><td><code><i>   493</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp cdc_trf_state&nbsp =&nbsp CDC_TX_READY;</code></td></tr>
<tr><td><code><i>   494</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp cdc_tx_len&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   495</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   496</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp break;</code></td></tr>
<tr><td><code><i>   497</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp default:</code></td></tr>
<tr><td><code><i>   498</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return&nbsp false;</code></td></tr>
<tr><td><code><i>   499</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   500</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp return&nbsp true;</code></td></tr>
<tr><td><code><i>   501</i> </code></td><td><code>&nbsp }</code></td></tr>
<tr><td><code><i>   502</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   503</i> </code></td><td><code>&nbsp /**********************************************************************************</code></td></tr>
<tr><td><code><i>   504</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   505</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp uint8_t&nbsp getsUSBUSART(char&nbsp *buffer,&nbsp uint8_t&nbsp len)</code></td></tr>
<tr><td><code><i>   506</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   507</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>   508</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp getsUSBUSART&nbsp copies&nbsp a&nbsp string&nbsp of&nbsp BYTEs&nbsp received&nbsp through&nbsp USB&nbsp CDC&nbsp Bulk&nbsp OUT</code></td></tr>
<tr><td><code><i>   509</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp endpoint&nbsp to&nbsp a&nbsp user's&nbsp specified&nbsp location.&nbsp It&nbsp is&nbsp a&nbsp non-blocking&nbsp function.</code></td></tr>
<tr><td><code><i>   510</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp It&nbsp does&nbsp not&nbsp wait&nbsp for&nbsp data&nbsp if&nbsp there&nbsp is&nbsp no&nbsp data&nbsp available.&nbsp Instead&nbsp it</code></td></tr>
<tr><td><code><i>   511</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp returns&nbsp '0'&nbsp to&nbsp notify&nbsp the&nbsp caller&nbsp that&nbsp there&nbsp is&nbsp no&nbsp data&nbsp available.</code></td></tr>
<tr><td><code><i>   512</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   513</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   514</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp getsUSBUSART&nbsp copies&nbsp a&nbsp string&nbsp of&nbsp BYTEs&nbsp received&nbsp through&nbsp USB&nbsp CDC&nbsp Bulk&nbsp OUT</code></td></tr>
<tr><td><code><i>   515</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp endpoint&nbsp to&nbsp a&nbsp user's&nbsp specified&nbsp location.&nbsp It&nbsp is&nbsp a&nbsp non-blocking&nbsp function.</code></td></tr>
<tr><td><code><i>   516</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp It&nbsp does&nbsp not&nbsp wait&nbsp for&nbsp data&nbsp if&nbsp there&nbsp is&nbsp no&nbsp data&nbsp available.&nbsp Instead&nbsp it</code></td></tr>
<tr><td><code><i>   517</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp returns&nbsp '0'&nbsp to&nbsp notify&nbsp the&nbsp caller&nbsp that&nbsp there&nbsp is&nbsp no&nbsp data&nbsp available.</code></td></tr>
<tr><td><code><i>   518</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   519</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Typical&nbsp Usage:</code></td></tr>
<tr><td><code><i>   520</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  code&rsaquo  </code></td></tr>
<tr><td><code><i>   521</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp uint8_t&nbsp numBytes;</code></td></tr>
<tr><td><code><i>   522</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp uint8_t&nbsp buffer[64]</code></td></tr>
<tr><td><code><i>   523</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   524</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp numBytes&nbsp =&nbsp getsUSBUSART(buffer,sizeof(buffer));&nbsp //until&nbsp the&nbsp buffer&nbsp is&nbsp free.</code></td></tr>
<tr><td><code><i>   525</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(numBytes&nbsp \&rsaquo &nbsp 0)</code></td></tr>
<tr><td><code><i>   526</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   527</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //we&nbsp received&nbsp numBytes&nbsp bytes&nbsp of&nbsp data&nbsp and&nbsp they&nbsp are&nbsp copied&nbsp into</code></td></tr>
<tr><td><code><i>   528</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp the&nbsp "buffer"&nbsp variable.&nbsp&nbsp We&nbsp can&nbsp do&nbsp something&nbsp with&nbsp the&nbsp data</code></td></tr>
<tr><td><code><i>   529</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp here.</code></td></tr>
<tr><td><code><i>   530</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   531</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  /code&rsaquo  </code></td></tr>
<tr><td><code><i>   532</i> </code></td><td><code>&nbsp &nbsp&nbsp Conditions:</code></td></tr>
<tr><td><code><i>   533</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Value&nbsp of&nbsp input&nbsp argument&nbsp 'len'&nbsp should&nbsp be&nbsp smaller&nbsp than&nbsp the&nbsp maximum</code></td></tr>
<tr><td><code><i>   534</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp endpoint&nbsp size&nbsp responsible&nbsp for&nbsp receiving&nbsp bulk&nbsp data&nbsp from&nbsp USB&nbsp host&nbsp for&nbsp CDC</code></td></tr>
<tr><td><code><i>   535</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp class.&nbsp Input&nbsp argument&nbsp 'buffer'&nbsp should&nbsp point&nbsp to&nbsp a&nbsp buffer&nbsp area&nbsp that&nbsp is</code></td></tr>
<tr><td><code><i>   536</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp bigger&nbsp or&nbsp equal&nbsp to&nbsp the&nbsp size&nbsp specified&nbsp by&nbsp 'len'.</code></td></tr>
<tr><td><code><i>   537</i> </code></td><td><code>&nbsp &nbsp&nbsp Input:</code></td></tr>
<tr><td><code><i>   538</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp buffer&nbsp -&nbsp&nbsp Pointer&nbsp to&nbsp where&nbsp received&nbsp BYTEs&nbsp are&nbsp to&nbsp be&nbsp stored</code></td></tr>
<tr><td><code><i>   539</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp len&nbsp -&nbsp&nbsp&nbsp&nbsp&nbsp The&nbsp number&nbsp of&nbsp BYTEs&nbsp expected.</code></td></tr>
<tr><td><code><i>   540</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   541</i> </code></td><td><code>&nbsp &nbsp&nbsp **********************************************************************************/</code></td></tr>
<tr><td><code><i>   542</i> </code></td><td><code>&nbsp uint8_t&nbsp getsUSBUSART(uint8_t&nbsp *buffer,&nbsp uint8_t&nbsp len)</code></td></tr>
<tr><td><code><i>   543</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   544</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp cdc_rx_len&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   545</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   546</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(!USBHandleBusy(CDCDataOutHandle))</code></td></tr>
<tr><td><code><i>   547</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   548</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   549</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Adjust&nbsp the&nbsp expected&nbsp number&nbsp of&nbsp BYTEs&nbsp to&nbsp equal</code></td></tr>
<tr><td><code><i>   550</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp the&nbsp actual&nbsp number&nbsp of&nbsp BYTEs&nbsp received.</code></td></tr>
<tr><td><code><i>   551</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   552</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(len&nbsp&rsaquo &nbsp USBHandleGetLength(CDCDataOutHandle))</code></td></tr>
<tr><td><code><i>   553</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp len&nbsp =&nbsp USBHandleGetLength(CDCDataOutHandle);</code></td></tr>
<tr><td><code><i>   554</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   555</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   556</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Copy&nbsp data&nbsp from&nbsp dual-ram&nbsp buffer&nbsp to&nbsp user's&nbsp buffer</code></td></tr>
<tr><td><code><i>   557</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   558</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp for(cdc_rx_len&nbsp =&nbsp 0;&nbsp cdc_rx_len&nbsp&lsaquo &nbsp len;&nbsp cdc_rx_len++)</code></td></tr>
<tr><td><code><i>   559</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp buffer[cdc_rx_len]&nbsp =&nbsp cdc_data_rx[cdc_rx_len];</code></td></tr>
<tr><td><code><i>   560</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   561</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   562</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Prepare&nbsp dual-ram&nbsp buffer&nbsp for&nbsp next&nbsp OUT&nbsp transaction</code></td></tr>
<tr><td><code><i>   563</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   564</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   565</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CDCDataOutHandle&nbsp =&nbsp USBRxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_rx,sizeof(cdc_data_rx));</code></td></tr>
<tr><td><code><i>   566</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   567</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp if</code></td></tr>
<tr><td><code><i>   568</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   569</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp return&nbsp cdc_rx_len;</code></td></tr>
<tr><td><code><i>   570</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   571</i> </code></td><td><code>&nbsp }//end&nbsp getsUSBUSART</code></td></tr>
<tr><td><code><i>   572</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   573</i> </code></td><td><code>&nbsp /******************************************************************************</code></td></tr>
<tr><td><code><i>   574</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   575</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp putUSBUSART(char&nbsp *data,&nbsp uint8_t&nbsp length)</code></td></tr>
<tr><td><code><i>   576</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   577</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>   578</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp putUSBUSART&nbsp writes&nbsp an&nbsp array&nbsp of&nbsp data&nbsp to&nbsp the&nbsp USB.&nbsp Use&nbsp this&nbsp version,&nbsp is</code></td></tr>
<tr><td><code><i>   579</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp capable&nbsp of&nbsp transfering&nbsp 0x00&nbsp (what&nbsp is&nbsp typically&nbsp a&nbsp NULL&nbsp character&nbsp in&nbsp any&nbsp of</code></td></tr>
<tr><td><code><i>   580</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp string&nbsp transfer&nbsp functions).</code></td></tr>
<tr><td><code><i>   581</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   582</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   583</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp putUSBUSART&nbsp writes&nbsp an&nbsp array&nbsp of&nbsp data&nbsp to&nbsp the&nbsp USB.&nbsp Use&nbsp this&nbsp version,&nbsp is</code></td></tr>
<tr><td><code><i>   584</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp capable&nbsp of&nbsp transfering&nbsp 0x00&nbsp (what&nbsp is&nbsp typically&nbsp a&nbsp NULL&nbsp character&nbsp in&nbsp any&nbsp of</code></td></tr>
<tr><td><code><i>   585</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp string&nbsp transfer&nbsp functions).</code></td></tr>
<tr><td><code><i>   586</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   587</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Typical&nbsp Usage:</code></td></tr>
<tr><td><code><i>   588</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  code&rsaquo  </code></td></tr>
<tr><td><code><i>   589</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBUSARTIsTxTrfReady())</code></td></tr>
<tr><td><code><i>   590</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   591</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp char&nbsp data[]&nbsp =&nbsp {0x00,&nbsp 0x01,&nbsp 0x02,&nbsp 0x03,&nbsp 0x04};</code></td></tr>
<tr><td><code><i>   592</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp putUSBUSART(data,5);</code></td></tr>
<tr><td><code><i>   593</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   594</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  /code&rsaquo  </code></td></tr>
<tr><td><code><i>   595</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   596</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp The&nbsp transfer&nbsp mechanism&nbsp for&nbsp device-to-host(put)&nbsp is&nbsp more&nbsp flexible&nbsp than</code></td></tr>
<tr><td><code><i>   597</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp host-to-device(get).&nbsp It&nbsp can&nbsp handle&nbsp a&nbsp string&nbsp of&nbsp data&nbsp larger&nbsp than&nbsp the</code></td></tr>
<tr><td><code><i>   598</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp maximum&nbsp size&nbsp of&nbsp bulk&nbsp IN&nbsp endpoint.&nbsp A&nbsp state&nbsp machine&nbsp is&nbsp used&nbsp to&nbsp transfer&nbsp a</code></td></tr>
<tr><td><code><i>   599</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp \long&nbsp string&nbsp of&nbsp data&nbsp over&nbsp multiple&nbsp USB&nbsp transactions.&nbsp CDCTxService()</code></td></tr>
<tr><td><code><i>   600</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp must&nbsp be&nbsp called&nbsp periodically&nbsp to&nbsp keep&nbsp sending&nbsp blocks&nbsp of&nbsp data&nbsp to&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>   601</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   602</i> </code></td><td><code>&nbsp &nbsp&nbsp Conditions:</code></td></tr>
<tr><td><code><i>   603</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBUSARTIsTxTrfReady()&nbsp must&nbsp return&nbsp true.&nbsp This&nbsp indicates&nbsp that&nbsp the&nbsp last</code></td></tr>
<tr><td><code><i>   604</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp transfer&nbsp is&nbsp complete&nbsp and&nbsp is&nbsp ready&nbsp to&nbsp receive&nbsp a&nbsp new&nbsp block&nbsp of&nbsp data.&nbsp The</code></td></tr>
<tr><td><code><i>   605</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp string&nbsp of&nbsp characters&nbsp pointed&nbsp to&nbsp by&nbsp 'data'&nbsp must&nbsp equal&nbsp to&nbsp or&nbsp smaller&nbsp than</code></td></tr>
<tr><td><code><i>   606</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp 255&nbsp BYTEs.</code></td></tr>
<tr><td><code><i>   607</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   608</i> </code></td><td><code>&nbsp &nbsp&nbsp Input:</code></td></tr>
<tr><td><code><i>   609</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp char&nbsp *data&nbsp -&nbsp pointer&nbsp to&nbsp a&nbsp RAM&nbsp array&nbsp of&nbsp data&nbsp to&nbsp be&nbsp transfered&nbsp to&nbsp the&nbsp host</code></td></tr>
<tr><td><code><i>   610</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp length&nbsp -&nbsp the&nbsp number&nbsp of&nbsp bytes&nbsp to&nbsp be&nbsp transfered&nbsp (must&nbsp be&nbsp less&nbsp than&nbsp 255).</code></td></tr>
<tr><td><code><i>   611</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   612</i> </code></td><td><code>&nbsp &nbsp *****************************************************************************/</code></td></tr>
<tr><td><code><i>   613</i> </code></td><td><code>&nbsp void&nbsp putUSBUSART(uint8_t&nbsp *data,&nbsp uint8_t&nbsp&nbsp length)</code></td></tr>
<tr><td><code><i>   614</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   615</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   616</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp User&nbsp should&nbsp have&nbsp checked&nbsp that&nbsp cdc_trf_state&nbsp is&nbsp in&nbsp CDC_TX_READY&nbsp state</code></td></tr>
<tr><td><code><i>   617</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp before&nbsp calling&nbsp this&nbsp function.</code></td></tr>
<tr><td><code><i>   618</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp As&nbsp a&nbsp safety&nbsp precaution,&nbsp this&nbsp fuction&nbsp checks&nbsp the&nbsp state&nbsp one&nbsp more&nbsp time</code></td></tr>
<tr><td><code><i>   619</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp to&nbsp make&nbsp sure&nbsp it&nbsp does&nbsp not&nbsp override&nbsp any&nbsp pending&nbsp transactions.</code></td></tr>
<tr><td><code><i>   620</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   621</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Currently&nbsp it&nbsp just&nbsp quits&nbsp the&nbsp routine&nbsp without&nbsp reporting&nbsp any&nbsp errors&nbsp back</code></td></tr>
<tr><td><code><i>   622</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp to&nbsp the&nbsp user.</code></td></tr>
<tr><td><code><i>   623</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   624</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Bottomline:&nbsp User&nbsp MUST&nbsp make&nbsp sure&nbsp that&nbsp USBUSARTIsTxTrfReady()==1</code></td></tr>
<tr><td><code><i>   625</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp before&nbsp calling&nbsp this&nbsp function!</code></td></tr>
<tr><td><code><i>   626</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Example:</code></td></tr>
<tr><td><code><i>   627</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp if(USBUSARTIsTxTrfReady())</code></td></tr>
<tr><td><code><i>   628</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp putUSBUSART(pData,&nbsp Length);</code></td></tr>
<tr><td><code><i>   629</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   630</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp IMPORTANT:&nbsp Never&nbsp use&nbsp the&nbsp following&nbsp blocking&nbsp while&nbsp loop&nbsp to&nbsp wait:</code></td></tr>
<tr><td><code><i>   631</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp while(!USBUSARTIsTxTrfReady())</code></td></tr>
<tr><td><code><i>   632</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp putUSBUSART(pData,&nbsp Length);</code></td></tr>
<tr><td><code><i>   633</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   634</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp The&nbsp whole&nbsp firmware&nbsp framework&nbsp is&nbsp written&nbsp based&nbsp on&nbsp cooperative</code></td></tr>
<tr><td><code><i>   635</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp multi-tasking&nbsp and&nbsp a&nbsp blocking&nbsp code&nbsp is&nbsp not&nbsp acceptable.</code></td></tr>
<tr><td><code><i>   636</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Use&nbsp a&nbsp state&nbsp machine&nbsp instead.</code></td></tr>
<tr><td><code><i>   637</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   638</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBMaskInterrupts();</code></td></tr>
<tr><td><code><i>   639</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(cdc_trf_state&nbsp ==&nbsp CDC_TX_READY)</code></td></tr>
<tr><td><code><i>   640</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   641</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp mUSBUSARTTxRam((uint8_t*)data,&nbsp length);&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp See&nbsp cdc.h</code></td></tr>
<tr><td><code><i>   642</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   643</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBUnmaskInterrupts();</code></td></tr>
<tr><td><code><i>   644</i> </code></td><td><code>&nbsp }//end&nbsp putUSBUSART</code></td></tr>
<tr><td><code><i>   645</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   646</i> </code></td><td><code>&nbsp /******************************************************************************</code></td></tr>
<tr><td><code><i>   647</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   648</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp putsUSBUSART(char&nbsp *data)</code></td></tr>
<tr><td><code><i>   649</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   650</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>   651</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp putsUSBUSART&nbsp writes&nbsp a&nbsp string&nbsp of&nbsp data&nbsp to&nbsp the&nbsp USB&nbsp including&nbsp the&nbsp null</code></td></tr>
<tr><td><code><i>   652</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp character.&nbsp Use&nbsp this&nbsp version,&nbsp 'puts',&nbsp to&nbsp transfer&nbsp data&nbsp from&nbsp a&nbsp RAM&nbsp buffer.</code></td></tr>
<tr><td><code><i>   653</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   654</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   655</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp putsUSBUSART&nbsp writes&nbsp a&nbsp string&nbsp of&nbsp data&nbsp to&nbsp the&nbsp USB&nbsp including&nbsp the&nbsp null</code></td></tr>
<tr><td><code><i>   656</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp character.&nbsp Use&nbsp this&nbsp version,&nbsp 'puts',&nbsp to&nbsp transfer&nbsp data&nbsp from&nbsp a&nbsp RAM&nbsp buffer.</code></td></tr>
<tr><td><code><i>   657</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   658</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Typical&nbsp Usage:</code></td></tr>
<tr><td><code><i>   659</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  code&rsaquo  </code></td></tr>
<tr><td><code><i>   660</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBUSARTIsTxTrfReady())</code></td></tr>
<tr><td><code><i>   661</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   662</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp char&nbsp data[]&nbsp =&nbsp "Hello&nbsp World";</code></td></tr>
<tr><td><code><i>   663</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp putsUSBUSART(data);</code></td></tr>
<tr><td><code><i>   664</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   665</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  /code&rsaquo  </code></td></tr>
<tr><td><code><i>   666</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   667</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp The&nbsp transfer&nbsp mechanism&nbsp for&nbsp device-to-host(put)&nbsp is&nbsp more&nbsp flexible&nbsp than</code></td></tr>
<tr><td><code><i>   668</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp host-to-device(get).&nbsp It&nbsp can&nbsp handle&nbsp a&nbsp string&nbsp of&nbsp data&nbsp larger&nbsp than&nbsp the</code></td></tr>
<tr><td><code><i>   669</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp maximum&nbsp size&nbsp of&nbsp bulk&nbsp IN&nbsp endpoint.&nbsp A&nbsp state&nbsp machine&nbsp is&nbsp used&nbsp to&nbsp transfer&nbsp a</code></td></tr>
<tr><td><code><i>   670</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp \long&nbsp string&nbsp of&nbsp data&nbsp over&nbsp multiple&nbsp USB&nbsp transactions.&nbsp CDCTxService()</code></td></tr>
<tr><td><code><i>   671</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp must&nbsp be&nbsp called&nbsp periodically&nbsp to&nbsp keep&nbsp sending&nbsp blocks&nbsp of&nbsp data&nbsp to&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>   672</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   673</i> </code></td><td><code>&nbsp &nbsp&nbsp Conditions:</code></td></tr>
<tr><td><code><i>   674</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBUSARTIsTxTrfReady()&nbsp must&nbsp return&nbsp true.&nbsp This&nbsp indicates&nbsp that&nbsp the&nbsp last</code></td></tr>
<tr><td><code><i>   675</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp transfer&nbsp is&nbsp complete&nbsp and&nbsp is&nbsp ready&nbsp to&nbsp receive&nbsp a&nbsp new&nbsp block&nbsp of&nbsp data.&nbsp The</code></td></tr>
<tr><td><code><i>   676</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp string&nbsp of&nbsp characters&nbsp pointed&nbsp to&nbsp by&nbsp 'data'&nbsp must&nbsp equal&nbsp to&nbsp or&nbsp smaller&nbsp than</code></td></tr>
<tr><td><code><i>   677</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp 255&nbsp BYTEs.</code></td></tr>
<tr><td><code><i>   678</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   679</i> </code></td><td><code>&nbsp &nbsp&nbsp Input:</code></td></tr>
<tr><td><code><i>   680</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp char&nbsp *data&nbsp -&nbsp&nbsp null\-terminated&nbsp string&nbsp of&nbsp constant&nbsp data.&nbsp If&nbsp a</code></td></tr>
<tr><td><code><i>   681</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp null&nbsp character&nbsp is&nbsp not&nbsp found,&nbsp 255&nbsp BYTEs&nbsp of&nbsp data</code></td></tr>
<tr><td><code><i>   682</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp will&nbsp be&nbsp transferred&nbsp to&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>   683</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   684</i> </code></td><td><code>&nbsp &nbsp *****************************************************************************/</code></td></tr>
<tr><td><code><i>   685</i> </code></td><td><code>&nbsp &nbsp </code></td></tr>
<tr><td><code><i>   686</i> </code></td><td><code>&nbsp void&nbsp putsUSBUSART(char&nbsp *data)</code></td></tr>
<tr><td><code><i>   687</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   688</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp len;</code></td></tr>
<tr><td><code><i>   689</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp char&nbsp *pData;</code></td></tr>
<tr><td><code><i>   690</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   691</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   692</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp User&nbsp should&nbsp have&nbsp checked&nbsp that&nbsp cdc_trf_state&nbsp is&nbsp in&nbsp CDC_TX_READY&nbsp state</code></td></tr>
<tr><td><code><i>   693</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp before&nbsp calling&nbsp this&nbsp function.</code></td></tr>
<tr><td><code><i>   694</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp As&nbsp a&nbsp safety&nbsp precaution,&nbsp this&nbsp fuction&nbsp checks&nbsp the&nbsp state&nbsp one&nbsp more&nbsp time</code></td></tr>
<tr><td><code><i>   695</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp to&nbsp make&nbsp sure&nbsp it&nbsp does&nbsp not&nbsp override&nbsp any&nbsp pending&nbsp transactions.</code></td></tr>
<tr><td><code><i>   696</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   697</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Currently&nbsp it&nbsp just&nbsp quits&nbsp the&nbsp routine&nbsp without&nbsp reporting&nbsp any&nbsp errors&nbsp back</code></td></tr>
<tr><td><code><i>   698</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp to&nbsp the&nbsp user.</code></td></tr>
<tr><td><code><i>   699</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   700</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Bottomline:&nbsp User&nbsp MUST&nbsp make&nbsp sure&nbsp that&nbsp USBUSARTIsTxTrfReady()==1</code></td></tr>
<tr><td><code><i>   701</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp before&nbsp calling&nbsp this&nbsp function!</code></td></tr>
<tr><td><code><i>   702</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Example:</code></td></tr>
<tr><td><code><i>   703</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp if(USBUSARTIsTxTrfReady())</code></td></tr>
<tr><td><code><i>   704</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp putsUSBUSART(pData,&nbsp Length);</code></td></tr>
<tr><td><code><i>   705</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   706</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp IMPORTANT:&nbsp Never&nbsp use&nbsp the&nbsp following&nbsp blocking&nbsp while&nbsp loop&nbsp to&nbsp wait:</code></td></tr>
<tr><td><code><i>   707</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp while(!USBUSARTIsTxTrfReady())</code></td></tr>
<tr><td><code><i>   708</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp putsUSBUSART(pData);</code></td></tr>
<tr><td><code><i>   709</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   710</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp The&nbsp whole&nbsp firmware&nbsp framework&nbsp is&nbsp written&nbsp based&nbsp on&nbsp cooperative</code></td></tr>
<tr><td><code><i>   711</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp multi-tasking&nbsp and&nbsp a&nbsp blocking&nbsp code&nbsp is&nbsp not&nbsp acceptable.</code></td></tr>
<tr><td><code><i>   712</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Use&nbsp a&nbsp state&nbsp machine&nbsp instead.</code></td></tr>
<tr><td><code><i>   713</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   714</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBMaskInterrupts();</code></td></tr>
<tr><td><code><i>   715</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(cdc_trf_state&nbsp !=&nbsp CDC_TX_READY)</code></td></tr>
<tr><td><code><i>   716</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   717</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBUnmaskInterrupts();</code></td></tr>
<tr><td><code><i>   718</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return;</code></td></tr>
<tr><td><code><i>   719</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   720</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   721</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   722</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp While&nbsp loop&nbsp counts&nbsp the&nbsp number&nbsp of&nbsp BYTEs&nbsp to&nbsp send&nbsp including&nbsp the</code></td></tr>
<tr><td><code><i>   723</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp null&nbsp character.</code></td></tr>
<tr><td><code><i>   724</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   725</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp len&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   726</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp pData&nbsp =&nbsp data;</code></td></tr>
<tr><td><code><i>   727</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp do</code></td></tr>
<tr><td><code><i>   728</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   729</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp len++;</code></td></tr>
<tr><td><code><i>   730</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(len&nbsp ==&nbsp 255)&nbsp break;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Break&nbsp loop&nbsp once&nbsp max&nbsp len&nbsp is&nbsp reached.</code></td></tr>
<tr><td><code><i>   731</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }while(*pData++);</code></td></tr>
<tr><td><code><i>   732</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   733</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   734</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Second&nbsp piece&nbsp of&nbsp information&nbsp (length&nbsp of&nbsp data&nbsp to&nbsp send)&nbsp is&nbsp ready.</code></td></tr>
<tr><td><code><i>   735</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Call&nbsp mUSBUSARTTxRam&nbsp to&nbsp setup&nbsp the&nbsp transfer.</code></td></tr>
<tr><td><code><i>   736</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp The&nbsp actual&nbsp transfer&nbsp process&nbsp will&nbsp be&nbsp handled&nbsp by&nbsp CDCTxService(),</code></td></tr>
<tr><td><code><i>   737</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp which&nbsp should&nbsp be&nbsp called&nbsp once&nbsp per&nbsp Main&nbsp Program&nbsp loop.</code></td></tr>
<tr><td><code><i>   738</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   739</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp mUSBUSARTTxRam((uint8_t*)data,&nbsp len);&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp See&nbsp cdc.h</code></td></tr>
<tr><td><code><i>   740</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBUnmaskInterrupts();</code></td></tr>
<tr><td><code><i>   741</i> </code></td><td><code>&nbsp }//end&nbsp putsUSBUSART</code></td></tr>
<tr><td><code><i>   742</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   743</i> </code></td><td><code>&nbsp /**************************************************************************</code></td></tr>
<tr><td><code><i>   744</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   745</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp putrsUSBUSART(const&nbsp const&nbsp char&nbsp *data)</code></td></tr>
<tr><td><code><i>   746</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   747</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>   748</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp putrsUSBUSART&nbsp writes&nbsp a&nbsp string&nbsp of&nbsp data&nbsp to&nbsp the&nbsp USB&nbsp including&nbsp the&nbsp null</code></td></tr>
<tr><td><code><i>   749</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp character.&nbsp Use&nbsp this&nbsp version,&nbsp 'putrs',&nbsp to&nbsp transfer&nbsp data&nbsp literals&nbsp and</code></td></tr>
<tr><td><code><i>   750</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp data&nbsp located&nbsp in&nbsp program&nbsp memory.</code></td></tr>
<tr><td><code><i>   751</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   752</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   753</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp putrsUSBUSART&nbsp writes&nbsp a&nbsp string&nbsp of&nbsp data&nbsp to&nbsp the&nbsp USB&nbsp including&nbsp the&nbsp null</code></td></tr>
<tr><td><code><i>   754</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp character.&nbsp Use&nbsp this&nbsp version,&nbsp 'putrs',&nbsp to&nbsp transfer&nbsp data&nbsp literals&nbsp and</code></td></tr>
<tr><td><code><i>   755</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp data&nbsp located&nbsp in&nbsp program&nbsp memory.</code></td></tr>
<tr><td><code><i>   756</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   757</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Typical&nbsp Usage:</code></td></tr>
<tr><td><code><i>   758</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  code&rsaquo  </code></td></tr>
<tr><td><code><i>   759</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(USBUSARTIsTxTrfReady())</code></td></tr>
<tr><td><code><i>   760</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   761</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp putrsUSBUSART("Hello&nbsp World");</code></td></tr>
<tr><td><code><i>   762</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   763</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  /code&rsaquo  </code></td></tr>
<tr><td><code><i>   764</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   765</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp The&nbsp transfer&nbsp mechanism&nbsp for&nbsp device-to-host(put)&nbsp is&nbsp more&nbsp flexible&nbsp than</code></td></tr>
<tr><td><code><i>   766</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp host-to-device(get).&nbsp It&nbsp can&nbsp handle&nbsp a&nbsp string&nbsp of&nbsp data&nbsp larger&nbsp than&nbsp the</code></td></tr>
<tr><td><code><i>   767</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp maximum&nbsp size&nbsp of&nbsp bulk&nbsp IN&nbsp endpoint.&nbsp A&nbsp state&nbsp machine&nbsp is&nbsp used&nbsp to&nbsp transfer&nbsp a</code></td></tr>
<tr><td><code><i>   768</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp \long&nbsp string&nbsp of&nbsp data&nbsp over&nbsp multiple&nbsp USB&nbsp transactions.&nbsp CDCTxService()</code></td></tr>
<tr><td><code><i>   769</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp must&nbsp be&nbsp called&nbsp periodically&nbsp to&nbsp keep&nbsp sending&nbsp blocks&nbsp of&nbsp data&nbsp to&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>   770</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   771</i> </code></td><td><code>&nbsp &nbsp&nbsp Conditions:</code></td></tr>
<tr><td><code><i>   772</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBUSARTIsTxTrfReady()&nbsp must&nbsp return&nbsp true.&nbsp This&nbsp indicates&nbsp that&nbsp the&nbsp last</code></td></tr>
<tr><td><code><i>   773</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp transfer&nbsp is&nbsp complete&nbsp and&nbsp is&nbsp ready&nbsp to&nbsp receive&nbsp a&nbsp new&nbsp block&nbsp of&nbsp data.&nbsp The</code></td></tr>
<tr><td><code><i>   774</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp string&nbsp of&nbsp characters&nbsp pointed&nbsp to&nbsp by&nbsp 'data'&nbsp must&nbsp equal&nbsp to&nbsp or&nbsp smaller&nbsp than</code></td></tr>
<tr><td><code><i>   775</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp 255&nbsp BYTEs.</code></td></tr>
<tr><td><code><i>   776</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   777</i> </code></td><td><code>&nbsp &nbsp&nbsp Input:</code></td></tr>
<tr><td><code><i>   778</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp const&nbsp const&nbsp char&nbsp *data&nbsp -&nbsp&nbsp null\-terminated&nbsp string&nbsp of&nbsp constant&nbsp data.&nbsp If&nbsp a</code></td></tr>
<tr><td><code><i>   779</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp null&nbsp character&nbsp is&nbsp not&nbsp found,&nbsp 255&nbsp uint8_ts&nbsp of&nbsp data</code></td></tr>
<tr><td><code><i>   780</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp will&nbsp be&nbsp transferred&nbsp to&nbsp the&nbsp host.</code></td></tr>
<tr><td><code><i>   781</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   782</i> </code></td><td><code>&nbsp &nbsp&nbsp **************************************************************************/</code></td></tr>
<tr><td><code><i>   783</i> </code></td><td><code>&nbsp void&nbsp putrsUSBUSART(const&nbsp const&nbsp char&nbsp *data)</code></td></tr>
<tr><td><code><i>   784</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   785</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp len;</code></td></tr>
<tr><td><code><i>   786</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp const&nbsp const&nbsp char&nbsp *pData;</code></td></tr>
<tr><td><code><i>   787</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   788</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   789</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp User&nbsp should&nbsp have&nbsp checked&nbsp that&nbsp cdc_trf_state&nbsp is&nbsp in&nbsp CDC_TX_READY&nbsp state</code></td></tr>
<tr><td><code><i>   790</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp before&nbsp calling&nbsp this&nbsp function.</code></td></tr>
<tr><td><code><i>   791</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp As&nbsp a&nbsp safety&nbsp precaution,&nbsp this&nbsp fuction&nbsp checks&nbsp the&nbsp state&nbsp one&nbsp more&nbsp time</code></td></tr>
<tr><td><code><i>   792</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp to&nbsp make&nbsp sure&nbsp it&nbsp does&nbsp not&nbsp override&nbsp any&nbsp pending&nbsp transactions.</code></td></tr>
<tr><td><code><i>   793</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   794</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Currently&nbsp it&nbsp just&nbsp quits&nbsp the&nbsp routine&nbsp without&nbsp reporting&nbsp any&nbsp errors&nbsp back</code></td></tr>
<tr><td><code><i>   795</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp to&nbsp the&nbsp user.</code></td></tr>
<tr><td><code><i>   796</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   797</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Bottomline:&nbsp User&nbsp MUST&nbsp make&nbsp sure&nbsp that&nbsp USBUSARTIsTxTrfReady()</code></td></tr>
<tr><td><code><i>   798</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp before&nbsp calling&nbsp this&nbsp function!</code></td></tr>
<tr><td><code><i>   799</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Example:</code></td></tr>
<tr><td><code><i>   800</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp if(USBUSARTIsTxTrfReady())</code></td></tr>
<tr><td><code><i>   801</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp putsUSBUSART(pData);</code></td></tr>
<tr><td><code><i>   802</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   803</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp IMPORTANT:&nbsp Never&nbsp use&nbsp the&nbsp following&nbsp blocking&nbsp while&nbsp loop&nbsp to&nbsp wait:</code></td></tr>
<tr><td><code><i>   804</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp while(cdc_trf_state&nbsp !=&nbsp CDC_TX_READY)</code></td></tr>
<tr><td><code><i>   805</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp&nbsp&nbsp&nbsp&nbsp putsUSBUSART(pData);</code></td></tr>
<tr><td><code><i>   806</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *</code></td></tr>
<tr><td><code><i>   807</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp The&nbsp whole&nbsp firmware&nbsp framework&nbsp is&nbsp written&nbsp based&nbsp on&nbsp cooperative</code></td></tr>
<tr><td><code><i>   808</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp multi-tasking&nbsp and&nbsp a&nbsp blocking&nbsp code&nbsp is&nbsp not&nbsp acceptable.</code></td></tr>
<tr><td><code><i>   809</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Use&nbsp a&nbsp state&nbsp machine&nbsp instead.</code></td></tr>
<tr><td><code><i>   810</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   811</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBMaskInterrupts();</code></td></tr>
<tr><td><code><i>   812</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(cdc_trf_state&nbsp !=&nbsp CDC_TX_READY)</code></td></tr>
<tr><td><code><i>   813</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   814</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBUnmaskInterrupts();</code></td></tr>
<tr><td><code><i>   815</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return;</code></td></tr>
<tr><td><code><i>   816</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   817</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   818</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   819</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp While&nbsp loop&nbsp counts&nbsp the&nbsp number&nbsp of&nbsp BYTEs&nbsp to&nbsp send&nbsp including&nbsp the</code></td></tr>
<tr><td><code><i>   820</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp null&nbsp character.</code></td></tr>
<tr><td><code><i>   821</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   822</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp len&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   823</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp pData&nbsp =&nbsp data;</code></td></tr>
<tr><td><code><i>   824</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp do</code></td></tr>
<tr><td><code><i>   825</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   826</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp len++;</code></td></tr>
<tr><td><code><i>   827</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(len&nbsp ==&nbsp 255)&nbsp break;&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Break&nbsp loop&nbsp once&nbsp max&nbsp len&nbsp is&nbsp reached.</code></td></tr>
<tr><td><code><i>   828</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }while(*pData++);</code></td></tr>
<tr><td><code><i>   829</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   830</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   831</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Second&nbsp piece&nbsp of&nbsp information&nbsp (length&nbsp of&nbsp data&nbsp to&nbsp send)&nbsp is&nbsp ready.</code></td></tr>
<tr><td><code><i>   832</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Call&nbsp mUSBUSARTTxRom&nbsp to&nbsp setup&nbsp the&nbsp transfer.</code></td></tr>
<tr><td><code><i>   833</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp The&nbsp actual&nbsp transfer&nbsp process&nbsp will&nbsp be&nbsp handled&nbsp by&nbsp CDCTxService(),</code></td></tr>
<tr><td><code><i>   834</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp which&nbsp should&nbsp be&nbsp called&nbsp once&nbsp per&nbsp Main&nbsp Program&nbsp loop.</code></td></tr>
<tr><td><code><i>   835</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   836</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   837</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp mUSBUSARTTxRom((const&nbsp uint8_t*)data,len);&nbsp //&nbsp See&nbsp cdc.h</code></td></tr>
<tr><td><code><i>   838</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBUnmaskInterrupts();</code></td></tr>
<tr><td><code><i>   839</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   840</i> </code></td><td><code>&nbsp }//end&nbsp putrsUSBUSART</code></td></tr>
<tr><td><code><i>   841</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   842</i> </code></td><td><code>&nbsp /************************************************************************</code></td></tr>
<tr><td><code><i>   843</i> </code></td><td><code>&nbsp &nbsp&nbsp Function:</code></td></tr>
<tr><td><code><i>   844</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp void&nbsp CDCTxService(void)</code></td></tr>
<tr><td><code><i>   845</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   846</i> </code></td><td><code>&nbsp &nbsp&nbsp Summary:</code></td></tr>
<tr><td><code><i>   847</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp CDCTxService&nbsp handles&nbsp device-to-host&nbsp transaction(s).&nbsp This&nbsp function</code></td></tr>
<tr><td><code><i>   848</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp should&nbsp be&nbsp called&nbsp once&nbsp per&nbsp Main&nbsp Program&nbsp loop&nbsp after&nbsp the&nbsp device&nbsp reaches</code></td></tr>
<tr><td><code><i>   849</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp configured&nbsp state.</code></td></tr>
<tr><td><code><i>   850</i> </code></td><td><code>&nbsp &nbsp&nbsp Description:</code></td></tr>
<tr><td><code><i>   851</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp CDCTxService&nbsp handles&nbsp device-to-host&nbsp transaction(s).&nbsp This&nbsp function</code></td></tr>
<tr><td><code><i>   852</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp should&nbsp be&nbsp called&nbsp once&nbsp per&nbsp Main&nbsp Program&nbsp loop&nbsp after&nbsp the&nbsp device&nbsp reaches</code></td></tr>
<tr><td><code><i>   853</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp the&nbsp configured&nbsp state&nbsp (after&nbsp the&nbsp CDCIniEP()&nbsp function&nbsp has&nbsp already&nbsp executed).</code></td></tr>
<tr><td><code><i>   854</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp This&nbsp function&nbsp is&nbsp needed,&nbsp in&nbsp order&nbsp to&nbsp advance&nbsp the&nbsp internal&nbsp software&nbsp state&nbsp </code></td></tr>
<tr><td><code><i>   855</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp machine&nbsp that&nbsp takes&nbsp care&nbsp of&nbsp sending&nbsp multiple&nbsp transactions&nbsp worth&nbsp of&nbsp IN&nbsp USB</code></td></tr>
<tr><td><code><i>   856</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp data&nbsp to&nbsp the&nbsp host,&nbsp associated&nbsp with&nbsp CDC&nbsp serial&nbsp data.&nbsp&nbsp Failure&nbsp to&nbsp call&nbsp </code></td></tr>
<tr><td><code><i>   857</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp CDCTxService()&nbsp perioidcally&nbsp will&nbsp prevent&nbsp data&nbsp from&nbsp being&nbsp sent&nbsp to&nbsp the</code></td></tr>
<tr><td><code><i>   858</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USB&nbsp host,&nbsp over&nbsp the&nbsp CDC&nbsp serial&nbsp data&nbsp interface.</code></td></tr>
<tr><td><code><i>   859</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   860</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp Typical&nbsp Usage:</code></td></tr>
<tr><td><code><i>   861</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  code&rsaquo  </code></td></tr>
<tr><td><code><i>   862</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp void&nbsp main(void)</code></td></tr>
<tr><td><code><i>   863</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   864</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceInit();</code></td></tr>
<tr><td><code><i>   865</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp while(1)</code></td></tr>
<tr><td><code><i>   866</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   867</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBDeviceTasks();</code></td></tr>
<tr><td><code><i>   868</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if((USBGetDeviceState()&nbsp \&lsaquo &nbsp CONFIGURED_STATE)&nbsp ||</code></td></tr>
<tr><td><code><i>   869</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp (USBIsDeviceSuspended()&nbsp ==&nbsp true))</code></td></tr>
<tr><td><code><i>   870</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   871</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Either&nbsp the&nbsp device&nbsp is&nbsp not&nbsp configured&nbsp or&nbsp we&nbsp are&nbsp suspended</code></td></tr>
<tr><td><code><i>   872</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp&nbsp so&nbsp we&nbsp don't&nbsp want&nbsp to&nbsp do&nbsp execute&nbsp any&nbsp application&nbsp code</code></td></tr>
<tr><td><code><i>   873</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp continue;&nbsp&nbsp&nbsp //go&nbsp back&nbsp to&nbsp the&nbsp top&nbsp of&nbsp the&nbsp while&nbsp loop</code></td></tr>
<tr><td><code><i>   874</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   875</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>   876</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   877</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Keep&nbsp trying&nbsp to&nbsp send&nbsp data&nbsp to&nbsp the&nbsp PC&nbsp as&nbsp required</code></td></tr>
<tr><td><code><i>   878</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CDCTxService();</code></td></tr>
<tr><td><code><i>   879</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   880</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //Run&nbsp application&nbsp code.</code></td></tr>
<tr><td><code><i>   881</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp UserApplication();</code></td></tr>
<tr><td><code><i>   882</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   883</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   884</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   885</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&lsaquo  /code&rsaquo  </code></td></tr>
<tr><td><code><i>   886</i> </code></td><td><code>&nbsp &nbsp&nbsp Conditions:</code></td></tr>
<tr><td><code><i>   887</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp CDCIniEP()&nbsp function&nbsp should&nbsp have&nbsp already&nbsp executed/the&nbsp device&nbsp should&nbsp be</code></td></tr>
<tr><td><code><i>   888</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp in&nbsp the&nbsp CONFIGURED_STATE.</code></td></tr>
<tr><td><code><i>   889</i> </code></td><td><code>&nbsp &nbsp&nbsp Remarks:</code></td></tr>
<tr><td><code><i>   890</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp None&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   891</i> </code></td><td><code>&nbsp &nbsp&nbsp ************************************************************************/</code></td></tr>
<tr><td><code><i>   892</i> </code></td><td><code>&nbsp &nbsp </code></td></tr>
<tr><td><code><i>   893</i> </code></td><td><code>&nbsp void&nbsp CDCTxService(void)</code></td></tr>
<tr><td><code><i>   894</i> </code></td><td><code>&nbsp {</code></td></tr>
<tr><td><code><i>   895</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp byte_to_send;</code></td></tr>
<tr><td><code><i>   896</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp uint8_t&nbsp i;</code></td></tr>
<tr><td><code><i>   897</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   898</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBMaskInterrupts();</code></td></tr>
<tr><td><code><i>   899</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   900</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp CDCNotificationHandler();</code></td></tr>
<tr><td><code><i>   901</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   902</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(USBHandleBusy(CDCDataInHandle))&nbsp </code></td></tr>
<tr><td><code><i>   903</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   904</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBUnmaskInterrupts();</code></td></tr>
<tr><td><code><i>   905</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return;</code></td></tr>
<tr><td><code><i>   906</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   907</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   908</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   909</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Completing&nbsp stage&nbsp is&nbsp necessary&nbsp while&nbsp [&nbsp mCDCUSartTxIsBusy()==1&nbsp ].</code></td></tr>
<tr><td><code><i>   910</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp By&nbsp having&nbsp this&nbsp stage,&nbsp user&nbsp can&nbsp always&nbsp check&nbsp cdc_trf_state,</code></td></tr>
<tr><td><code><i>   911</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp and&nbsp not&nbsp having&nbsp to&nbsp call&nbsp mCDCUsartTxIsBusy()&nbsp directly.</code></td></tr>
<tr><td><code><i>   912</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   913</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(cdc_trf_state&nbsp ==&nbsp CDC_TX_COMPLETING)</code></td></tr>
<tr><td><code><i>   914</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp cdc_trf_state&nbsp =&nbsp CDC_TX_READY;</code></td></tr>
<tr><td><code><i>   915</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   916</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   917</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp If&nbsp CDC_TX_READY&nbsp state,&nbsp nothing&nbsp to&nbsp do,&nbsp just&nbsp return.</code></td></tr>
<tr><td><code><i>   918</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   919</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(cdc_trf_state&nbsp ==&nbsp CDC_TX_READY)</code></td></tr>
<tr><td><code><i>   920</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   921</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp USBUnmaskInterrupts();</code></td></tr>
<tr><td><code><i>   922</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp return;</code></td></tr>
<tr><td><code><i>   923</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   924</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   925</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   926</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp If&nbsp CDC_TX_BUSY_ZLP&nbsp state,&nbsp send&nbsp zero&nbsp length&nbsp packet</code></td></tr>
<tr><td><code><i>   927</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   928</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp if(cdc_trf_state&nbsp ==&nbsp CDC_TX_BUSY_ZLP)</code></td></tr>
<tr><td><code><i>   929</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   930</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CDCDataInHandle&nbsp =&nbsp USBTxOnePacket(CDC_DATA_EP,NULL,0);</code></td></tr>
<tr><td><code><i>   931</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //CDC_DATA_BD_IN.CNT&nbsp =&nbsp 0;</code></td></tr>
<tr><td><code><i>   932</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp cdc_trf_state&nbsp =&nbsp CDC_TX_COMPLETING;</code></td></tr>
<tr><td><code><i>   933</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   934</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp else&nbsp if(cdc_trf_state&nbsp ==&nbsp CDC_TX_BUSY)</code></td></tr>
<tr><td><code><i>   935</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   936</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   937</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp First,&nbsp have&nbsp to&nbsp figure&nbsp out&nbsp how&nbsp many&nbsp byte&nbsp of&nbsp data&nbsp to&nbsp send.</code></td></tr>
<tr><td><code><i>   938</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   939</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp if(cdc_tx_len&nbsp&rsaquo &nbsp sizeof(cdc_data_tx))</code></td></tr>
<tr><td><code><i>   940</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp byte_to_send&nbsp =&nbsp sizeof(cdc_data_tx);</code></td></tr>
<tr><td><code><i>   941</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>   942</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp &nbsp&nbsp&nbsp&nbsp byte_to_send&nbsp =&nbsp cdc_tx_len;</code></td></tr>
<tr><td><code><i>   943</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   944</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   945</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Subtract&nbsp the&nbsp number&nbsp of&nbsp bytes&nbsp just&nbsp about&nbsp to&nbsp be&nbsp sent&nbsp from&nbsp the&nbsp total.</code></td></tr>
<tr><td><code><i>   946</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   947</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp cdc_tx_len&nbsp =&nbsp cdc_tx_len&nbsp -&nbsp byte_to_send;</code></td></tr>
<tr><td><code><i>   948</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp &nbsp&nbsp&nbsp &nbsp&nbsp </code></td></tr>
<tr><td><code><i>   949</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pCDCDst.bRam&nbsp =&nbsp (uint8_t*)&cdc_data_tx;&nbsp //&nbsp Set&nbsp destination&nbsp pointer</code></td></tr>
<tr><td><code><i>   950</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   951</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i&nbsp =&nbsp byte_to_send;</code></td></tr>
<tr><td><code><i>   952</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(cdc_mem_type&nbsp ==&nbsp USB_EP0_ROM)&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp //&nbsp Determine&nbsp type&nbsp of&nbsp memory&nbsp source</code></td></tr>
<tr><td><code><i>   953</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   954</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp while(i)</code></td></tr>
<tr><td><code><i>   955</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   956</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *pCDCDst.bRam&nbsp =&nbsp *pCDCSrc.bRom;</code></td></tr>
<tr><td><code><i>   957</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pCDCDst.bRam++;</code></td></tr>
<tr><td><code><i>   958</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pCDCSrc.bRom++;</code></td></tr>
<tr><td><code><i>   959</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i--;</code></td></tr>
<tr><td><code><i>   960</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }//end&nbsp while(byte_to_send)</code></td></tr>
<tr><td><code><i>   961</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   962</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>   963</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   964</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp while(i)</code></td></tr>
<tr><td><code><i>   965</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   966</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *pCDCDst.bRam&nbsp =&nbsp *pCDCSrc.bRam;</code></td></tr>
<tr><td><code><i>   967</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pCDCDst.bRam++;</code></td></tr>
<tr><td><code><i>   968</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp pCDCSrc.bRam++;</code></td></tr>
<tr><td><code><i>   969</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp i--;</code></td></tr>
<tr><td><code><i>   970</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   971</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }</code></td></tr>
<tr><td><code><i>   972</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   973</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp /*</code></td></tr>
<tr><td><code><i>   974</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp Lastly,&nbsp determine&nbsp if&nbsp a&nbsp zero&nbsp length&nbsp packet&nbsp state&nbsp is&nbsp necessary.</code></td></tr>
<tr><td><code><i>   975</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp *&nbsp See&nbsp explanation&nbsp in&nbsp USB&nbsp Specification&nbsp 2.0:&nbsp Section&nbsp 5.8.3</code></td></tr>
<tr><td><code><i>   976</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp */</code></td></tr>
<tr><td><code><i>   977</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(cdc_tx_len&nbsp ==&nbsp 0)</code></td></tr>
<tr><td><code><i>   978</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp {</code></td></tr>
<tr><td><code><i>   979</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp if(byte_to_send&nbsp ==&nbsp CDC_DATA_IN_EP_SIZE)</code></td></tr>
<tr><td><code><i>   980</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp cdc_trf_state&nbsp =&nbsp CDC_TX_BUSY_ZLP;</code></td></tr>
<tr><td><code><i>   981</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp else</code></td></tr>
<tr><td><code><i>   982</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp cdc_trf_state&nbsp =&nbsp CDC_TX_COMPLETING;</code></td></tr>
<tr><td><code><i>   983</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp }//end&nbsp if(cdc_tx_len...)</code></td></tr>
<tr><td><code><i>   984</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp CDCDataInHandle&nbsp =&nbsp USBTxOnePacket(CDC_DATA_EP,(uint8_t*)&cdc_data_tx,byte_to_send);</code></td></tr>
<tr><td><code><i>   985</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   986</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp }//end&nbsp if(cdc_tx_sate&nbsp ==&nbsp CDC_TX_BUSY)</code></td></tr>
<tr><td><code><i>   987</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp </code></td></tr>
<tr><td><code><i>   988</i> </code></td><td><code>&nbsp &nbsp&nbsp&nbsp&nbsp USBUnmaskInterrupts();</code></td></tr>
<tr><td><code><i>   989</i> </code></td><td><code>&nbsp }//end&nbsp CDCTxService</code></td></tr>
<tr><td><code><i>   990</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   991</i> </code></td><td><code>&nbsp #endif&nbsp //USB_USE_CDC</code></td></tr>
<tr><td><code><i>   992</i> </code></td><td><code>&nbsp </code></td></tr>
<tr><td><code><i>   993</i> </code></td><td><code>&nbsp /**&nbsp EOF&nbsp cdc.c&nbsp ****************************************************************/</code></code></BODY>
</HTML>
